(*
 * @(#)control.cgd	1.2 06/08/22
 * Generated by Compiler Generator for PEAS.
 * 
 * (c) COPYRIGHT 2001 
 * Osaka University. Written by Shinsuke KOBAYASHI.
 * All rights reserved.
 *)

(***** added by S.Kobayashi, 2002/03/28 ****)
REWR e:mirCompare(b:mirConvert(c:_), d:_) -> a:mirCompare(c, d);
CALC {
  a.Relation = e.Relation;
}

REWR e:mirCompare(a:_, b:mirConvert(c:_)) -> d:mirCompare(a, c);
CALC {
  d.Relation = e.Relation;
}

REWR f:mirCompare(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirCompare(b, d);
CALC {
  e.Relation = f.Relation;
}

(********* end added **************)

RULE    xirBarrier;
BARRIER;
EMIT {
      addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
      addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
      addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

RULE  o:xirReg -> GPR RESTRICT {gcg_RegToRegSet(o.Reg)};
CLASS   NOCODE;
CONDITION {
        o.Nt == ntGPR
}

RULE [comp2cc34] c:mirCompare(l:GPR, r:GPR) -> cc:cc;
CONDITION {
     IS_POINTER_OR_INT(mirEXPR_get_Type(c.Left))
}
WRITE REGISTERS <GPR27>;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
EMIT {       
    mirRELATION	temp;
    temp = c.Relation;
     cc.rs1  = l;
     cc.rs2  = r;
    cc.isEqOrNeq = 0;
    cc.cond = cc_ne;

	addInsnInfo_RSRSR( state,
		condToCompareInsn(rel_to_cond(temp, 
     		mirEXPR_get_Type(c.Left))),
		RegGPR27,
		SCHED_STRING_0,
		l,
		SCHED_STRING_0,
		r,
		gcg_cycle );
};

RULE [comp2cc35] c:mirCompare(l:GPR, r:mirIntConst) -> cc:ccid;
CONDITION {
     IS_IMMEDIATE16(mirEXPR_get_Type(c.Left))
	&&
(	(c.Relation == Equal)
	||
	(c.Relation == GreaterEqual)
	||
	(c.Relation == Greater)
	||
	(c.Relation == LessEqual)
	||
	(c.Relation == Less)
	||
	(c.Relation == UnEqual)
	)
}
WRITE REGISTERS <GPR27>;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
EMIT {       
    mirRELATION	temp;
    temp = c.Relation;
     cc.rs1  = l;
     cc.immd  = UnivInt_to_int(r.Value);
    cc.isEqOrNeq = 0;
    cc.cond = cc_ne;

	addInsnInfo_RSRSI( state,
		condToCompareImmdInsn(rel_to_cond(temp, 
     		mirEXPR_get_Type(c.Left))),
		RegGPR27,
		SCHED_STRING_0,
		l,
		SCHED_STRING_0,
		UnivInt_to_int(r.Value),
		gcg_cycle );
};

(****************************************************
 *  Branch instructions.
 ****************************************************)

RULE [branch_cond] mirIf (            
             c:cc,
             t:mirObjectAddr,
             e:mirObjectAddr
     );
CONTROL branch;
EMIT {
     mirBasicBlock   Then = (mirBasicBlock) t.Obj;
     mirBasicBlock   Else = (mirBasicBlock) e.Obj;
     cond_t          cond = c.cond;

	addInsnInfo_RSA( state,
		condToSchedCondBooleanBranch(cond),
		RegGPR27,
		SCHED_STRING_0,
		Then,
		gcg_cycle );

	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
     addInsnInfo_A( state,
                 SCHED_OP_j,
                 Else,
                 gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

RULE [branch_cond_const] mirIf (            
             c:ccid,
             t:mirObjectAddr,
             e:mirObjectAddr
     );
CONTROL branch;
EMIT {
     mirBasicBlock   Then = (mirBasicBlock) t.Obj;
     mirBasicBlock   Else = (mirBasicBlock) e.Obj;
     cond_t          cond = c.cond;

	addInsnInfo_RSA( state,
		condToSchedCondBooleanBranch(cond),
		c.rs1,
		SCHED_STRING_0,
		Then,
		gcg_cycle );

	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
     addInsnInfo_A( state,
                 SCHED_OP_j,
                 Else,
                 gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

(****************************************************
 *  JUMP instructions.
 ****************************************************)

RULE [j_targetIsNext] o:mirGoto (b:mirObjectAddr);
CONDITION {
o.TargetIsNext
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
CONTROL branch;
EMIT {
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

RULE [j] o:mirGoto (b:mirObjectAddr);
CONDITION {
!o.TargetIsNext
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
CONTROL branch;
EMIT {
     mirBasicBlock   To = (mirBasicBlock) b.Obj;
        addInsnInfo_A( state,
                       SCHED_OP_j,
                       To,
                       gcg_cycle );
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
        addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

RULE [jr19] o:mirGoto (b:GPR);
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
CONTROL branch;
EMIT {
        addInsnInfo_R( state,
                  SCHED_OP_jr,
                  b,
                  gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);

}


(****************************************************
 *  Function call instructions.
 ****************************************************)

RULE [funccall17] xirFuncCall(
const__:mirObjectAddr,
	a:INPUT {
		gcg_reg_restriction = gcg_RegToRegSet(`gcg_expr->Reg),
		`gcg_expr->Nt
	}
)->
GPR<GPR28>;
CHANGE { get_changed_set(const__) }
BARRIER;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	int size = state->outarg_frame_size / 8;
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_Ap( state,
		SCHED_OP_jal,
		const__.Obj,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
}
RULE [funccallReg18] f:xirFuncCall(
rs0:GPR,
	a:INPUT {
		gcg_reg_restriction = gcg_RegToRegSet(`gcg_expr->Reg),
		`gcg_expr->Nt
	}
)->GPR<GPR28>;
CHANGE { get_changed_set(mirEXPR_xirFuncCall_get_Proc(f)) }
BARRIER;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	int size = state->outarg_frame_size / 8;
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_R( state,
		SCHED_OP_jalr,
		rs0,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
}
(****************************************************
 *  Call instructions.
 ****************************************************)

RULE [call17] mirCall(
const__     :mirObjectAddr,
     a:INPUT {
             gcg_reg_restriction = gcg_RegToRegSet(`gcg_expr->Reg),
             `gcg_expr->Nt
     }
);
CHANGE { get_changed_set(const__) }
BARRIER;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	int size = state->outarg_frame_size / 8;
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_Ap( state,
		SCHED_OP_jal,
		const__.Obj,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
RULE [callReg18] f:mirCall(
rs0:GPR,
     a:INPUT {
             gcg_reg_restriction = gcg_RegToRegSet(`gcg_expr->Reg),
             `gcg_expr->Nt
     }
);
CHANGE { get_changed_set(mirSTMT_mirCall_get_Proc(f)) }
BARRIER;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	int size = state->outarg_frame_size / 8;
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_R( state,
		SCHED_OP_jalr,
		rs0,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
if (size > 0){
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		size,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
(****************************************************
 *  Return instructions.
 ****************************************************)

RULE [ret_GPR_j_targetIsNext]  o:mirReturn (GPR<GPR28>,  n:mirObjectAddr);
CONDITION {
	o.TargetIsNext
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
CONTROL branch;
EMIT {
}
RULE [ret_GPR_j]  o:mirReturn (GPR<GPR28>,  n:mirObjectAddr);
CONDITION {
	!o.TargetIsNext
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
CONTROL branch;
EMIT {
	mirBasicBlock   To = (mirBasicBlock) n.Obj;
        addInsnInfo_A( state,
                       SCHED_OP_j,
                       To,
                      gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}
RULE [arg33] o:mirActual ( rs:GPR) -> memarg;
CONDITION {
IS_IMMEDIATE8(mirEXPR_get_Type(o.Value))}
COST 1;
EMIT {
     int offset;

     offset = - UnivInt_to_int(o.Offset) / 8;

	addInsnInfo_RbiSR( state,
		SCHED_OP_sb,
		RegGPR29,
		offset,
		SCHED_STRING_0,
		rs,
		gcg_cycle );

}

RULE [arg42] o:mirActual ( rs:GPR) -> memarg;
CONDITION {
IS_IMMEDIATE16(mirEXPR_get_Type(o.Value))}
COST 1;
EMIT {
     int offset;

     offset = - UnivInt_to_int(o.Offset) / 8;

	addInsnInfo_RbiSR( state,
		SCHED_OP_sh,
		RegGPR29,
		offset,
		SCHED_STRING_0,
		rs,
		gcg_cycle );

}

RULE [arg61] o:mirActual ( rs:GPR) -> memarg;
CONDITION {
IS_IMMEDIATE32(mirEXPR_get_Type(o.Value))}
COST 1;
EMIT {
     int offset;

     offset = - UnivInt_to_int(o.Offset) / 8;

	addInsnInfo_RbiSR( state,
		SCHED_OP_sw,
		RegGPR29,
		offset,
		SCHED_STRING_0,
		rs,
		gcg_cycle );

}

(****************************************************
 *  Argument instructions.
 ****************************************************)

RULE [regarg] o:mirActual(rs:GPR) -> rd:GPR;
RESULT rs;

RULE [prologue] mirBeginProcedure;
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
POSTBARRIER;
EMIT {
     NAME name;
     gcgRegisterSet             usedregs;
     gcgRegister                reg;
     int                        count = 0;

     name = mirProcGlobal_get_Name(state->proc);
     usedregs = state->tobesaved;

	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_RbiSR( state,
		SCHED_OP_sw,
		RegGPR29,
		-4,
		SCHED_STRING_0,
		RegGPR30,
		gcg_cycle );
	addInsnInfo_RbiSR( state,
		SCHED_OP_sw,
		RegGPR29,
		0,
		SCHED_STRING_0,
		RegGPR31,
		gcg_cycle );
	addInsnInfo_RSRSI( state,
		SCHED_OP_subui,
		RegGPR30,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		4,
		gcg_cycle );

        gcg_RegSetLoop(usedregs, reg) {

	  if ( 
	   ( reg != RegGPR28 ) 
	  ) {
	addInsnInfo_RbiSR( state,
		SCHED_OP_sw,
		RegGPR29,
		( state->local_frame_size - state->spill_frame_size ) / 8 - 4 * count - 8,
		SCHED_STRING_0,
		reg,
		gcg_cycle );
            count += 1;
          }

        } gcg_RegSetEndLoop;

	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);  // Added due to hardware problems with this part
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR29,
		SCHED_STRING_0,
		-(( state->local_frame_size - state->spill_frame_size ) / 8 - 4 * count - 8),
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}

RULE [end] mirEndProcedure;
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
EMIT {
    gcgRegisterSet             usedregs;
    gcgRegister                reg;
    int                        count;

    usedregs = state->tobesaved;
    count = gcg_RegSetCard(usedregs);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);

	gcg_RegSetLoop(usedregs, reg) {
	  if ( 
	   ( reg == RegGPR28 ) 
	  ) {
	    count--;
	  }
	} gcg_RegSetEndLoop;


	gcg_RegSetLoop(usedregs, reg) {
	  if ( 
	   ( reg != RegGPR28 ) 
	  ) {
	addInsnInfo_RSRbi( state,
		SCHED_OP_lw,
		reg,
		SCHED_STRING_0,
		RegGPR29,
		4*count,
		gcg_cycle );
	    count--;
	  }
	} gcg_RegSetEndLoop;

	addInsnInfo_RSRbi( state,
		SCHED_OP_lw,
		RegGPR31,
		SCHED_STRING_0,
		RegGPR30,
		4,
		gcg_cycle );
	addInsnInfo_RSRSI( state,
		SCHED_OP_addui,
		RegGPR29,
		SCHED_STRING_0,
		RegGPR30,
		SCHED_STRING_0,
		4,
		gcg_cycle );
	addInsnInfo_RSRbi( state,
		SCHED_OP_lw,
		RegGPR30,
		SCHED_STRING_0,
		RegGPR30,
		0,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
        addInsnInfo_R( state,
                       SCHED_OP_jr,
                       RegGPR31,
                       gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
}


REWR mirReturn (mirNoExpr, o:mirObjectAddr) -> mirGoto (o);


REWR bv:mirBoolVal (bc:mirBoolConst) -> ic:mirIntConst;
CALC {
        ic.Type         = bv.Type;
        if (bc.Value) {
                ic.Value = bv.True;
        } else {
                ic.Value = bv.False;
        }
}

REWR i:mirIf (
        bc:mirBoolConst,
        t:mirObjectAddr,
        e:mirObjectAddr
) -> g:mirGoto (e);
CONDITION {
        ! bc.Value
}
CALC {
        g.Origin        = i.Origin;
}
REWR i:mirIf (
        bc:mirBoolConst,
        t:mirObjectAddr,
        e:mirObjectAddr
) -> g:mirGoto (t);
CONDITION {
        bc.Value
}
CALC {
        g.Origin        = i.Origin;
}
(*
 * Insertion points
 *)

INSERTS

IpGcg_match_sdl {

// view for dynamic INPUT clause
domain matchActual : mirActual + [name(mirActual)]
        + <
                Reg             [READ]  : gcgRegister,
                Nt              [READ]  : gcgNonTerminal
        >;

// view for dynamic NONTERMINAL clause
domain matchTYPE : mirTYPE + [name(mirTYPE)]
        + {
                mirProcType
                <
                        Nt              [READ]  : gcgNonTerminal
                >
        };
}

IpGcgMatcher_c {

static gcgRegister get_result_nt(`.mirEXPR Proc)
{
        return `Proc->Type->mirPointer.RefType->mirProcType.Nt;
}

}


IpGcgMatcher_c + IpGcgCover_c {

static gcgNonTerminal get_return_nt(`.mirProcGlobal Proc)
{
        return `Proc->Type->mirProcType.Nt;
}

}

IpGcgCover_c {

gcgRegisterSet get_changed_set(`.mirEXPR Proc)
{
        return `Proc->Type->mirPointer.RefType->mirProcType.ChangedByCallee;
}

static gcgRegister get_result_reg(`.mirEXPR Proc)
{
        return `Proc->Type->mirPointer.RefType->mirProcType.Reg;
}

static gcgRegister get_return_reg(`.mirProcGlobal Proc)
{
        return `Proc->Type->mirProcType.Reg;
}

}
