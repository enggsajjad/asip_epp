(*
 * @(#)arith.cgd	1.2 06/08/22
 * Generated by Compiler Generator for PEAS.
 * 
 * (c) COPYRIGHT 2001 
 * Osaka University. Written by Shinsuke KOBAYASHI.
 * All rights reserved.
 *)
(****************************************************
 *  ADD instructions.
 ****************************************************)

RULE [add_0] add:mirPlus(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(add.Type) || IS_SHORT(add.Type) || IS_SHORT(add.Type) || IS_LONG(add.Type) || IS_LONG(add.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_add,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [addi_0] addi:mirPlus(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(addi.Type) || IS_SHORT(addi.Type) || IS_SHORT(addi.Type) || IS_LONG(addi.Type) || IS_LONG(addi.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_S16(const__)||VALUERANGE_S16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


RULE [addu_0] addu:mirPlus(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(addu.Type) || IS_USHORT(addu.Type) || IS_USHORT(addu.Type) || IS_ULONG(addu.Type) || IS_ULONG(addu.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_addu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [addui_0] addui:mirPlus(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_UCHAR(addui.Type) || IS_USHORT(addui.Type) || IS_USHORT(addui.Type) || IS_ULONG(addui.Type) || IS_ULONG(addui.Type))
 && (VALUERANGE_U8(const__)||VALUERANGE_U16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_addui,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  SUB instructions.
 ****************************************************)

RULE [sub_0] sub:mirDiff(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(sub.Type) || IS_SHORT(sub.Type) || IS_SHORT(sub.Type) || IS_LONG(sub.Type) || IS_LONG(sub.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_sub,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [subi_0] subi:mirDiff(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(subi.Type) || IS_SHORT(subi.Type) || IS_SHORT(subi.Type) || IS_LONG(subi.Type) || IS_LONG(subi.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_S16(const__)||VALUERANGE_S16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


RULE [subu_0] subu:mirDiff(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(subu.Type) || IS_USHORT(subu.Type) || IS_USHORT(subu.Type) || IS_ULONG(subu.Type) || IS_ULONG(subu.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_subu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [subui_0] subui:mirDiff(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_UCHAR(subui.Type) || IS_USHORT(subui.Type) || IS_USHORT(subui.Type) || IS_ULONG(subui.Type) || IS_ULONG(subui.Type))
 && (VALUERANGE_U8(const__)||VALUERANGE_U16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_subui,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  MULT instructions.
 ****************************************************)

RULE [mult_0] mult:mirMult(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(mult.Type) || IS_SHORT(mult.Type) || IS_SHORT(mult.Type) || IS_LONG(mult.Type) || IS_LONG(mult.Type))

}
PRODUCER mult_out;
CONSUMER mult_in;
TEMPLATE mult_op;
COST 33;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_mult,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [multu_0] multu:mirMult(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(multu.Type) || IS_USHORT(multu.Type) || IS_USHORT(multu.Type) || IS_ULONG(multu.Type) || IS_ULONG(multu.Type))

}
PRODUCER mult_out;
CONSUMER mult_in;
TEMPLATE mult_op;
COST 33;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_multu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


(****************************************************
 *  DIV instructions.
 ****************************************************)

RULE [div_0] div:mirDiv(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(div.Type) || IS_SHORT(div.Type) || IS_SHORT(div.Type) || IS_LONG(div.Type) || IS_LONG(div.Type))

}
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
COST 32;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_div,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [divu_0] divu:mirDiv(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(divu.Type) || IS_USHORT(divu.Type) || IS_USHORT(divu.Type) || IS_ULONG(divu.Type) || IS_ULONG(divu.Type))

}
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
COST 32;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_divu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


(****************************************************
 *  MOD instructions.
 ****************************************************)

RULE [MOD_0] MOD:mirMod(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(MOD.Type) || IS_SHORT(MOD.Type) || IS_SHORT(MOD.Type) || IS_LONG(MOD.Type) || IS_LONG(MOD.Type))

}
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
COST 32;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_MOD,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [modu_0] modu:mirMod(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(modu.Type) || IS_USHORT(modu.Type) || IS_USHORT(modu.Type) || IS_ULONG(modu.Type) || IS_ULONG(modu.Type))

}
PRODUCER MOD_out;
CONSUMER MOD_in;
TEMPLATE MOD_op;
COST 32;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_modu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


(****************************************************
 *  SHIFT instructions.
 ****************************************************)

RULE [sll_0] sll:mirShiftLeft(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(sll.Type) || IS_UCHAR(sll.Type) || IS_SHORT(sll.Type) || IS_USHORT(sll.Type) || IS_USHORT(sll.Type) || IS_USHORT(sll.Type) || IS_LONG(sll.Type) || IS_ULONG(sll.Type) || IS_ULONG(sll.Type) || IS_ULONG(sll.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_sll,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [slli_0] slli:mirShiftLeft(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(slli.Type) || IS_UCHAR(slli.Type) || IS_SHORT(slli.Type) || IS_USHORT(slli.Type) || IS_USHORT(slli.Type) || IS_USHORT(slli.Type) || IS_LONG(slli.Type) || IS_ULONG(slli.Type) || IS_ULONG(slli.Type) || IS_ULONG(slli.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_slli,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


RULE [srl_0] srl:mirShiftRight(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_UCHAR(srl.Type) || IS_USHORT(srl.Type) || IS_ULONG(srl.Type) )

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_srl,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [srli_0] srli:mirShiftRight(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_UCHAR(srli.Type) || IS_USHORT(srli.Type) || IS_ULONG(srli.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_srli,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


RULE [sra_0] sra:mirShiftRightSign(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(sra.Type) || IS_SHORT(sra.Type) || IS_LONG(sra.Type) )

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_sra,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [srai_0] srai:mirShiftRightSign(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(srai.Type) || IS_SHORT(srai.Type) || IS_LONG(srai.Type) )
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_srai,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  AND instructions.
 ****************************************************)

RULE [and_0] and:mirAnd(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(and.Type) || IS_UCHAR(and.Type) || IS_SHORT(and.Type) || IS_USHORT(and.Type) || IS_USHORT(and.Type) || IS_USHORT(and.Type) || IS_LONG(and.Type) || IS_ULONG(and.Type) || IS_ULONG(and.Type) || IS_ULONG(and.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_and,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [andi_0] andi:mirAnd(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(andi.Type) || IS_UCHAR(andi.Type) || IS_SHORT(andi.Type) || IS_USHORT(andi.Type) || IS_USHORT(andi.Type) || IS_USHORT(andi.Type) || IS_LONG(andi.Type) || IS_ULONG(andi.Type) || IS_ULONG(andi.Type) || IS_ULONG(andi.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_andi,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  OR instructions.
 ****************************************************)

RULE [or_0] or:mirOr(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(or.Type) || IS_UCHAR(or.Type) || IS_SHORT(or.Type) || IS_USHORT(or.Type) || IS_USHORT(or.Type) || IS_USHORT(or.Type) || IS_LONG(or.Type) || IS_ULONG(or.Type) || IS_ULONG(or.Type) || IS_ULONG(or.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_or,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [ori_0] ori:mirOr(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(ori.Type) || IS_UCHAR(ori.Type) || IS_SHORT(ori.Type) || IS_USHORT(ori.Type) || IS_USHORT(ori.Type) || IS_USHORT(ori.Type) || IS_LONG(ori.Type) || IS_ULONG(ori.Type) || IS_ULONG(ori.Type) || IS_ULONG(ori.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_ori,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  XOR instructions.
 ****************************************************)

RULE [xor_0] xor:mirXor(rs0:GPR, rs1:GPR) -> rd:GPR;
CONDITION {
(IS_CHAR(xor.Type) || IS_UCHAR(xor.Type) || IS_SHORT(xor.Type) || IS_USHORT(xor.Type) || IS_USHORT(xor.Type) || IS_USHORT(xor.Type) || IS_LONG(xor.Type) || IS_ULONG(xor.Type) || IS_ULONG(xor.Type) || IS_ULONG(xor.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_xor,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [xori_0] xori:mirXor(rs0:GPR, const__:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(xori.Type) || IS_UCHAR(xori.Type) || IS_SHORT(xori.Type) || IS_USHORT(xori.Type) || IS_USHORT(xori.Type) || IS_USHORT(xori.Type) || IS_LONG(xori.Type) || IS_ULONG(xori.Type) || IS_ULONG(xori.Type) || IS_ULONG(xori.Type))
 && (VALUERANGE_S8(const__)||VALUERANGE_U8(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__)||VALUERANGE_S16(const__)||VALUERANGE_U16(const__))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_xori,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		UnivInt_to_int(const__.Value),
		gcg_cycle );
}


(****************************************************
 *  NOT instructions.
 ****************************************************)

RULE [NOT3]addi:mirNot(a:GPR) -> b:GPR;
CONDITION {
(IS_CHAR(addi.Type) || IS_SHORT(addi.Type) || IS_SHORT(addi.Type) || IS_LONG(addi.Type) || IS_LONG(addi.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_addi,
		b,
		SCHED_STRING_0,
		a,
		SCHED_STRING_0,
		1,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_RSRSR( state,
		SCHED_OP_subu,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		b,
		gcg_cycle );
}


RULE [NOT5]addui:mirNot(a:GPR) -> b:GPR;
CONDITION {
(IS_UCHAR(addui.Type) || IS_USHORT(addui.Type) || IS_USHORT(addui.Type) || IS_ULONG(addui.Type) || IS_ULONG(addui.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_addui,
		b,
		SCHED_STRING_0,
		a,
		SCHED_STRING_0,
		1,
		gcg_cycle );
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_NOP(state, SCHED_OP_NOP_DUMMY, gcg_cycle);
	addInsnInfo_RSRSR( state,
		SCHED_OP_subu,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		b,
		gcg_cycle );
}


(****************************************************
 *  NEG instructions.
 ****************************************************)

RULE [NEG57] sub:mirNeg(a:GPR) -> b:GPR;
CONDITION {
(IS_CHAR(sub.Type) || IS_SHORT(sub.Type) || IS_SHORT(sub.Type) || IS_LONG(sub.Type) || IS_LONG(sub.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_sub,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		a,
		gcg_cycle );
}


RULE [NEG58] subi:mirNeg(a:GPR) -> b:GPR;
CONDITION {
(IS_CHAR(subi.Type) || IS_SHORT(subi.Type) || IS_SHORT(subi.Type) || IS_LONG(subi.Type) || IS_LONG(subi.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_subi,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		0,
		gcg_cycle );
}


RULE [NEG59] subu:mirNeg(a:GPR) -> b:GPR;
CONDITION {
(IS_UCHAR(subu.Type) || IS_USHORT(subu.Type) || IS_USHORT(subu.Type) || IS_ULONG(subu.Type) || IS_ULONG(subu.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_subu,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		a,
		gcg_cycle );
}


RULE [NEG60] subui:mirNeg(a:GPR) -> b:GPR;
CONDITION {
(IS_UCHAR(subui.Type) || IS_USHORT(subui.Type) || IS_USHORT(subui.Type) || IS_ULONG(subui.Type) || IS_ULONG(subui.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSI( state,
		SCHED_OP_subui,
		b,
		SCHED_STRING_0,
		RegGPR0,
		SCHED_STRING_0,
		0,
		gcg_cycle );
}


(****************************************************
 *  Address Calc instructions.
 ****************************************************)

RULE [ADDR_GPR] mirAddrPlus(rs0:GPR, rs1:GPR) -> rd:GPR;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_add,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [ADDRDIFF_GPR] mirAddrDiff(rs0:GPR, rs1:GPR) -> rd:GPR;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_sub,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


(****************************************************
 *  OTHER instructions.
 ****************************************************)

RULE [avg_0] avg:mirDiv(mirPlus(rs0:GPR, rs1:GPR), imm_2) -> rd:GPR;
CONDITION {
(IS_CHAR(avg.Type) || IS_SHORT(avg.Type) || IS_SHORT(avg.Type) || IS_LONG(avg.Type) || IS_LONG(avg.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_avg,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [avgu_0] avgu:mirDiv(mirPlus(rs0:GPR, rs1:GPR), imm_2) -> rd:GPR;
CONDITION {
(IS_UCHAR(avgu.Type) || IS_USHORT(avgu.Type) || IS_USHORT(avgu.Type) || IS_ULONG(avgu.Type) || IS_ULONG(avgu.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_avgu,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [fex_0] fex:mirShiftRightSign(mirAnd(rs:GPR, mask:GPR), shift:mirIntConst) -> rd:GPR;
CONDITION {
(IS_CHAR(fex.Type) || IS_SHORT(fex.Type) || IS_SHORT(fex.Type) || IS_LONG(fex.Type) || IS_LONG(fex.Type))
}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSRSI( state,
		SCHED_OP_fex,
		rd,
		SCHED_STRING_0,
		rs,
		SCHED_STRING_0,
		mask,
		SCHED_STRING_0,
		UnivInt_to_int(shift.Value),
		gcg_cycle );
}


RULE [mac_0] mac:mirPlus(rd:GPR, mirMult(rs0:GPR, rs1:GPR)) -> GPR;
CONDITION {
(IS_CHAR(mac.Type) || IS_SHORT(mac.Type) || IS_SHORT(mac.Type) || IS_LONG(mac.Type) || IS_LONG(mac.Type))

}
TARGET	rd;
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSR( state,
		SCHED_OP_mac,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


RULE [mad_0] mad:mirPlus(rs0:GPR, mirMult(rs1:GPR, rs2:GPR)) -> rd:GPR;
CONDITION {
(IS_CHAR(mad.Type) || IS_SHORT(mad.Type) || IS_SHORT(mad.Type) || IS_LONG(mad.Type) || IS_LONG(mad.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSRSRSR( state,
		SCHED_OP_mad,
		rd,
		SCHED_STRING_0,
		rs0,
		SCHED_STRING_0,
		rs1,
		SCHED_STRING_0,
		rs2,
		gcg_cycle );
}


RULE [swap_0] swap:mirOr(mirAnd(mirShiftLeft(rs1:GPR, imm_16), imm__65536), mirAnd(mirShiftRightSign(rs1:GPR, imm_16), imm_65535)) -> rs0:GPR;
CONDITION {
(IS_CHAR(swap.Type) || IS_UCHAR(swap.Type) || IS_SHORT(swap.Type) || IS_USHORT(swap.Type) || IS_USHORT(swap.Type) || IS_USHORT(swap.Type) || IS_LONG(swap.Type) || IS_ULONG(swap.Type) || IS_ULONG(swap.Type) || IS_ULONG(swap.Type))

}
PRODUCER add_out;
CONSUMER add_in;
TEMPLATE add_op;
COST 1;
EMIT {
	addInsnInfo_RSR( state,
		SCHED_OP_swap,
		rs0,
		SCHED_STRING_0,
		rs1,
		gcg_cycle );
}


(****************************************************
 *  NULL instructions.
 ****************************************************)

RULE mirNil -> a:constValue;
EMIT {
    a.Value = 0;
}

(*******  *********)
REWR mirPlus(a:mirConvert(b:_), c:_) -> d:mirPlus(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirPlus(a:_, b:mirConvert(c:_)) -> d:mirPlus(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirPlus(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirPlus(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirPlus(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirPlus(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

(*******  *********)
REWR mirDiff(a:mirConvert(b:_), c:_) -> d:mirDiff(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirDiff(a:_, b:mirConvert(c:_)) -> d:mirDiff(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirDiff(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirDiff(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirDiff(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirDiff(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

REWR mirMult(a:mirConvert(b:_), c:_) -> d:mirMult(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirMult(a:_, b:mirConvert(c:_)) -> d:mirMult(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirMult(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirMult(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirMult(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirMult(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

REWR mirDiv(a:mirConvert(b:_), c:_) -> d:mirDiv(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirDiv(a:_, b:mirConvert(c:_)) -> d:mirDiv(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirDiv(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirDiv(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirDiv(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirDiv(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

REWR mirMod(a:mirConvert(b:_), c:_) -> d:mirMod(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirMod(a:_, b:mirConvert(c:_)) -> d:mirMod(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirMod(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirMod(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirMod(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirMod(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

REWR mirAnd(a:mirConvert(b:_), c:_) -> d:mirAnd(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirAnd(a:_, b:mirConvert(c:_)) -> d:mirAnd(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirAnd(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirAnd(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirAnd(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirAnd(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

(******  or  ******)
REWR mirOr(a:mirConvert(b:_), c:_) -> d:mirOr(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirOr(a:_, b:mirConvert(c:_)) -> d:mirOr(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirOr(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirOr(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirOr(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirOr(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

(******  xor  ******)
REWR mirXor(a:mirConvert(b:_), c:_) -> d:mirXor(b, c);
CALC {
  d.Type = a.Type;
}

REWR mirXor(a:_, b:mirConvert(c:_)) -> d:mirXor(a, c);
CALC {
  d.Type = b.Type;
}

REWR mirXor(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirXor(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) > 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = a.Type;
}

REWR mirXor(a:mirConvert(b:_), c:mirConvert(d:_)) -> e:mirXor(b, d);
CONDITION {
  UnivInt_to_int(mirTYPE_get_Size(a.Type)) <= 
                          UnivInt_to_int(mirTYPE_get_Size(c.Type)) 
}
CALC {
  e.Type = c.Type;
}

(******  shift right  ******)
REWR mirShiftRight(a:mirConvert(b:_), c:_) -> d:mirShiftRight(b, c);
CALC {
  d.Type = a.Type;
}

(******  shift right arith  ******)
REWR mirShiftRightSign(a:mirConvert(b:_), c:_) -> d:mirShiftRightSign(b, c);
CALC {
  d.Type = a.Type;
}


REWR mirNot(b:mirConvert(a:_)) -> c:mirNot(a);
CALC {
  c.Type = b.Type;
}

REWR mirNeg(b:mirConvert(a:_)) -> c:mirNeg(a);
CALC {
  c.Type = b.Type;
}
