-- Copyright(C) 2002 by Xilinx, Inc. All rights reserved.
-- This text contains proprietary, confidential
-- information of Xilinx, Inc., is distributed
-- under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms
-- of a valid license agreement with Xilinx, Inc. This copyright
-- notice must be retained as part of this text at all times.
--
--------------------------------------------------------------------------------
--$RCSfile: cordic_v1_1.vhd,v $ $Revision: 1.2.12.3 $ $Date: 2004/05/18 12:10:44 $
--------------------------------------------------------------------------------
-- Project  : cordic_v1_1
-- Unit     : c_cordic_v1_1_beh
-- Author   : Jeffrey Graham
-- Function :  Top Level Module 
--------------------------------------------------------------------------------
-- Description
-- ===========
--------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.mult_gen_v4_0_services.ALL;

PACKAGE cordic_pack_v1_1 IS

  FUNCTION c_funct_has_port(funct, position: INTEGER) RETURN INTEGER;

  FUNCTION f_get_data_extend_length (width : INTEGER) RETURN INTEGER;

  FUNCTION getLatency(cordic_function : INTEGER; scale_comp : INTEGER;
                      input_width : INTEGER; output_width : INTEGER; 
                      architecture_sel : INTEGER; pipeline_mode : INTEGER;
                      reg_inputs : INTEGER; round_mode : INTEGER) 
                      RETURN INTEGER;

  FUNCTION get_ccm_scale_latency(cordic_function : INTEGER; output_width : INTEGER)
                      RETURN INTEGER;
  FUNCTION get_round_latency(round_mode : INTEGER) RETURN INTEGER;
  FUNCTION get_round_ext(round_mode : INTEGER) RETURN INTEGER;
  FUNCTION get_rotate_latency(cordic_function:INTEGER;architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER;scale_comp:INTEGER)
                RETURN INTEGER;
  FUNCTION get_translate_latency(cordic_function:INTEGER;architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER;scale_comp:INTEGER)
                RETURN INTEGER;
  FUNCTION get_sqrt_latency(architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER)
                RETURN INTEGER;
  
  --Function to set all bits in a vector (ie Others Statement Replacement)
  FUNCTION set_vect_bv(x: BIT_VECTOR; val: BIT) RETURN BIT_VECTOR;
  FUNCTION set_vect_sl(x: STD_LOGIC_VECTOR; val: STD_LOGIC) RETURN STD_LOGIC_VECTOR;

  --Function to cut slice of vector (ie Slice Replacement)
  FUNCTION slice_down_bv(x: BIT_VECTOR; start, stop : INTEGER) RETURN BIT_VECTOR;
  FUNCTION slice_down_sl(x: STD_LOGIC_VECTOR; start, stop : INTEGER) RETURN STD_LOGIC_VECTOR;
  FUNCTION slice_up_bv(x: BIT_VECTOR; start, stop : INTEGER) RETURN BIT_VECTOR;
  FUNCTION slice_up_sl(x: STD_LOGIC_VECTOR; start, stop : INTEGER) RETURN STD_LOGIC_VECTOR;
  FUNCTION slice_str(x: STRING; start, stop : INTEGER) RETURN STRING;

  --Convert from type Bit to/from Std Logic
  FUNCTION bv_to_sl(x: BIT_VECTOR) RETURN STD_LOGIC_VECTOR;
  FUNCTION b_to_sl(x: BIT) RETURN STD_LOGIC;
  FUNCTION sl_to_bv(x: STD_LOGIC_VECTOR) RETURN BIT_VECTOR;
  FUNCTION sl_to_b(x: STD_LOGIC) RETURN BIT;

  --Convert from type Bit Vector to/from String
  FUNCTION bv_to_str(x: BIT_VECTOR) RETURN STRING;
  FUNCTION str_to_bv(x: STRING) RETURN BIT_VECTOR;
  
  --Convert from type Interger-Natural to/from String
  FUNCTION nat_to_bv(x: NATURAL; len: INTEGER) RETURN BIT_VECTOR;
  FUNCTION bv_to_nat(x: BIT_VECTOR) RETURN NATURAL;
  FUNCTION int_to_bv(x: INTEGER; len: INTEGER) RETURN BIT_VECTOR;
  FUNCTION bv_to_int(x: BIT_VECTOR) RETURN INTEGER;

  FUNCTION max_int(x : IN INTEGER; y : IN INTEGER) RETURN INTEGER;
  FUNCTION min_int(x : IN INTEGER; y : IN INTEGER) RETURN INTEGER;  

  --Functions to Add and Sub
  FUNCTION add_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION add_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION sub_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION sub_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION add_c_bv(x : BIT_VECTOR; y : BIT_VECTOR; c : BIT) RETURN BIT_VECTOR;  
  
  -- Functions to Round
  FUNCTION rnd_ubv(x : IN BIT_VECTOR; mode : IN INTEGER; precision : IN INTEGER) 
                  RETURN BIT_VECTOR;
  FUNCTION rnd_sbv(x : IN BIT_VECTOR; mode : IN INTEGER; precision : IN INTEGER) 
                  RETURN BIT_VECTOR;
  FUNCTION rnd_ulv(x : IN STD_LOGIC_VECTOR; mode : IN INTEGER; precision : IN INTEGER) 
                  RETURN STD_LOGIC_VECTOR;
  FUNCTION rnd_slv(x : IN STD_LOGIC_VECTOR; mode : IN INTEGER; precision : IN INTEGER) 
                  RETURN STD_LOGIC_VECTOR;

  -- Functions to generate inv_cordic_scale_coefficients.
  FUNCTION f_inv_cordic_scale_coeff_slv(width, cordic_funct : INTEGER) RETURN STD_LOGIC_VECTOR;
  FUNCTION f_inv_cordic_scale_coeff_str(width, cordic_funct : INTEGER) RETURN STRING;
  
  ----------------------------------------------------------------------------
  --CONSTANTS used to configure CORDIC
  ----------------------------------------------------------------------------
  -- Used to set c_cordic_function
  CONSTANT c_f_rotate : INTEGER := 0; 
  CONSTANT c_f_translate : INTEGER := 1;
  CONSTANT c_f_sin_cos : INTEGER := 2;
  CONSTANT c_f_atan : INTEGER := 3;
  CONSTANT c_f_sinh_cosh : INTEGER := 4;
  CONSTANT c_f_atanh : INTEGER := 5;
  CONSTANT c_f_sqrt : INTEGER := 6;
  CONSTANT c_f_default : INTEGER := 7;

  -- Used to set c_architecture
  CONSTANT c_bser_arch : INTEGER := 0; -- Select Bit Serial Architecture (Not Implemented)
  CONSTANT c_wser_arch : INTEGER := 1; -- Select Word Serial Architecture
  CONSTANT c_para_arch : INTEGER := 2; -- Select Parallel Aarchitecture

  -- Used to set c_phase_format
  CONSTANT c_format_rad : INTEGER := 0;
  CONSTANT c_format_sca : INTEGER := 1;

  -- Used to set c_data_width
  CONSTANT c_data_width_max : INTEGER := 64;   

  -- Used to set c_round_mode
  CONSTANT c_round_truncate : INTEGER := 0;
  CONSTANT c_round_pos_inf: INTEGER := 1;
  CONSTANT c_round_pos_neg_inf : INTEGER := 2;

  -- Used to set c_scale_comp
  CONSTANT c_scale_none : INTEGER := 0;
  CONSTANT c_scale_ccm: INTEGER := 1;

  -- Used to set c_pipeline_mode
  CONSTANT c_pipe_none : INTEGER := 0;
  CONSTANT c_pipe_opt: INTEGER := -1;
  CONSTANT c_pipe_max: INTEGER := -2;

  -- Used to set c_replications
  CONSTANT c_repl_none : INTEGER := 0;
  CONSTANT c_repl_opt : INTEGER := -1;
  CONSTANT c_repl_max : INTEGER := -2;
  
  -- Used to Specify Layout Orientation
  CONSTANT c_layout_depth_width : INTEGER := 0; 
  CONSTANT c_layout_width_depth : INTEGER := 1;
  
  -- Used for I/O Port
  CONSTANT c_x_in_port : INTEGER := 5;
  CONSTANT c_y_in_port : INTEGER := 4;
  CONSTANT c_pha_in_port : INTEGER := 3;
  CONSTANT c_x_out_port : INTEGER := 2;
  CONSTANT c_y_out_port : INTEGER := 1;
  CONSTANT c_pha_out_port : INTEGER := 0;

--Constants used to set the engine operational mode
  CONSTANT c_em_rotational : STD_LOGIC := '0';
  CONSTANT c_em_translation : STD_LOGIC := '1';
  CONSTANT c_em_rotational_beh : BIT := '0';
  CONSTANT c_em_translation_beh : BIT := '1';

--Constants used to select between trigonometric and
--          hyperbolic rotations
  CONSTANT c_transform_trig : INTEGER := 0;
  CONSTANT c_transform_hyp : INTEGER := 1;

  ----------------------------------------------------------------------------
  --Constants used to set DEFAULT VALUES  
  ----------------------------------------------------------------------------
  CONSTANT c_cordic_io_cnt : INTEGER := 6;
  
  CONSTANT c_max_rom_width : INTEGER := 72;
  CONSTANT c_max_rom_length : INTEGER := 64;

  CONSTANT c_wser_slice_opt : INTEGER := 16;
  CONSTANT c_rom_block_depth : INTEGER := 16;
  CONSTANT c_rom_block_addr : INTEGER := 4;
  
  CONSTANT c_ctrl_width_f_translate : INTEGER := 4;
  --Translate Control Vector {Quad[1],Quad[0],RFD_INT,RDY_INT}
  CONSTANT c_ctrl_width_f_rotate : INTEGER := 4;
  --Rotate Control Vector    {Quad[1],Quad[0],RFD_INT,RDY_INT}
  
  CONSTANT c_cordic_scale_trig_const_slv : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "010010101000011000011011110100111100001111011011110101001110101010001100"; 
  CONSTANT c_cordic_scale_trig_const_str : STRING(1 to c_max_rom_width) :=
  "010010101000011000011011110100111100001111011011110101001110101010001100";
  CONSTANT c_cordic_scale_hyp_const_slv : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "001101010000000010010000000111101100110011010011000111001100001100011100"; 
  CONSTANT c_cordic_scale_hyp_const_str : STRING(1 to c_max_rom_width) :=
  "001101010000000010010000000111101100110011010011000111001100001100011100";

  CONSTANT c_inv_cordic_scale_trig_const_slv : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "001101101111011001010110110001011010011100011001010111000011000100100000";
  CONSTANT c_inv_cordic_scale_trig_const_str : STRING(1 to c_max_rom_width) :=
  "001101101111011001010110110001011010011100011001010111000011000100100000";
  CONSTANT c_inv_cordic_scale_hyp_const_slv : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "010011010100011110100001110010000000001110111011000010001100101001011001"; 
  CONSTANT c_inv_cordic_scale_hyp_const_str : STRING(1 to c_max_rom_width) :=
  "010011010100011110100001110010000000001110111011000010001100101001011001"; 

  --ARITHMETIC CONSTANTS.  
  CONSTANT     c_pi_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "011001001000011111101101010100010001000010110100011000010001101001100010";
  CONSTANT c_pi_3_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "010010110110010111110001111111001100110010000111010010001101001111001010";
  CONSTANT c_pi_2_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "001100100100001111110110101010001000100001011010001100001000110100110010";
  CONSTANT c_pi_1_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "000110010010000111111011010101000100010000101101000110000100011010011000";
  CONSTANT c_neg_pi_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "100110110111100000010010101011101110111101001011100111101110010110011110";
  CONSTANT c_neg_pi_3_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "101101001001101000001110000000110011001101111000101101110010110000110110";
  CONSTANT c_neg_pi_2_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "110011011011110000001001010101110111011110100101110011110111001011001110";
  CONSTANT c_neg_pi_1_4_rads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "111001101101111000000100101010111011101111010010111001111011100101101000";
  CONSTANT c_neg_pi_jrads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "111000000000000000000000000000000000000000000000000000000000000000000000";
  CONSTANT c_neg_pi_3_4_jrads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "111010000000000000000000000000000000000000000000000000000000000000000000";
  CONSTANT c_neg_pi_2_4_jrads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "111100000000000000000000000000000000000000000000000000000000000000000000";
  CONSTANT c_neg_pi_1_4_jrads_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "111110000000000000000000000000000000000000000000000000000000000000000000";
  CONSTANT c_zero_const : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0) :=
  "000000000000000000000000000000000000000000000000000000000000000000000000";

--ROM CONSTANTS
  --ROM CONSTANTS are stored as a Qn format STD_LOGIC_VECTOR. 
  --ROM(0) Corresponds to FUNCTION(+0.5)  
  --c_atan_rads
  --c_atan_jrads
  --c_atanh_rads
  --c_atanh_jrads
  CONSTANT c_atan_rads : STD_LOGIC_VECTOR(c_max_rom_width*c_max_rom_length-1 DOWNTO 0) :=
  ("000000000000000000000000000000000000000000000000000000000000000000100000" &
   "000000000000000000000000000000000000000000000000000000000000000001000000" &
   "000000000000000000000000000000000000000000000000000000000000000010000000" &
   "000000000000000000000000000000000000000000000000000000000000000100000000" &
   "000000000000000000000000000000000000000000000000000000000000001000000000" &
   "000000000000000000000000000000000000000000000000000000000000010000000000" &
   "000000000000000000000000000000000000000000000000000000000000100000000000" &
   "000000000000000000000000000000000000000000000000000000000001000000000000" &
   "000000000000000000000000000000000000000000000000000000000010000000000000" &
   "000000000000000000000000000000000000000000000000000000000100000000000000" &
   "000000000000000000000000000000000000000000000000000000001000000000000000" &
   "000000000000000000000000000000000000000000000000000000010000000000000000" &
   "000000000000000000000000000000000000000000000000000000100000000000000000" &
   "000000000000000000000000000000000000000000000000000001000000000000000000" &
   "000000000000000000000000000000000000000000000000000010000000000000000000" &
   "000000000000000000000000000000000000000000000000000100000000000000000000" &
   "000000000000000000000000000000000000000000000000001000000000000000000000" &
   "000000000000000000000000000000000000000000000000010000000000000000000000" &
   "000000000000000000000000000000000000000000000000100000000000000000000000" &
   "000000000000000000000000000000000000000000000001000000000000000000000000" &
   "000000000000000000000000000000000000000000000010000000000000000000000000" &
   "000000000000000000000000000000000000000000000100000000000000000000000000" &
   "000000000000000000000000000000000000000000001000000000000000000000000000" &
   "000000000000000000000000000000000000000000010000000000000000000000000000" &
   "000000000000000000000000000000000000000000100000000000000000000000000000" &
   "000000000000000000000000000000000000000001000000000000000000000000000000" &
   "000000000000000000000000000000000000000010000000000000000000000000000000" &
   "000000000000000000000000000000000000000100000000000000000000000000000000" &
   "000000000000000000000000000000000000001000000000000000000000000000000000" &
   "000000000000000000000000000000000000010000000000000000000000000000000000" &
   "000000000000000000000000000000000000100000000000000000000000000000000000" &
   "000000000000000000000000000000000001000000000000000000000000000000000000" &
   "000000000000000000000000000000000010000000000000000000000000000000000000" &
   "000000000000000000000000000000000100000000000000000000000000000000000000" &
   "000000000000000000000000000000001000000000000000000000000000000000000000" &
   "000000000000000000000000000000010000000000000000000000000000000000000000" &
   "000000000000000000000000000000100000000000000000000000000000000000000000" &
   "000000000000000000000000000001000000000000000000000000000000000000000000" &
   "000000000000000000000000000010000000000000000000000000000000000000000000" &
   "000000000000000000000000000100000000000000000000000000000000000000000000" &
   "000000000000000000000000001000000000000000000000000000000000000000000000" &
   "000000000000000000000000010000000000000000000000000000000000000000000000" &
   "000000000000000000000000011111111111111111111111111111111111111111111101" &
   "000000000000000000000000111111111111111111111111111111111111111111101011" &
   "000000000000000000000001111111111111111111111111111111111111111101010101" &
   "000000000000000000000011111111111111111111111111111111111111101010101011" &
   "000000000000000000000111111111111111111111111111111111111101010101010101" &
   "000000000000000000001111111111111111111111111111111111101010101010101011" &
   "000000000000000000011111111111111111111111111111111101010101010101010101" &
   "000000000000000000111111111111111111111111111111101010101010101010101011" &
   "000000000000000001111111111111111111111111111101010101010101010101010101" &
   "000000000000000011111111111111111111111111101010101010101010101010101110" &
   "000000000000000111111111111111111111111101010101010101010101010110111100" &
   "000000000000001111111111111111111111101010101010101010101011011101110111" &
   "000000000000011111111111111111111101010101010101010101101110111011101111" &
   "000000000000111111111111111111101010101010101010110111011101110111010101" &
   "000000000001111111111111111101010101010101011011101110111011011100101001" &
   "000000000011111111111111101010101010101101110111011101010010111001011010" &
   "000000000111111111111101010101010110111011101101110010100110101011011110" &
   "000000001111111111101010101011011101110101001011101100010010010101000010" &
   "000000011111111101010101101110110111001011001111110111101001110001101101" &
   "000000111111101010110111010100110101010110000101111011011011100011001011" &
   "000001111101011011011101011111100100101100100000001101110101100010101011" &
   "000011101101011000110011100000101011000011011101101001111100010010000110");

  CONSTANT c_atan_jrads : STD_LOGIC_VECTOR(c_max_rom_width*c_max_rom_length-1 DOWNTO 0) :=
  ("000000000000000000000000000000000000000000000000000000000000000000001010" &
   "000000000000000000000000000000000000000000000000000000000000000000010100" &
   "000000000000000000000000000000000000000000000000000000000000000000101000" &
   "000000000000000000000000000000000000000000000000000000000000000001010001" &
   "000000000000000000000000000000000000000000000000000000000000000010100011" &
   "000000000000000000000000000000000000000000000000000000000000000101000110" &
   "000000000000000000000000000000000000000000000000000000000000001010001100" &
   "000000000000000000000000000000000000000000000000000000000000010100011000" &
   "000000000000000000000000000000000000000000000000000000000000101000101111" &
   "000000000000000000000000000000000000000000000000000000000001010001011111" &
   "000000000000000000000000000000000000000000000000000000000010100010111110" &
   "000000000000000000000000000000000000000000000000000000000101000101111101" &
   "000000000000000000000000000000000000000000000000000000001010001011111001" &
   "000000000000000000000000000000000000000000000000000000010100010111110011" &
   "000000000000000000000000000000000000000000000000000000101000101111100110" &
   "000000000000000000000000000000000000000000000000000001010001011111001100" &
   "000000000000000000000000000000000000000000000000000010100010111110011000" &
   "000000000000000000000000000000000000000000000000000101000101111100110000" &
   "000000000000000000000000000000000000000000000000001010001011111001100001" &
   "000000000000000000000000000000000000000000000000010100010111110011000001" &
   "000000000000000000000000000000000000000000000000101000101111100110000011" &
   "000000000000000000000000000000000000000000000001010001011111001100000111" &
   "000000000000000000000000000000000000000000000010100010111110011000001101" &
   "000000000000000000000000000000000000000000000101000101111100110000011011" &
   "000000000000000000000000000000000000000000001010001011111001100000110111" &
   "000000000000000000000000000000000000000000010100010111110011000001101110" &
   "000000000000000000000000000000000000000000101000101111100110000011011011" &
   "000000000000000000000000000000000000000001010001011111001100000110110111" &
   "000000000000000000000000000000000000000010100010111110011000001101101110" &
   "000000000000000000000000000000000000000101000101111100110000011011011100" &
   "000000000000000000000000000000000000001010001011111001100000110110111001" &
   "000000000000000000000000000000000000010100010111110011000001101101110010" &
   "000000000000000000000000000000000000101000101111100110000011011011100101" &
   "000000000000000000000000000000000001010001011111001100000110110111001010" &
   "000000000000000000000000000000000010100010111110011000001101101110010011" &
   "000000000000000000000000000000000101000101111100110000011011011100100111" &
   "000000000000000000000000000000001010001011111001100000110110111001001110" &
   "000000000000000000000000000000010100010111110011000001101101110010011100" &
   "000000000000000000000000000000101000101111100110000011011011100100111001" &
   "000000000000000000000000000001010001011111001100000110110111001001110010" &
   "000000000000000000000000000010100010111110011000001101101110010011100100" &
   "000000000000000000000000000101000101111100110000011011011100100111001000" &
   "000000000000000000000000001010001011111001100000110110111001001110010000" &
   "000000000000000000000000010100010111110011000001101101110010011100011011" &
   "000000000000000000000000101000101111100110000011011011100100111000001101" &
   "000000000000000000000001010001011111001100000110110111001001101011010101" &
   "000000000000000000000010100010111110011000001101101110010010101101111011" &
   "000000000000000000000101000101111100110000011011011100100000010101111010" &
   "000000000000000000001010001011111001100000110110111000010111111100001110" &
   "000000000000000000010100010111110011000001101101101011101001111011101101" &
   "000000000000000000101000101111100110000011011010101110100100010001010110" &
   "000000000000000001010001011111001100000110110000010111001011110010010001" &
   "000000000000000010100010111110011000001100110111111110110001100001100110" &
   "000000000000000101000101111100110000010100101010000000110010110111000010" &
   "000000000000001010001011111001100000000000100100011011101001111011011010" &
   "000000000000010100010111110010111010111011001100001010101100110111101110" &
   "000000000000101000101111100101001101000110110100001100001100110110111111" &
   "000000000001010001011111000101010100010001110101000100001010101110101000" &
   "000000000010100010111101100001111001011100001010000010011000101001100001" &
   "000000000101000101110101111110000101011001000001000110001001111000010101" &
   "000000001010001011000011010100001100001110010110001001101011101100110000" &
   "000000010100010001000100011101010000011101110111011001101000011011100000" &
   "000000100111111011001110000101101101011110111000111001111010001101111000" &
   "000001001011100100000001010001110110011101111100110000100001111010111100");

  CONSTANT c_atanh_rads : STD_LOGIC_VECTOR(c_max_rom_width*c_max_rom_length-1 DOWNTO 0) :=
  ("000000000000000000000000000000000000000000000000000000000000000000100000" &
   "000000000000000000000000000000000000000000000000000000000000000001000000" &
   "000000000000000000000000000000000000000000000000000000000000000010000000" &
   "000000000000000000000000000000000000000000000000000000000000000100000000" &
   "000000000000000000000000000000000000000000000000000000000000001000000000" &
   "000000000000000000000000000000000000000000000000000000000000010000000000" &
   "000000000000000000000000000000000000000000000000000000000000100000000000" &
   "000000000000000000000000000000000000000000000000000000000001000000000000" &
   "000000000000000000000000000000000000000000000000000000000010000000000000" &
   "000000000000000000000000000000000000000000000000000000000100000000000000" &
   "000000000000000000000000000000000000000000000000000000001000000000000000" &
   "000000000000000000000000000000000000000000000000000000010000000000000000" &
   "000000000000000000000000000000000000000000000000000000100000000000000000" &
   "000000000000000000000000000000000000000000000000000001000000000000000000" &
   "000000000000000000000000000000000000000000000000000010000000000000000000" &
   "000000000000000000000000000000000000000000000000000100000000000000000000" &
   "000000000000000000000000000000000000000000000000001000000000000000000000" &
   "000000000000000000000000000000000000000000000000010000000000000000000000" &
   "000000000000000000000000000000000000000000000000100000000000000000000000" &
   "000000000000000000000000000000000000000000000001000000000000000000000000" &
   "000000000000000000000000000000000000000000000010000000000000000000000000" &
   "000000000000000000000000000000000000000000000100000000000000000000000000" &
   "000000000000000000000000000000000000000000001000000000000000000000000000" &
   "000000000000000000000000000000000000000000010000000000000000000000000000" &
   "000000000000000000000000000000000000000000100000000000000000000000000000" &
   "000000000000000000000000000000000000000001000000000000000000000000000000" &
   "000000000000000000000000000000000000000010000000000000000000000000000000" &
   "000000000000000000000000000000000000000100000000000000000000000000000000" &
   "000000000000000000000000000000000000001000000000000000000000000000000000" &
   "000000000000000000000000000000000000010000000000000000000000000000000000" &
   "000000000000000000000000000000000000100000000000000000000000000000000000" &
   "000000000000000000000000000000000001000000000000000000000000000000000000" &
   "000000000000000000000000000000000010000000000000000000000000000000000000" &
   "000000000000000000000000000000000100000000000000000000000000000000000000" &
   "000000000000000000000000000000001000000000000000000000000000000000000000" &
   "000000000000000000000000000000010000000000000000000000000000000000000000" &
   "000000000000000000000000000000100000000000000000000000000000000000000000" &
   "000000000000000000000000000001000000000000000000000000000000000000000000" &
   "000000000000000000000000000010000000000000000000000000000000000000000000" &
   "000000000000000000000000000100000000000000000000000000000000000000000000" &
   "000000000000000000000000001000000000000000000000000000000000000000000000" &
   "000000000000000000000000010000000000000000000000000000000000000000000000" &
   "000000000000000000000000100000000000000000000000000000000000000000000011" &
   "000000000000000000000001000000000000000000000000000000000000000000010101" &
   "000000000000000000000010000000000000000000000000000000000000000010101011" &
   "000000000000000000000100000000000000000000000000000000000000010101010101" &
   "000000000000000000001000000000000000000000000000000000000010101010101011" &
   "000000000000000000010000000000000000000000000000000000010101010101010101" &
   "000000000000000000100000000000000000000000000000000010101010101010101011" &
   "000000000000000001000000000000000000000000000000010101010101010101010101" &
   "000000000000000010000000000000000000000000000010101010101010101010101011" &
   "000000000000000100000000000000000000000000010101010101010101010101011000" &
   "000000000000001000000000000000000000000010101010101010101010101100010001" &
   "000000000000010000000000000000000000010101010101010101010110001000100010" &
   "000000000000100000000000000000000010101010101010101011000100010001000100" &
   "000000000001000000000000000000010101010101010101100010001000100010010010" &
   "000000000010000000000000000010101010101010110001000100010001010110100011" &
   "000000000100000000000000010101010101011000100010001001000110101101001110" &
   "000000001000000000000010101010101100010001000101011010001110010011000111" &
   "000000010000000000010101010110001000100100011010111011100010010010110100" &
   "000000100000000010101011000100010101101001101110101101011001101110010110" &
   "000001000000010101100010010001110010011110101011101111011101101001100101" &
   "000010000010110001010111011111010100000010001010001010001101001110010100" &
   "000100011001001111101010011110101010110100000011000010100111110011111001");

  CONSTANT c_atanh_jrads : STD_LOGIC_VECTOR(c_max_rom_width*c_max_rom_length-1 DOWNTO 0) :=
  ("000000000000000000000000000000000000000000000000000000000000000000001010" &
   "000000000000000000000000000000000000000000000000000000000000000000010100" &
   "000000000000000000000000000000000000000000000000000000000000000000101000" &
   "000000000000000000000000000000000000000000000000000000000000000001010001" &
   "000000000000000000000000000000000000000000000000000000000000000010100011" &
   "000000000000000000000000000000000000000000000000000000000000000101000110" &
   "000000000000000000000000000000000000000000000000000000000000001010001100" &
   "000000000000000000000000000000000000000000000000000000000000010100011000" &
   "000000000000000000000000000000000000000000000000000000000000101000101111" &
   "000000000000000000000000000000000000000000000000000000000001010001011111" &
   "000000000000000000000000000000000000000000000000000000000010100010111110" &
   "000000000000000000000000000000000000000000000000000000000101000101111101" &
   "000000000000000000000000000000000000000000000000000000001010001011111001" &
   "000000000000000000000000000000000000000000000000000000010100010111110011" &
   "000000000000000000000000000000000000000000000000000000101000101111100110" &
   "000000000000000000000000000000000000000000000000000001010001011111001100" &
   "000000000000000000000000000000000000000000000000000010100010111110011000" &
   "000000000000000000000000000000000000000000000000000101000101111100110000" &
   "000000000000000000000000000000000000000000000000001010001011111001100000" &
   "000000000000000000000000000000000000000000000000010100010111110011000001" &
   "000000000000000000000000000000000000000000000000101000101111100110000011" &
   "000000000000000000000000000000000000000000000001010001011111001100000111" &
   "000000000000000000000000000000000000000000000010100010111110011000001101" &
   "000000000000000000000000000000000000000000000101000101111100110000011011" &
   "000000000000000000000000000000000000000000001010001011111001100000110111" &
   "000000000000000000000000000000000000000000010100010111110011000001101110" &
   "000000000000000000000000000000000000000000101000101111100110000011011011" &
   "000000000000000000000000000000000000000001010001011111001100000110110111" &
   "000000000000000000000000000000000000000010100010111110011000001101101110" &
   "000000000000000000000000000000000000000101000101111100110000011011011100" &
   "000000000000000000000000000000000000001010001011111001100000110110111001" &
   "000000000000000000000000000000000000010100010111110011000001101101110010" &
   "000000000000000000000000000000000000101000101111100110000011011011100101" &
   "000000000000000000000000000000000001010001011111001100000110110111001010" &
   "000000000000000000000000000000000010100010111110011000001101101110010011" &
   "000000000000000000000000000000000101000101111100110000011011011100100111" &
   "000000000000000000000000000000001010001011111001100000110110111001001110" &
   "000000000000000000000000000000010100010111110011000001101101110010011100" &
   "000000000000000000000000000000101000101111100110000011011011100100111001" &
   "000000000000000000000000000001010001011111001100000110110111001001110010" &
   "000000000000000000000000000010100010111110011000001101101110010011100100" &
   "000000000000000000000000000101000101111100110000011011011100100111001000" &
   "000000000000000000000000001010001011111001100000110110111001001110010010" &
   "000000000000000000000000010100010111110011000001101101110010011100101001" &
   "000000000000000000000000101000101111100110000011011011100100111001111010" &
   "000000000000000000000001010001011111001100000110110111001001111000111010" &
   "000000000000000000000010100010111110011000001101101110010100011010100101" &
   "000000000000000000000101000101111100110000011011011100101101111011000111" &
   "000000000000000000001010001011111001100000110110111010000100100101110100" &
   "000000000000000000010100010111110011000001101101111001001111001000011000" &
   "000000000000000000101000101111100110000011011100011011001101110110110100" &
   "000000000000000001010001011111001100000110111101111100011000011110000101" &
   "000000000000000010100010111110011000001110100100101000010111000000000101" &
   "000000000000000101000101111100110000100010001111001101011110101010111001" &
   "000000000000001010001011111001100001101101001110000001001000011010010001" &
   "000000000000010100010111110011001000100000011000110110100000101110110010" &
   "000000000000101000101111100110111001110000011001101010101011111010010101" &
   "000000000001010001011111010010111001011110100000111000011000111110011000" &
   "000000000010100010111111001110100011000001101001001111110100011101111100" &
   "000000000101000110000011100011010010000110010010000101010101101000101111" &
   "000000001010001100101111111101110100100111000101100100011110011011011100" &
   "000000010100011110101001101111110000110110010010110011101110001001010111" &
   "000000101001101000000011010110000100100011111110110010011001011000110100" &
   "000001011001100001011110001000110111101101011100101111010000001101101110");
  
END cordic_pack_v1_1;

PACKAGE BODY cordic_pack_v1_1 is

  -- This function is used to determine if a cordic functional 
  -- configuration requires an input.
  FUNCTION c_funct_has_port(funct, position: INTEGER) RETURN INTEGER IS 
    VARIABLE in_out_vect : BIT_VECTOR(C_CORDIC_IO_CNT-1 DOWNTO 0);
    VARIABLE in_out_bit : BIT;
    VARIABLE in_out_tmp : INTEGER;
  BEGIN
  	
    in_out_bit := '0';
    -- The in_out_vect represents the valid
    -- I/O for the selected CORDIC function.
    -- "X_IN,Y_IN,PHA_IN,X_OUT,Y_OUT,PHA_OUT" 
   	CASE funct IS
      WHEN c_f_rotate => -- C_ROTATE 
        in_out_vect := "111110";
      WHEN c_f_translate => -- C_VECTOR 
        in_out_vect := "110101";
      WHEN c_f_sin_cos => -- C_SIN_COS
        in_out_vect := "001110";
      WHEN c_f_sinh_cosh => -- C_SINH_COSH
        in_out_vect := "001110";
      WHEN c_f_atan|c_f_atanh => -- C_ATAN or C_ATANH 
        in_out_vect := "110001";
      WHEN c_f_sqrt => -- C_SQRT 
        in_out_vect := "100100";
      WHEN OTHERS => -- DEFAULT.
        in_out_vect := "111111";
    END CASE;
    
    in_out_bit := in_out_vect(position);
    in_out_tmp := 0;
    IF (in_out_bit = '1') THEN
      in_out_tmp := 1;	
    END IF;    
    
    RETURN in_out_tmp;
  END;

  FUNCTION f_get_data_extend_length (width : INTEGER) RETURN INTEGER IS
    VARIABLE tmp,cnt : INTEGER;
  BEGIN 
    tmp := 8;
    cnt := 3;
    WHILE (width > tmp) LOOP
      tmp := tmp + tmp; 
      cnt := cnt + 1;
    END LOOP;
    RETURN cnt;
  END;

  FUNCTION get_ccm_scale_latency(cordic_function : INTEGER; output_width : INTEGER)
                   RETURN INTEGER IS
    VARIABLE data_length_int : INTEGER;
    VARIABLE ccm_scale_str : string(1 TO output_width);
    VARIABLE ccm_scale_latency : INTEGER;
  BEGIN
    data_length_int := f_get_data_extend_length(output_width) + output_width;
    IF ((cordic_function = c_f_sinh_cosh) OR (cordic_function = c_f_atanh)) THEN
      FOR I IN 1 TO output_width LOOP
      	ccm_scale_str(I) := c_inv_cordic_scale_hyp_const_str(I);
      END LOOP;
  	ELSE
      FOR I IN 1 TO output_width LOOP
      	ccm_scale_str(I) := c_inv_cordic_scale_trig_const_str(I);
      END LOOP;
   	END IF;
    ccm_scale_latency := get_mult_gen_v4_0_latency(			 
            data_length_int,	 -- c_a_width
            data_length_int,	 -- c_b_width
            1,		         	 -- c_b_type
            0,					 -- c_has_a_signed
            1,					 -- c_reg_a_b_inputs
            0,					 -- c_mem_type
            1,					 -- c_pipeline
            2,					 -- c_mult_type
            0,					 -- c_has_loadb
            data_length_int,	 -- c_baat
            ccm_scale_str,	     -- c_b_value
            0,			         -- c_a_type
            0,					 -- c_has_swapb
            0,					 -- c_sqm_type
            8					 -- bram_addr_width
         ) + 2;
    RETURN ccm_scale_latency;
  END;
  
  FUNCTION getLatency(cordic_function : INTEGER; scale_comp : INTEGER;
                      input_width : INTEGER; output_width : INTEGER; 
                      architecture_sel : INTEGER; pipeline_mode : INTEGER;
                      reg_inputs : INTEGER; round_mode : INTEGER) 
                      RETURN INTEGER IS
    VARIABLE latency_int : INTEGER;
  BEGIN
    latency_int := 0;
    IF (cordic_function = c_f_rotate) THEN
      latency_int := get_rotate_latency(cordic_function,architecture_sel,output_width,pipeline_mode,
                                        round_mode,reg_inputs,scale_comp);
    END IF;
    IF ((cordic_function = c_f_sin_cos) OR
        (cordic_function = c_f_sinh_cosh))
    THEN
      latency_int := get_rotate_latency(cordic_function,architecture_sel,output_width,pipeline_mode,
                                        round_mode,reg_inputs,c_scale_none);
    END IF;
    IF (cordic_function = c_f_translate) THEN
      latency_int := get_translate_latency(cordic_function,architecture_sel,output_width,pipeline_mode,
                                        round_mode,reg_inputs,scale_comp);
    END IF;
    IF ((cordic_function = c_f_atan) OR
        (cordic_function = c_f_atanh))
    THEN
      latency_int := get_translate_latency(cordic_function,architecture_sel,output_width,pipeline_mode,
                                        round_mode,reg_inputs,c_scale_none);
    END IF;
    IF (cordic_function = c_f_sqrt)
    THEN
      latency_int := get_sqrt_latency(architecture_sel,output_width,pipeline_mode,
                                        round_mode,reg_inputs);
    END IF;
    RETURN latency_int;
  END;

  FUNCTION get_round_latency(round_mode : INTEGER) RETURN INTEGER IS
    VARIABLE latency_int : INTEGER;
  BEGIN
  	latency_int := 0;
    IF ((round_mode = C_ROUND_POS_INF) OR (round_mode = C_ROUND_POS_NEG_INF)) THEN
       latency_int := 1;
  	END IF;
    RETURN latency_int;
  END;
  
  FUNCTION get_round_ext(round_mode : INTEGER) RETURN INTEGER IS
    VARIABLE ext_int : INTEGER;
  BEGIN
  	ext_int := 0;
    IF (round_mode = C_ROUND_POS_INF) THEN
      ext_int := 1;
    END IF;
    IF (round_mode = C_ROUND_POS_NEG_INF) THEN
       ext_int := 2;
  	END IF;
    RETURN ext_int;
  END;
  
  FUNCTION get_rotate_latency(cordic_function:INTEGER;architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER;scale_comp:INTEGER)
                RETURN INTEGER IS
    VARIABLE latency_int : INTEGER; 
    VARIABLE iterations : INTEGER;
  BEGIN
    latency_int := 0;
    iterations := output_width;
    IF (cordic_function = c_f_sinh_cosh) AND (iterations >= 13) THEN
      iterations := iterations + 2;
    ELSIF (cordic_function = c_f_sinh_cosh) AND (iterations >= 4)THEN
      iterations := iterations + 1;
    END IF;
    --Coarse Input Rotation
      --Optional input register
      IF reg_inputs = 1 THEN
    	latency_int := latency_int + 1;
      END IF;
      --Coarse Input Stage (Always Pipelined)
      latency_int := latency_int + 2;
      --ENG ND setup time.
      latency_int := latency_int + 1;
      --CORDIC Engine delay (Subject to Pipeline)
      IF pipeline_mode = c_pipe_max THEN
        latency_int := latency_int + iterations;
      END IF;
      IF pipeline_mode = c_pipe_opt THEN
        latency_int := latency_int + iterations;
      END IF;
      IF pipeline_mode = c_pipe_none THEN
        latency_int := latency_int;
      END IF;
      --CCM (Always Pipelined)
      IF scale_comp = c_scale_ccm THEN
        latency_int := latency_int + get_ccm_scale_latency(cordic_function, output_width);
      END IF;
      --Cordic Round (Always Pipelined)
      latency_int := latency_int + get_round_latency(round_mode);
      --Coarse Output Rotation (Always Pipelined)
      latency_int := latency_int + 2;
    RETURN latency_int;
  END;

  FUNCTION get_translate_latency(cordic_function:INTEGER;architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER;scale_comp:INTEGER)
                RETURN INTEGER IS
    VARIABLE latency_int : INTEGER; 
    VARIABLE iterations : INTEGER;
  BEGIN
    latency_int := 0;
    iterations := output_width;
    IF (cordic_function = c_f_atanh) AND (iterations >= 13) THEN
      iterations := iterations + 2;
    ELSIF (cordic_function = c_f_atanh) AND (iterations >= 4) THEN
      iterations := iterations + 1;
    END IF;

    --Coarse Input Rotation
      --Optional input register
      IF reg_inputs = 1 THEN
    	latency_int := latency_int + 1;
      END IF;
      --Coarse Input Stage (Always Pipelined)
      latency_int := latency_int + 2;
      --ENG ND setup time.
      latency_int := latency_int + 1;
      --CORDIC Engine delay (Subject to Pipeline)
      IF pipeline_mode = c_pipe_max THEN
        latency_int := latency_int + iterations;
      END IF;
      IF pipeline_mode = c_pipe_opt THEN
        latency_int := latency_int + iterations;
      END IF;
      IF pipeline_mode = c_pipe_none THEN
        latency_int := latency_int;
      END IF;
      --CCM (Always Pipelined)
      IF scale_comp = c_scale_ccm THEN
        latency_int := latency_int + get_ccm_scale_latency(c_f_translate, output_width);
      END IF;
      --Cordic Round
      latency_int := latency_int + get_round_latency(round_mode);
      --Coarse Output Rotation
      latency_int := latency_int + 2;
    RETURN latency_int;
  END;

  FUNCTION get_sqrt_latency(architecture_sel:INTEGER;output_width:INTEGER;
                pipeline_mode:INTEGER;round_mode:INTEGER;reg_inputs:INTEGER)
                RETURN INTEGER IS
    VARIABLE latency_int : INTEGER; 
    VARIABLE round_int : INTEGER; 
  BEGIN
    latency_int := 0;
    round_int := 0;
    --Optional input register
    IF reg_inputs = 1 THEN
    	latency_int := latency_int + 1;
    END IF;
    --Sqrt Calculation delay
    IF pipeline_mode = c_pipe_none THEN
      latency_int := latency_int;
      round_int := 0;
    END IF;
    --IF pipeline_mode = c_pipe_opt THEN
    --  latency_int := latency_int + (output_width-2)/2;
    --END IF;
    IF ((pipeline_mode = c_pipe_opt) OR (pipeline_mode = c_pipe_max)) THEN
    	latency_int := latency_int + output_width -2;
        round_int := 1;
    END IF;
    --Sqrt Round Operation
    --due to extended length of calculation for extra bits to round.
    IF ((round_mode = c_round_pos_inf) OR (round_mode = c_round_pos_neg_inf)) THEN
      latency_int := latency_int + 1 + round_int;
    END IF;
    --Sqrt output register
    latency_int := latency_int +1;
    RETURN latency_int;
  END;

  FUNCTION set_vect_bv(x: BIT_VECTOR; val: BIT) RETURN BIT_VECTOR IS
    VARIABLE tmp : BIT_VECTOR(x'LENGTH-1 DOWNTO 0);
  BEGIN
  	FOR I IN x'LENGTH-1 DOWNTO 0 LOOP
  	  tmp(I) := val;	
  	END LOOP;
    RETURN tmp;
  END;
  
  FUNCTION set_vect_sl(x: STD_LOGIC_VECTOR; val: STD_LOGIC) RETURN STD_LOGIC_VECTOR IS                  
    VARIABLE tmp : STD_LOGIC_VECTOR(x'LENGTH-1 DOWNTO 0);
  BEGIN
  	FOR I IN x'LENGTH-1 DOWNTO 0 LOOP
  	  tmp(I) := val;	
  	END LOOP;
    RETURN tmp;
  END;

  FUNCTION slice_down_bv(x: BIT_VECTOR; start, stop : INTEGER) RETURN BIT_VECTOR IS
    VARIABLE slice_tmp : BIT_VECTOR((start-stop) DOWNTO 0); 
  BEGIN
  	FOR I IN (start-stop) DOWNTO 0 LOOP
  	  slice_tmp(I) := x(I+stop);	
  	END LOOP;
    RETURN slice_tmp;
  END;

  FUNCTION slice_down_sl(x: STD_LOGIC_VECTOR; start, stop : INTEGER) RETURN STD_LOGIC_VECTOR IS                  
    VARIABLE slice_tmp : STD_LOGIC_VECTOR((start-stop) DOWNTO 0); 
  BEGIN
  	FOR I IN (start-stop) DOWNTO 0 LOOP
  	  slice_tmp(I) := x(I+stop);	
  	END LOOP;
    RETURN slice_tmp;
  END;

  FUNCTION slice_up_bv(x: BIT_VECTOR; start, stop : INTEGER) RETURN BIT_VECTOR IS
    VARIABLE slice_tmp : BIT_VECTOR(0 TO (stop-start)); 
  BEGIN
  	FOR I IN 0 TO (stop-start) LOOP
  	  slice_tmp(I) := x(I+start);	
  	END LOOP;
    RETURN slice_tmp;
  END;

  FUNCTION slice_up_sl(x: STD_LOGIC_VECTOR; start, stop : INTEGER) RETURN STD_LOGIC_VECTOR IS
    VARIABLE slice_tmp : STD_LOGIC_VECTOR(0 TO (stop-start)); 
  BEGIN
  	FOR I IN 0 TO (stop-start) LOOP
  	  slice_tmp(I) := x(I+start);	
  	END LOOP;
    RETURN slice_tmp;
  END;

  FUNCTION slice_str(x: STRING; start, stop : INTEGER) RETURN STRING IS                  
    VARIABLE slice_tmp : STRING(1 TO (stop-start+1)); 
  BEGIN
  	FOR I IN 1 TO (stop-start+1) LOOP
  	  slice_tmp(I) := x(I+start-1);	
  	END LOOP;
    RETURN slice_tmp;
  END;
  
  FUNCTION bv_to_sl(x: BIT_VECTOR) RETURN STD_LOGIC_VECTOR IS
    VARIABLE slv_tmp : STD_LOGIC_VECTOR(x'length-1 DOWNTO 0);
  BEGIN
    FOR I IN x'length-1 DOWNTO 0 LOOP
	  slv_tmp(I) := '0';
      IF (x(x'low+I) = '1') THEN
      	slv_tmp(I) := '1';
      END IF;	
    END LOOP;
    RETURN slv_tmp;
  END;

  FUNCTION b_to_sl(x: BIT) RETURN STD_LOGIC IS
    VARIABLE sl_tmp : STD_LOGIC;
  BEGIN
    sl_tmp := '0';
    IF (x = '1') THEN
      sl_tmp := '1';
    END IF;	
    RETURN sl_tmp;
  END;

  FUNCTION sl_to_bv(x: STD_LOGIC_VECTOR) RETURN BIT_VECTOR IS
    VARIABLE bv_tmp : BIT_VECTOR(x'length-1 DOWNTO 0);
  BEGIN
    FOR I IN x'length-1 DOWNTO 0 LOOP
	  bv_tmp(I) := '0';
      IF (x(x'low+I) = '1') THEN
      	bv_tmp(I) := '1';
      END IF;	
    END LOOP;
    RETURN bv_tmp;
  END;

  FUNCTION sl_to_b(x: STD_LOGIC) RETURN BIT IS
    VARIABLE bv_tmp : BIT;
  BEGIN
    bv_tmp := '0';
    IF (x = '1') THEN
      bv_tmp := '1';
    END IF;	
    RETURN bv_tmp;
  END;

  FUNCTION bv_to_str(x: BIT_VECTOR) RETURN STRING IS
    VARIABLE str_tmp : STRING(1 TO x'length);
  BEGIN
    FOR I IN x'length-1 DOWNTO 0 LOOP
	  str_tmp(x'length - I) := '0';
      IF (x(x'low+I) = '1') THEN
	  str_tmp(x'length - I) := '1';
      END IF;	
    END LOOP;
    RETURN str_tmp;
  END;

  FUNCTION str_to_bv(x: STRING) RETURN BIT_VECTOR IS
    VARIABLE bv_tmp : BIT_VECTOR(x'length-1 DOWNTO 0);
  BEGIN
    FOR I IN bv_tmp'high DOWNTO bv_tmp'low LOOP
	  bv_tmp(I) := '0';
      IF (x(x'high-I) = '1') THEN
	  bv_tmp(I) := '1';
      END IF;	
    END LOOP;
    RETURN bv_tmp;
  END;

  FUNCTION nat_to_bv(x: NATURAL; len: INTEGER) RETURN BIT_VECTOR IS
    VARIABLE x_old : NATURAL;
    VARIABLE x_new : NATURAL;
    VARIABLE bv_tmp : BIT_VECTOR(len-1 DOWNTO 0);
  BEGIN
    x_old := x;
    FOR I IN 0 TO LEN-1 LOOP
	  x_new := x_old/2; 
      bv_tmp(I) := '0';
      IF ((x_old - x_new -x_new) = 1) THEN
	  bv_tmp(I) := '1';
      END IF;
      x_old := x_new;	
    END LOOP;
    RETURN bv_tmp;
  END;

  FUNCTION bv_to_nat(x: BIT_VECTOR) RETURN NATURAL IS
    VARIABLE nat_tmp : NATURAL;
    VARIABLE sum_term : NATURAL;
  BEGIN
  	nat_tmp := 0;
    sum_term := 1;
    FOR I IN x'low TO x'high LOOP
      IF (x(I) = '1') THEN
	  nat_tmp := nat_tmp + sum_term;
      END IF;
      sum_term := sum_term + sum_term;	
    END LOOP;
    RETURN nat_tmp;    
  END;

  FUNCTION int_to_bv(x: INTEGER; len: INTEGER) RETURN BIT_VECTOR IS
    VARIABLE x_old : INTEGER;
    VARIABLE x_new : INTEGER;
    VARIABLE low_bit : BIT;
    VARIABLE high_bit : BIT;
    VARIABLE bv_tmp : BIT_VECTOR(len-1 DOWNTO 0);
  BEGIN
    low_bit := '0';
    high_bit := '1';
    x_old := x;
    IF (x < 0) THEN
      low_bit := '1';
      high_bit := '0';	
      x_old := -x;
    END IF;    
    FOR I IN 0 TO LEN-1 LOOP
	  x_new := x_old/2; 
      bv_tmp(I) := low_bit;
      IF ((x_old - x_new -x_new) = 1) THEN
	  bv_tmp(I) := high_bit;
      END IF;	
      x_old := x_new;
    END LOOP;
    RETURN bv_tmp;
  END;

  FUNCTION bv_to_int(x: BIT_VECTOR) RETURN INTEGER IS
    VARIABLE int_tmp : INTEGER;
    VARIABLE sum_term : INTEGER;
    VARIABLE adj_term : INTEGER;
    VARIABLE nat_tmp : INTEGER;
  BEGIN
  	int_tmp := 0;
    sum_term := 1;
    adj_term := 0;
    nat_tmp := 0;
    IF (x(x'high) = '1') THEN
      adj_term := -2;
    END IF;    
    FOR I IN x'low TO x'high LOOP
      IF (x(I) = '1') THEN
	  nat_tmp := nat_tmp + sum_term;
      END IF;
      sum_term := sum_term + sum_term;	
      adj_term := adj_term + adj_term;	
    END LOOP;
    nat_tmp := nat_tmp - adj_term;
    RETURN nat_tmp;    
  END;
  
  FUNCTION max_int(x : IN INTEGER; y : IN INTEGER) RETURN INTEGER IS
    VARIABLE max_tmp : INTEGER;
  BEGIN
    max_tmp := x;
	IF y > x THEN
      max_tmp := y;   
    END IF;
    RETURN max_tmp;
  END;
    
  FUNCTION min_int(x : IN INTEGER; y : IN INTEGER) RETURN INTEGER IS
    VARIABLE min_tmp : INTEGER;
  BEGIN
    min_tmp := x;
	IF y < x THEN
      min_tmp := y;   
    END IF;
    RETURN min_tmp;
  END;
  
  FUNCTION add_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
  BEGIN
    RETURN add_c_bv(x,y,'0');
  END;
  FUNCTION add_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
  BEGIN
    RETURN add_c_bv(x,y,'0');
  END;
  FUNCTION sub_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
    variable y_inv : BIT_VECTOR(y'length-1 DOWNTO 0);
  BEGIN
  	FOR I IN y'length-1 DOWNTO 0 LOOP
      y_inv(I) := '1';
      IF (y(I+y'LOW) = '1') THEN
      	y_inv(I) := '0';
      END IF;
  	END LOOP;
    RETURN add_c_bv(x,y_inv,'1');
  END;
  FUNCTION sub_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
    VARIABLE x_int : BIT_VECTOR(x'length DOWNTO 0); 
    VARIABLE y_inv : BIT_VECTOR(y'length DOWNTO 0); 
    VARIABLE length_int : INTEGER := max_int(x'length, y'length); 
    VARIABLE sum_int : BIT_VECTOR(length_int DOWNTO 0); 
    VARIABLE sum_int_slice : BIT_VECTOR(length_int-1 DOWNTO 0); 
  BEGIN
  	FOR I IN x'LENGTH-1 DOWNTO 0 LOOP
  	  x_int(I) := x(I+x'LOW);	
  	END LOOP;
  	FOR I IN y'LENGTH-1 DOWNTO 0 LOOP
      y_inv(I) := '1';
      IF (y(I+y'LOW) = '1') THEN
      	y_inv(I) := '0';
      END IF;      
  	END LOOP;
    x_int(x'length) := '0';
    y_inv(y'length) := '1';
    sum_int := add_c_bv(x_int,y_inv,'1');
  	FOR I IN length_int-1 DOWNTO 0 LOOP
	  sum_int_slice(I) := sum_int(I);
  	END LOOP;
    RETURN sum_int_slice;
  END;

  FUNCTION add_c_bv(x : BIT_VECTOR; y : BIT_VECTOR; c : BIT) RETURN BIT_VECTOR IS
    VARIABLE length_int : INTEGER := max_int(x'length, y'length); 
    VARIABLE x_int, y_int : BIT_VECTOR(length_int-1 DOWNTO 0); 
    VARIABLE carry_int : BIT;
    VARIABLE carry_out : BIT;
    VARIABLE x_xor_y : BIT;
    VARIABLE sum_out : BIT;
    VARIABLE sum_int : BIT_VECTOR(length_int-1 DOWNTO 0);
  BEGIN

  	carry_int := c;

    FOR I IN length_int-1 DOWNTO 0 LOOP
      x_int(I) := x(x'high);
      y_int(I) := y(y'high);
      IF (I < x'length) THEN
        x_int(I) := x(x'low + I);
      END IF;
      IF (I < y'length) THEN
        y_int(I) := y(y'low + I);
      END IF;
    END LOOP;
          
    FOR I IN 0 TO length_int-1 LOOP
      carry_out := '0';
      IF (((x_int(I) = '1') AND (y_int(I) = '1')) OR 
          ((x_int(I) = '1') AND (carry_int = '1')) OR
          ((y_int(I) = '1') AND (carry_int = '1'))) THEN
        carry_out := '1';
      END IF;
      x_xor_y := '0';
      IF (((x_int(I) = '1') AND (y_int(I) = '0')) OR
          ((x_int(I) = '0') AND (y_int(I) = '1'))) THEN
        x_xor_y := '1';
      END IF;
      sum_out := '0';
      IF (((x_xor_y = '1') AND (carry_int = '0')) OR
          ((x_xor_y = '0') AND (carry_int = '1'))) THEN
        sum_out := '1';
      END IF;      
      carry_int := carry_out;
      sum_int(I) := sum_out;
    END LOOP;    
    RETURN sum_int;    
  END;

  FUNCTION rnd_ubv(x : IN BIT_VECTOR; mode : IN INTEGER; precision : IN INTEGER)
                  RETURN BIT_VECTOR IS
    VARIABLE sx : BIT_VECTOR(x'length DOWNTO 0); 
    VARIABLE tmp : BIT_VECTOR(precision DOWNTO 0);
  BEGIN
  	sx(x'length-1 DOWNTO 0) := x;
    sx(x'length) := '0';
  	tmp := rnd_sbv(sx, mode, precision+1);
    RETURN tmp(precision-1 DOWNTO 0);
  END;

  FUNCTION rnd_sbv(x : IN BIT_VECTOR; mode : IN INTEGER; precision : IN INTEGER) 
           RETURN BIT_VECTOR IS
  	VARIABLE x_int : BIT_VECTOR(x'length+1 DOWNTO 0);
  	VARIABLE rnd_tmp : BIT_VECTOR(precision+1 DOWNTO 0);
  	VARIABLE one_vect : BIT_VECTOR(precision+1 DOWNTO 0);
    
  BEGIN

    -- extend input by 2 bits to allow for rounding 
    x_int(x'length+1 DOWNTO 2) := x;
    x_int(1 DOWNTO 0) := "00";
 
    -- Truncate Round
    IF (mode = c_round_truncate) THEN
      rnd_tmp(precision+1 DOWNTO 0) := x_int(x'length+1 DOWNTO x'length-precision);
    END IF; -- IF (p_round_mode = c_round_truncate)
  
    -- Round to Positive Infinity
    IF (mode = c_round_pos_inf) THEN
      -- Add 1/2 to input and Truncate
      one_vect := set_vect_bv(one_vect, '0');	
      one_vect(1) := '1';  
      rnd_tmp := add_sbv(x_int(x'length+1 DOWNTO x'length-precision), one_vect);
    END IF; -- IF (p_round_mode = c_round_pos_inf)
                 
    -- Round to Plus or Minus Infinity
    IF (mode = c_round_pos_neg_inf) THEN
      -- If input positive then add 1/2 and Truncate
      IF x_int(x'length+1) = '0' THEN
        one_vect := set_vect_bv(one_vect, '0');	
        one_vect(1) := '1';	
      END IF;
      -- If input is negative then add 1/4 and Truncate
      IF x_int(x'length+1) = '1' THEN
        one_vect := set_vect_bv(one_vect, '0');	
        one_vect(0) := '1';	
      END IF;
  
      rnd_tmp := add_sbv(x_int(x'length+1 DOWNTO x'length-precision), one_vect);
    END IF;

    --Check for overflow or underflow
    IF ( (rnd_tmp(precision+1) = '1') AND
         (rnd_tmp(precision+1) /= x_int(x'length+1)) ) THEN
      rnd_tmp := x_int(x'length+1 DOWNTO x'length-precision);
    END IF;

    RETURN rnd_tmp(precision+1 DOWNTO 2);                 

  END rnd_sbv;

  FUNCTION rnd_ulv(x : IN STD_LOGIC_VECTOR; mode : IN INTEGER; precision : IN INTEGER)
                  RETURN STD_LOGIC_VECTOR IS
    VARIABLE sx : BIT_VECTOR(x'length DOWNTO 0); 
    VARIABLE tmp : STD_LOGIC_VECTOR(precision DOWNTO 0);
  BEGIN
  	sx(x'length-1 DOWNTO 0) := sl_to_bv(x);
    sx(x'length) := '0';
  	tmp := bv_to_sl(rnd_sbv(sx, mode, precision+1));
    RETURN tmp(precision-1 DOWNTO 0);
  END;
  FUNCTION rnd_slv(x : IN STD_LOGIC_VECTOR; mode : IN INTEGER; precision : IN INTEGER)
                  RETURN STD_LOGIC_VECTOR IS
    VARIABLE sx : BIT_VECTOR(x'length-1 DOWNTO 0); 
    VARIABLE tmp : STD_LOGIC_VECTOR(precision-1 DOWNTO 0);
  BEGIN
  	sx := sl_to_bv(x);
  	tmp := bv_to_sl(rnd_sbv(sx, mode, precision));
    RETURN tmp;
  END;

  FUNCTION f_inv_cordic_scale_coeff_slv(width, cordic_funct : INTEGER) RETURN STD_LOGIC_VECTOR IS
    VARIABLE inv_scale_in : STD_LOGIC_VECTOR(c_max_rom_width-1 DOWNTO 0);
    VARIABLE inv_scale_int : STD_LOGIC_VECTOR(width-1 DOWNTO 0);
  BEGIN
    IF (cordic_funct=c_f_sinh_cosh) OR (cordic_funct=c_f_atanh) THEN
      inv_scale_in := c_inv_cordic_scale_hyp_const_slv;
    ELSE
      inv_scale_in := c_inv_cordic_scale_trig_const_slv;
    END IF;
    inv_scale_int := slice_down_sl(inv_scale_in,c_max_rom_width-1,c_max_rom_width-width);
  	RETURN inv_scale_int;
  END;

  FUNCTION f_inv_cordic_scale_coeff_str(width, cordic_funct : INTEGER) RETURN STRING IS
    VARIABLE inv_scale_in : STRING(1 TO c_max_rom_width);
    VARIABLE inv_scale_int : STRING(1 TO width);
  BEGIN
    IF (cordic_funct=c_f_sinh_cosh) OR (cordic_funct=c_f_atanh) THEN
      inv_scale_in := c_inv_cordic_scale_hyp_const_str;
    ELSE
      inv_scale_in := c_inv_cordic_scale_trig_const_str;
    END IF;
    inv_scale_int := slice_str(inv_scale_in,1,width);
  	RETURN inv_scale_int;
  END;
  
END;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;

PACKAGE cordic_pack_beh_v1_1 IS

    --Left/Right shift bit vectors.
  FUNCTION left_shift_ubv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR;
  FUNCTION right_shift_ubv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR;  
  FUNCTION left_shift_sbv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR;
  FUNCTION right_shift_sbv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR;  

  -- Functions for Mult and SQRT
  FUNCTION mult_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION mult_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR;
  FUNCTION sqrt_ubv(data_in : IN BIT_VECTOR; precision : IN INTEGER) RETURN BIT_VECTOR;
  FUNCTION sqrt_sbv(data_in : IN BIT_VECTOR; precision : IN INTEGER) RETURN BIT_VECTOR;  
  
END cordic_pack_beh_v1_1;

PACKAGE BODY cordic_pack_beh_v1_1 is

  FUNCTION left_shift_ubv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR IS
    VARIABLE tmp : BIT_VECTOR(x'LENGTH-1 DOWNTO 0); 
  BEGIN
    tmp := set_vect_bv(tmp, '0');	
    tmp(x'LENGTH-1) := x(x'HIGH);
    FOR I IN (x'LENGTH - shift -2) DOWNTO 0 LOOP
      tmp(I+shift) := x(I+x'LOW);	
    END LOOP;    
    RETURN tmp;
  END;

  FUNCTION right_shift_ubv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR IS
    VARIABLE tmp : BIT_VECTOR(x'LENGTH-1 DOWNTO 0); 
  BEGIN
    tmp := set_vect_bv(tmp, '0');	
    FOR I IN (x'LENGTH - shift -2) DOWNTO 0 LOOP
      tmp(I) := x(I+shift+x'LOW);	
    END LOOP;    
    RETURN tmp;
  END; 
  
  FUNCTION left_shift_sbv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR IS
    VARIABLE tmp : BIT_VECTOR(x'LENGTH-1 DOWNTO 0); 
  BEGIN
    tmp := set_vect_bv(tmp, '0');	
    tmp(x'LENGTH-1) := x(x'high);
    FOR I IN (x'length - shift -2) DOWNTO 0 LOOP
      tmp(I+shift) := x(I+x'low);	
    END LOOP;    
    RETURN tmp;
  END;

  FUNCTION right_shift_sbv(x : IN BIT_VECTOR; shift : IN INTEGER) RETURN BIT_VECTOR IS
    VARIABLE tmp : BIT_VECTOR(x'LENGTH-1 DOWNTO 0); 
  BEGIN
    tmp := set_vect_bv(tmp, x(x'HIGH));	
    FOR I IN (x'LENGTH - shift -2) DOWNTO 0 LOOP
      tmp(I) := x(I+shift+x'LOW);	
    END LOOP;    
    RETURN tmp;
  END;  

  FUNCTION mult_ubv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
    VARIABLE mult_int: BIT_VECTOR((x'LENGTH+y'LENGTH-1) DOWNTO 0);
    VARIABLE add_term: BIT_VECTOR((x'LENGTH+y'LENGTH-1) DOWNTO 0);
  BEGIN
  	FOR I IN (x'LENGTH+y'LENGTH-1) DOWNTO 0 LOOP
  	  mult_int(I) := '0';	
	  add_term(I) := '0';
  	END LOOP;
  	add_term(y'length-1 DOWNTO 0) := y;
    FOR I IN 0 TO x'LENGTH-1 LOOP
      IF x(I+x'low) = '1' THEN
        mult_int := add_ubv(mult_int, add_term);
      END IF;
      add_term := left_shift_ubv(add_term, 1);
    END LOOP;
    RETURN mult_int;
  END mult_ubv;

  FUNCTION mult_sbv(x : BIT_VECTOR; y : BIT_VECTOR) RETURN BIT_VECTOR IS
    VARIABLE mult_int: BIT_VECTOR((x'LENGTH+y'LENGTH-1) DOWNTO 0);
    VARIABLE add_term: BIT_VECTOR((x'LENGTH+y'LENGTH-1) DOWNTO 0);
  BEGIN
  	FOR I IN (x'LENGTH+y'LENGTH-1) DOWNTO 0 LOOP
  	  mult_int(I) := '0';	
	  add_term(I) := y(y'high);
  	END LOOP;
  	add_term(y'length-1 DOWNTO 0) := y;
    FOR I IN 0 TO x'LENGTH-1 LOOP
      IF x(I+x'low) = '1' THEN
        mult_int := add_sbv(mult_int, add_term);
      END IF;
      add_term := left_shift_sbv(add_term, 1);
    END LOOP;
    IF x(x'high) = '1' THEN
      mult_int := sub_sbv(mult_int, add_term);
    END IF;    
    RETURN mult_int;
  END mult_sbv;

  FUNCTION sqrt_ubv(data_in : IN BIT_VECTOR; precision : IN INTEGER) RETURN BIT_VECTOR IS
    CONSTANT data_width_even : INTEGER := data_in'length + (data_in'length MOD 2);
    VARIABLE data_even : BIT_VECTOR(data_width_even-1 DOWNTO 0);
    VARIABLE data_int : BIT_VECTOR(2*precision-1 DOWNTO 0);
    VARIABLE rem_int : BIT_VECTOR(2*precision-1 DOWNTO 0);
    VARIABLE rem_next : BIT_VECTOR(2*precision-1 DOWNTO 0);
    VARIABLE sqre_diff : BIT_VECTOR(2*precision-1 DOWNTO 0);
    VARIABLE sqrt_int : BIT_VECTOR(precision-1 DOWNTO 0);    
  BEGIN
    data_even(data_width_even-1) := '0';
    FOR I IN (data_in'length-1) DOWNTO 0 LOOP
      data_even(I) := data_in(I);	
    END LOOP;    

    FOR I IN (2*precision-1) DOWNTO 0 LOOP
      IF (I <= data_width_even-1) THEN
        data_int(2*precision-1 -I) := data_even(data_width_even-1-I);
      ELSE
        data_int(2*precision-1 -I) := '0';
      END IF;
    END LOOP;

    --init variables    
    sqre_diff := set_vect_bv(sqre_diff, '0');	
    sqre_diff(1) := '0';
    sqre_diff(0) := '1';
    rem_int := set_vect_bv(rem_int, '0');	
    rem_next := set_vect_bv(rem_next, '0');	
    sqrt_int := set_vect_bv(sqrt_int, '0');	
  
   FOR I IN precision-1 DOWNTO 0 LOOP
     --left shift the existing remainder internal
      FOR J IN precision-2 DOWNTO 0 LOOP
        rem_int(J+2) := rem_int(J);	
      END LOOP;    
      rem_int(1) := data_int (2*I+1);
      rem_int(0) := data_int (2*I);
      --update the current difference in the Square Difference
      FOR J IN precision-3 DOWNTO 0 LOOP
        sqre_diff(J+2) := sqrt_int(J);	
      END LOOP;      
      rem_next := sub_ubv(rem_int, sqre_diff);
      --assign sqrt_int
      FOR J IN precision-2 DOWNTO 0 LOOP
        sqrt_int(J+1) := sqrt_int(J);	
      END LOOP;    
      sqrt_int(0) := '0';
      IF (rem_next(precision) = '0') THEN
        rem_int := rem_next;
        sqrt_int(0) := '1';
      END IF;
   END LOOP;
    RETURN sqrt_int;  
      
  END;

  FUNCTION sqrt_sbv(data_in : IN BIT_VECTOR; precision : IN INTEGER) RETURN BIT_VECTOR IS
    VARIABLE data_in_slice : BIT_VECTOR(data_in'length-2 DOWNTO 0);
    VARIABLE sqrt_unsig : BIT_VECTOR(precision-2 DOWNTO 0);
    VARIABLE sqrt_int : BIT_VECTOR(precision-1 DOWNTO 0);     
  BEGIN
    FOR I IN data_in'length-2 DOWNTO 0 LOOP
      data_in_slice(I) := data_in(I);	
    END LOOP;
    sqrt_unsig := sqrt_ubv(data_in_slice, precision-1);
    sqrt_int(precision-1) := '0';
    FOR I IN precision-2 DOWNTO 0 LOOP
      sqrt_int(I) := sqrt_unsig(I);	
    END LOOP;
    RETURN sqrt_int;
  END sqrt_sbv;
  
END;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

PACKAGE lib_comps_beh_cordic_v1_1 IS
  
COMPONENT lib_fd_beh_sb_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN SIGNED(p_width-1 DOWNTO 0);
     q : OUT SIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd_beh_ub_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;

COMPONENT lib_fd_beh_bv_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN BIT_VECTOR(p_width-1 DOWNTO 0);
     q : OUT BIT_VECTOR(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;  
  
COMPONENT lib_fd_beh_cordic_v1_1
  GENERIC (
     p_enable_rlocs : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     q : OUT STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END COMPONENT;

COMPONENT lib_fd1_beh_sb_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1_beh_ub_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1_beh_bv_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1_beh_cordic_v1_1
  GENERIC (
     p_enable_rlocs :INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN STD_LOGIC;
     q : OUT STD_LOGIC;
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END COMPONENT;

COMPONENT lib_fd1i_beh_sb_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_ainit : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1i_beh_ub_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_ainit : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1i_beh_bv_cordic_v1_1
  GENERIC (
     p_has_ce : INTEGER := 0;
     p_has_ainit : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END COMPONENT;
  
COMPONENT lib_fd1i_beh_cordic_v1_1
  GENERIC (
     p_enable_rlocs :INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_ainit : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN STD_LOGIC;
     q : OUT STD_LOGIC;
     clk : IN STD_LOGIC;
     ainit : IN STD_LOGIC;
     sinit : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END COMPONENT;

COMPONENT lib_fifo_beh_sb_cordic_v1_1
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN SIGNED(p_width-1 DOWNTO 0);
     q : OUT SIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;

COMPONENT lib_fifo_beh_ub_cordic_v1_1
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;

COMPONENT lib_fifo_beh_bv_cordic_v1_1
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN BIT_VECTOR(p_width-1 DOWNTO 0);
     q : OUT BIT_VECTOR(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END COMPONENT;

COMPONENT lib_fifo_beh_cordic_v1_1
  GENERIC (
     p_depth : INTEGER := 2;
     p_enable_rlocs :INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     q : OUT STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END COMPONENT;

COMPONENT lib_ccm_mult_beh_cordic_v1_1
  GENERIC (
    p_data_in_width : INTEGER := 8;
    p_data_type : INTEGER := 0;
    p_enable_rlocs : INTEGER := 1;
    p_b_value : STRING; 
    p_data_out_width : INTEGER := 8; 
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    a : IN STD_LOGIC_VECTOR(p_data_in_width-1 DOWNTO 0);
    q : OUT STD_LOGIC_VECTOR(p_data_out_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    rdy : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
END COMPONENT;
  
END lib_comps_beh_cordic_v1_1;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd_beh_sb_cordic_v1_1 IS
  GENERIC (
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN SIGNED(p_width-1 DOWNTO 0);
     q : OUT SIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd_beh_sb_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd_beh_sb_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : SIGNED(p_width-1 DOWNTO 0) := (OTHERS => '0');
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= (OTHERS => '0');
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
        q_tmp <= (OTHERS => '0');
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd_beh_ub_cordic_v1_1 IS
  GENERIC (
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd_beh_ub_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd_beh_ub_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : UNSIGNED(p_width-1 DOWNTO 0) := (OTHERS => '0');
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= (OTHERS => '0');
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
        q_tmp <= (OTHERS => '0');
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd_beh_bv_cordic_v1_1 IS
  GENERIC (
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN BIT_VECTOR(p_width-1 DOWNTO 0);
     q : OUT BIT_VECTOR(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd_beh_bv_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd_beh_bv_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : BIT_VECTOR(p_width-1 DOWNTO 0) := (OTHERS => '0');
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= (OTHERS => '0');
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
      	q_tmp <= (OTHERS => '0');
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd_beh_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     q : OUT STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END lib_fd_beh_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd_beh_cordic_v1_1 IS

  SIGNAL aclr_int : STD_LOGIC := '0';
  SIGNAL sclr_int : STD_LOGIC := '0';
  SIGNAL ce_int : STD_LOGIC := '1';
  SIGNAL q_tmp : STD_LOGIC_VECTOR(p_width-1 DOWNTO 0) := (OTHERS => '0');

BEGIN
	
  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= (OTHERS => '0');
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
        q_tmp <= (OTHERS => '0');
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1_beh_sb_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd1_beh_sb_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1_beh_sb_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';

  SIGNAL q_tmp : BIT := '0';
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= '0';
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
      	q_tmp <= '0';
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1_beh_ub_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd1_beh_ub_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1_beh_ub_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';

  SIGNAL q_tmp : BIT := '0';
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= '0';
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
      	q_tmp <= '0';
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1_beh_bv_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fd1_beh_bv_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1_beh_bv_cordic_v1_1 IS
  SIGNAL aclr_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';

  SIGNAL q_tmp : BIT := '0';
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= '0';
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
      	q_tmp <= '0';
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1_beh_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0
  );
  PORT (
     d : IN STD_LOGIC;
     q : OUT STD_LOGIC;
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END lib_fd1_beh_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1_beh_cordic_v1_1 IS
  SIGNAL aclr_int : STD_LOGIC := '0';
  SIGNAL sclr_int : STD_LOGIC := '0';
  SIGNAL ce_int : STD_LOGIC := '1';
  SIGNAL q_tmp : STD_LOGIC := '0';
BEGIN

  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    aclr_int <= '0';
    sclr_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      aclr_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sclr_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      q_tmp <= '0';
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sclr_int = '1') THEN
      	q_tmp <= '0';
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1i_beh_sb_cordic_v1_1 IS
  GENERIC (
     p_has_ainit : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END lib_fd1i_beh_sb_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1i_beh_sb_cordic_v1_1 IS
  SIGNAL ainit_int : BIT := '0';
  SIGNAL sinit_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : BIT := p_init;
BEGIN

  init_control : PROCESS(ainit,sinit,ce)
  BEGIN
    ainit_int <= '0';
    sinit_int <= '0';
    ce_int <= '1';
    IF (p_has_ainit = 1) THEN
      ainit_int <= ainit;
    END IF;
    IF (p_has_sinit = 1) THEN
      sinit_int <= sinit;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,ainit)
  BEGIN
    IF (ainit_int = '1') THEN
      q_tmp <= p_init;
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sinit_int = '1') THEN
        q_tmp <= sinit;
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;


LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1i_beh_ub_cordic_v1_1 IS
  GENERIC (
     p_has_ainit : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END lib_fd1i_beh_ub_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1i_beh_ub_cordic_v1_1 IS
  SIGNAL ainit_int : BIT := '0';
  SIGNAL sinit_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : BIT := p_init;
BEGIN

  init_control : PROCESS(ainit,sinit,ce)
  BEGIN
    ainit_int <= '0';
    sinit_int <= '0';
    ce_int <= '1';
    IF (p_has_ainit = 1) THEN
      ainit_int <= ainit;
    END IF;
    IF (p_has_sinit = 1) THEN
      sinit_int <= sinit;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,ainit)
  BEGIN
    IF (ainit_int = '1') THEN
      q_tmp <= p_init;
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sinit_int = '1') THEN
      	q_tmp <= p_init;
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1i_beh_bv_cordic_v1_1 IS
  GENERIC (
     p_has_ainit : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : BIT := '0'
  );
  PORT (
     d : IN BIT;
     q : OUT BIT;
     clk : IN BIT;
     ainit : IN BIT;
     sinit : IN BIT;
     ce : IN BIT
  );
END lib_fd1i_beh_bv_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1i_beh_bv_cordic_v1_1 IS
  SIGNAL ainit_int : BIT := '0';
  SIGNAL sinit_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  SIGNAL q_tmp : BIT := p_init;
BEGIN

  init_control : PROCESS(ainit,sinit,ce)
  BEGIN
    ainit_int <= '0';
    sinit_int <= '0';
    ce_int <= '1';
    IF (p_has_ainit = 1) THEN
      ainit_int <= ainit;
    END IF;
    IF (p_has_sinit = 1) THEN
      sinit_int <= sinit;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,ainit_int)
  BEGIN
    IF (ainit_int = '1') THEN
      q_tmp <= p_init;
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sinit_int = '1') THEN
        q_tmp <= p_init;
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_fd1i_beh_cordic_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_ainit : INTEGER := 0;
     p_has_sinit : INTEGER := 0;
     p_init : STD_LOGIC := '0'
  );
  PORT (
     d : IN STD_LOGIC;
     q : OUT STD_LOGIC;
     clk : IN STD_LOGIC;
     ainit : IN STD_LOGIC;
     sinit : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END lib_fd1i_beh_cordic_v1_1;

ARCHITECTURE virtex OF lib_fd1i_beh_cordic_v1_1 IS

  SIGNAL ainit_int : STD_LOGIC := '0';
  SIGNAL sinit_int : STD_LOGIC := '0';
  SIGNAL ce_int : STD_LOGIC := '1';
  SIGNAL q_tmp : STD_LOGIC := p_init;

BEGIN
	
  init_control : PROCESS(ainit,sinit,ce)
  BEGIN
    ainit_int <= '0';
    sinit_int <= '0';
    ce_int <= '1';
    IF (p_has_ainit = 1) THEN
      ainit_int <= ainit;
    END IF;
    IF (p_has_sinit = 1) THEN
      sinit_int <= sinit;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,ainit)
  BEGIN
    IF (ainit_int = '1') THEN
      q_tmp <= p_init;
    ELSIF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sinit_int = '1') THEN
      	q_tmp <= p_init;
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;

ENTITY lib_fifo_beh_bv_cordic_v1_1 IS
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN BIT_VECTOR(p_width-1 DOWNTO 0);
     q : OUT BIT_VECTOR(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fifo_beh_bv_cordic_v1_1;

ARCHITECTURE virtex OF lib_fifo_beh_bv_cordic_v1_1 IS

  TYPE reg_array IS ARRAY (0 TO p_depth) OF BIT_VECTOR(p_width-1 DOWNTO 0); 
  SIGNAL q_int : reg_array;
  
BEGIN

  q_int(0) <= d;

  gen_fifo_array : FOR I IN 0 TO p_depth-1 GENERATE
  	inst_fifo_slice_reg : lib_fd_beh_bv_cordic_v1_1
    GENERIC MAP(
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_width => p_width
    )
    PORT MAP(
      d => q_int(I),
      q => q_int(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );

  END GENERATE;
  
  q <= q_int(p_depth) AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;

ENTITY lib_fifo_beh_sb_cordic_v1_1 IS
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN SIGNED(p_width-1 DOWNTO 0);
     q : OUT SIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fifo_beh_sb_cordic_v1_1;

ARCHITECTURE virtex OF lib_fifo_beh_sb_cordic_v1_1 IS

  TYPE reg_array IS ARRAY (0 TO p_depth) OF SIGNED(p_width-1 DOWNTO 0); 
  SIGNAL q_int : reg_array;
  
BEGIN

  q_int(0) <= d;

  gen_fifo_array : FOR I IN 0 TO p_depth-1 GENERATE

  	inst_fifo_slice_reg : lib_fd_beh_sb_cordic_v1_1
    GENERIC MAP(
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_width => p_width
    )
    PORT MAP(
      d => q_int(I),
      q => q_int(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );

  END GENERATE;
  
  q <= q_int(p_depth) AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;

ENTITY lib_fifo_beh_ub_cordic_v1_1 IS
  GENERIC (
     p_depth : INTEGER := 2;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END lib_fifo_beh_ub_cordic_v1_1;

ARCHITECTURE virtex OF lib_fifo_beh_ub_cordic_v1_1 IS

  TYPE reg_array IS ARRAY (0 TO p_depth) OF UNSIGNED(p_width-1 DOWNTO 0); 
  SIGNAL q_int : reg_array;
  
BEGIN

  q_int(0) <= d;

  gen_fifo_array : FOR I IN 0 TO p_depth-1 GENERATE

  	inst_fifo_slice_reg : lib_fd_beh_ub_cordic_v1_1
    GENERIC MAP(
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_width => p_width
    )
    PORT MAP(
      d => q_int(I),
      q => q_int(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );

  END GENERATE;
  
  q <= q_int(p_depth) AFTER 1 ns;

END VIRTEX;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;

ENTITY lib_fifo_beh_cordic_v1_1 IS
  GENERIC (
     p_depth : INTEGER := 2;
     p_enable_rlocs :INTEGER := 1;
     p_has_ce : INTEGER := 0;
     p_has_aclr : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_width : INTEGER := 8
  );
  PORT (
     d : IN STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     q : OUT STD_LOGIC_VECTOR(p_width-1 DOWNTO 0);
     clk : IN STD_LOGIC;
     aclr : IN STD_LOGIC;
     sclr : IN STD_LOGIC;
     ce : IN STD_LOGIC
  );
END lib_fifo_beh_cordic_v1_1;

ARCHITECTURE behave OF lib_fifo_beh_cordic_v1_1 IS

  TYPE reg_array IS ARRAY (0 TO p_depth) OF STD_LOGIC_VECTOR(p_width-1 DOWNTO 0); 
  SIGNAL q_int : reg_array;
  
BEGIN

  q_int(0) <= d;

  gen_fifo_array : FOR I IN 0 TO p_depth-1 GENERATE

  	inst_fifo_slice_reg : lib_fd_beh_cordic_v1_1
    GENERIC MAP(
      p_enable_rlocs => p_enable_rlocs,
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_width => p_width
    )
    PORT MAP(
      d => q_int(I),
      q => q_int(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );

  END GENERATE;
  
  q <= q_int(p_depth);

END behave;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

ENTITY lib_ccm_mult_beh_cordic_v1_1 IS
  GENERIC (
    p_data_in_width : INTEGER := 8;
    p_data_type : INTEGER := 0;
    p_enable_rlocs : INTEGER := 1;
    p_b_value : STRING; 
    p_data_out_width : INTEGER := 8; 
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    a : IN STD_LOGIC_VECTOR(p_data_in_width-1 DOWNTO 0);
    q : OUT STD_LOGIC_VECTOR(p_data_out_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    rdy : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
END lib_ccm_mult_beh_cordic_v1_1;

ARCHITECTURE BEHAVE of lib_ccm_mult_beh_cordic_v1_1 is

BEGIN


END BEHAVE;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;

ENTITY lib_ccm_mult_beh_bv_cordic_v1_1 IS
  GENERIC (
    p_data_in_width : INTEGER := 8;
    p_data_type : INTEGER := 0;
    p_enable_rlocs : INTEGER := 1;
    p_b_value : STRING; 
    p_data_out_width : INTEGER := 8; 
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    a : IN BIT_VECTOR(p_data_in_width-1 DOWNTO 0);
    q : OUT BIT_VECTOR(p_data_out_width-1 DOWNTO 0);
    nd : IN BIT;
    rdy : OUT BIT;
    clk : IN BIT;
    ce : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT
  );
END lib_ccm_mult_beh_bv_cordic_v1_1;

ARCHITECTURE behave of lib_ccm_mult_beh_bv_cordic_v1_1 is

  SIGNAL a_sl : STD_LOGIC_VECTOR(p_data_in_width-1 DOWNTO 0);
  SIGNAL q_sl : STD_LOGIC_VECTOR(p_data_out_width-1 DOWNTO 0);
  SIGNAL nd_sl : STD_LOGIC;
  SIGNAL rdy_sl : STD_LOGIC;
  SIGNAL clk_sl : STD_LOGIC;
  SIGNAL aclr_sl : STD_LOGIC;
  SIGNAL sclr_sl : STD_LOGIC;
  SIGNAL ce_sl : STD_LOGIC;

BEGIN
	
  PROCESS(a, q_sl, nd, rdy_sl, clk, aclr, sclr, ce)
  BEGIN
    a_sl <= bv_to_sl(a);
    q <= sl_to_bv(q_sl);
    nd_sl <= b_to_sl(nd);
    rdy <= sl_to_b(rdy_sl);
    clk_sl <= b_to_sl(clk);
    aclr_sl <= b_to_sl(aclr);
    sclr_sl <= b_to_sl(sclr);
    ce_sl <= b_to_sl(ce);
  END PROCESS;

  inst_lib_ccm_mult_beh: lib_ccm_mult_beh_cordic_v1_1
  GENERIC MAP(
    p_data_in_width => p_data_in_width,
    p_data_type => p_data_type,
    p_enable_rlocs => p_enable_rlocs,
    p_b_value => p_b_value, 
    p_data_out_width => p_data_out_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_nd => p_has_nd,
    p_has_rdy => p_has_rdy,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    a => a_sl,
    q => q_sl,
    nd => nd_sl,
    rdy => rdy_sl,
    clk => clk_sl,
    ce => ce_sl,
    aclr => aclr_sl,
    sclr => sclr_sl
  );

END behave;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;

ENTITY cordic_cntr_reg_beh_ub_v1_1 IS
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_init : STRING := "";
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
END cordic_cntr_reg_beh_ub_v1_1;

ARCHITECTURE virtex OF cordic_cntr_reg_beh_ub_v1_1 IS
  SIGNAL ainit_int : BIT := '0';
  SIGNAL sinit_int : BIT := '0';
  SIGNAL ce_int : BIT := '1';
  CONSTANT p_init_bv : BIT_VECTOR(p_init'length-1 DOWNTO 0) := str_to_bv(p_init);
  CONSTANT p_init_ub : UNSIGNED(p_init'length-1 DOWNTO 0) := UNSIGNED(str_to_bv(p_init));
  signal test_init_ub : UNSIGNED(p_init'length-1 DOWNTO 0);   
  signal test_init_str : STRING(p_init'length DOWNTO 1);   
  signal test_init_bv : BIT_VECTOR(p_init'length-1 DOWNTO 0);
  SIGNAL q_tmp : UNSIGNED(p_width-1 DOWNTO 0) := p_init_ub;

BEGIN

  test_init_ub <= UNSIGNED(str_to_bv(p_init));
  test_init_str <= p_init;
  test_init_bv <= p_init_bv;
     
  init_control : PROCESS(aclr,sclr,ce)
  BEGIN
    ainit_int <= '0';
    sinit_int <= '0';
    ce_int <= '1';
    IF (p_has_aclr = 1) THEN
      ainit_int <= aclr;
    END IF;
    IF (p_has_sclr = 1) THEN
      sinit_int <= sclr;
    END IF;
    IF (p_has_ce = 1) THEN
      ce_int <= ce;
    END IF;
  END PROCESS;

  register_block : PROCESS(clk,aclr)
  BEGIN
    IF (ainit_int = '1') THEN
      q_tmp <= p_init_ub;
    END IF;
    IF (clk'event AND clk = '1') THEN
      IF (ce_int = '1') THEN
        q_tmp <= d;
      END IF;
      IF (sinit_int = '1') THEN
      	q_tmp <= p_init_ub;
      END IF;
    END IF;
  END PROCESS;

  q <= q_tmp AFTER 1 ns;

END VIRTEX;

LIBRARY std;
USE std.textio.ALL;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;

PACKAGE cordic_eng_comps_beh_v1_1 IS

  COMPONENT cordic_eng_beh_bv_v1_1
  GENERIC (
	p_architecture : INTEGER := c_wser_arch;--Determines Engine Architecture
    p_cordic_funct : INTEGER := c_f_default;
    p_ctrl_width : INTEGER := 2; --Number of bits of control logic stored by engine
    p_data_extend : INTEGER := 5; -- Number of extra bits carried in addition.
    p_data_width : INTEGER := 32; -- Determines Data Path Width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_replications : INTEGER := 1; --Level of internal replication to increase throughput
    p_round_mode : INTEGER := c_round_pos_neg_inf; -- Determines rounding mode.
    p_scale_comp : INTEGER := c_scale_none -- Determines rounding mode.
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width - 1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width - 1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_eng_beh_v1_1
  GENERIC (
    p_architecture : INTEGER := c_wser_arch;--Determines Engine Architecture
    p_cordic_funct : INTEGER := c_f_default;
    p_ctrl_width : INTEGER := 4; --Number of bits of control logic stored by engine
    p_data_extend : INTEGER := 5; -- Number of extra bits carried in addition.
    p_data_width : INTEGER := 32; -- Determines Data Path Width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_replications : INTEGER := 1; --Level of internal replication to increase throughput
    p_round_mode : INTEGER := c_round_pos_neg_inf; -- Determines rounding mode.
    p_scale_comp : INTEGER := c_scale_none -- Determines rounding mode.
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
  END COMPONENT;
  
  COMPONENT cordic_eng_slice_wser_beh_bv_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4;
    p_data_extend : integer := 5;
    p_data_width_int : integer := 32+5;
    p_enable_rlocs : integer := 1;
    p_hardwired_shift : integer := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : integer := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : integer := c_format_rad;
    p_rep_count : integer := 4;
    p_slice_width : integer := 8
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width_int - 1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width_int - 1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_eng_slice_wser_beh_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4;
    p_data_extend : INTEGER := 5;
    p_data_width_int : INTEGER := 32+5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad;
    p_rep_count : INTEGER := 4;
    p_slice_width : INTEGER := 8
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
  END COMPONENT;

  COMPONENT cordic_eng_slice_par_beh_bv_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4; --Number of bits of control logic stored by engine
    p_data_width_int : INTEGER := 32+5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width_int- 1 DOWNTO 0);
    add_nsub_gen_in : IN BIT_VECTOR(1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width_int - 1 DOWNTO 0);
    add_nsub_gen_out : OUT BIT_VECTOR(1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_eng_slice_par_beh_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4; --Number of bits of control logic stored by engine
    p_data_width_int : INTEGER := 32+5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0) := (OTHERS => 'Z');
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0) := (OTHERS => 'Z');
    phase_in : IN STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0) := (OTHERS => 'Z');
    add_nsub_gen_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0) := (OTHERS => 'Z');
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    add_nsub_gen_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0) := (OTHERS => 'Z');
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0';
    ce : IN STD_LOGIC := '1'
  );
  END COMPONENT;

  COMPONENT cordic_cntr_reg_beh_ub_v1_1
  GENERIC (
     p_enable_rlocs :INTEGER := 1;
     p_has_aclr : INTEGER := 0;
     p_has_ce : INTEGER := 0;
     p_has_sclr : INTEGER := 0;
     p_init : STRING := "";
     p_width : INTEGER := 8
  );
  PORT (
     d : IN UNSIGNED(p_width-1 DOWNTO 0);
     q : OUT UNSIGNED(p_width-1 DOWNTO 0);
     clk : IN BIT;
     aclr : IN BIT;
     sclr : IN BIT;
     ce : IN BIT
  );
  END COMPONENT;  
  
  
END cordic_eng_comps_beh_v1_1;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_slice_par_beh_bv_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4; --Number of bits of control logic stored by engine
    p_data_width_int : INTEGER := 32+5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width_int- 1 DOWNTO 0);
    add_nsub_gen_in : IN BIT_VECTOR(1 DOWNTO 0) := (OTHERS => '0');
    data_x_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width_int - 1 DOWNTO 0);
    add_nsub_gen_out : OUT BIT_VECTOR(1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_eng_slice_par_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_eng_slice_par_beh_bv_v1_1 IS

  SIGNAL data_x_hw_shift : SIGNED(p_data_width_int-1 DOWNTO 0); 
  SIGNAL data_x_add : SIGNED(p_data_width_int-1 DOWNTO 0); 
  SIGNAL data_x_tmp : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_hw_shift : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_add : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_tmp : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL phase_add : SIGNED(p_data_width_int - 1 DOWNTO 0);
  SIGNAL phase_tmp : SIGNED(p_data_width_int-1 DOWNTO 0);

  SIGNAL phase_add_t0 : SIGNED(p_data_width_int - 1 DOWNTO 0);
  SIGNAL phase_add_t1 : SIGNED(p_data_width_int - 1 DOWNTO 0);
  
  SIGNAL ctrl_vect_int : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL nd_and_ce : BIT;
 
  SIGNAL add_nsub_x_int : BIT;
  SIGNAL add_nsub_y_int : BIT;
  SIGNAL add_nsub_p_int : BIT;

  SIGNAL add_nsub_gen_int : BIT_VECTOR(1 DOWNTO 0);
  
  FUNCTION f_pad_shift(data_in:SIGNED;p_width:INTEGER;p_shift:INTEGER)RETURN SIGNED IS
    VARIABLE data_shift_int : SIGNED(p_data_width_int-1 DOWNTO 0); 
  BEGIN
    data_shift_int((p_width-1) DOWNTO (p_width - p_shift))
      := (others => data_in(p_width-1));
    data_shift_int((p_width-p_shift-1) DOWNTO 0 )
      := data_in((p_width-1) DOWNTO p_shift);
    RETURN data_shift_int;  
  END f_pad_shift;
  
  FUNCTION f_engine_mode(cordic_funct : INTEGER)RETURN INTEGER IS
    VARIABLE engine_mode_v : INTEGER;
  BEGIN
    engine_mode_v := 0;
    IF ((cordic_funct = c_f_rotate) OR (cordic_funct = c_f_sin_cos) OR (cordic_funct = c_f_sinh_cosh)) THEN
      engine_mode_v := 0;
  	END IF; 
    IF ((cordic_funct = c_f_translate) OR (cordic_funct = c_f_atan) OR (cordic_funct = c_f_atanh)) THEN
      engine_mode_v := 1;
  	END IF; 
    RETURN engine_mode_v; 
  END f_engine_mode;
  CONSTANT c_engine_mode : INTEGER := f_engine_mode(p_cordic_funct); 

  FUNCTION f_transform_type(cordic_funct : INTEGER)RETURN INTEGER IS
    VARIABLE transform_type_v : INTEGER;
  BEGIN
    transform_type_v := 0;
  	IF ((cordic_funct = c_f_sinh_cosh) OR (cordic_funct = c_f_atanh)) THEN
      transform_type_v := 1;
  	END IF; RETURN transform_type_v; 
  END f_transform_type;
  CONSTANT c_transform_type : INTEGER := f_transform_type(p_cordic_funct); 
  
  FUNCTION f_rom_data_int(transform_type : INTEGER)RETURN SIGNED IS
    VARIABLE rom_data_tmp : STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
  BEGIN
    rom_data_tmp := c_atan_rads((p_iteration+1)*c_max_rom_width-1 DOWNTO (p_iteration+1)*c_max_rom_width-p_data_width_int);
  	IF (transform_type = 0) AND (p_phase_format = c_format_sca) THEN
      rom_data_tmp := c_atan_jrads((p_iteration+1)*c_max_rom_width-1 DOWNTO (p_iteration+1)*c_max_rom_width-p_data_width_int);
    ELSIF (transform_type = 1) AND (p_phase_format = c_format_rad) THEN
      rom_data_tmp := c_atanh_rads((p_iteration+1)*c_max_rom_width-1 DOWNTO (p_iteration+1)*c_max_rom_width-p_data_width_int);
    ELSIF (transform_type = 1) AND (p_phase_format = c_format_sca) THEN
      rom_data_tmp := c_atanh_jrads((p_iteration+1)*c_max_rom_width-1 DOWNTO (p_iteration+1)*c_max_rom_width-p_data_width_int);
  	END IF;
    RETURN SIGNED(sl_to_bv(rom_data_tmp));
  END;
  CONSTANT c_rom_data_int :SIGNED(p_data_width_int-1 DOWNTO 0) := f_rom_data_int(c_transform_type); 
  SIGNAL s_rom_data_int :SIGNED(p_data_width_int-1 DOWNTO 0) := c_rom_data_int;
	
BEGIN

  --Pad the input and implement the hardware shift
  data_x_hw_shift <= f_pad_shift(data_x_in,p_data_width_int,p_hardwired_shift+1);
  data_y_hw_shift <= f_pad_shift(data_y_in,p_data_width_int,p_hardwired_shift+1);

  --Process to generate data_x_add
  gen_data_x_add : PROCESS(add_nsub_x_int,data_x_in,data_y_hw_shift)
  BEGIN
    IF (add_nsub_x_int = '1') THEN
      data_x_add <= data_x_in(p_data_width_int - 1 downto 0) + data_y_hw_shift(p_data_width_int-1 downto 0);
    END IF;
    IF (add_nsub_x_int = '0') THEN
      data_x_add <= data_x_in(p_data_width_int - 1 downto 0) - data_y_hw_shift(p_data_width_int-1 downto 0);
    END IF;
  END PROCESS;
  --Process to generate data_y_add
  gen_data_y_add : PROCESS(add_nsub_y_int,data_x_hw_shift,data_y_in)
  BEGIN
    IF (add_nsub_y_int = '1') THEN
      data_y_add <= data_y_in(p_data_width_int - 1 downto 0) + data_x_hw_shift(p_data_width_int-1 downto 0);
    END IF;
    IF (add_nsub_y_int = '0') THEN
      data_y_add <= data_y_in(p_data_width_int - 1 downto 0) - data_x_hw_shift(p_data_width_int-1 downto 0);  	
    END IF;
  END PROCESS;

  inst_data_x_int : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_add,
    q => data_x_tmp,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_y_int : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_add,
    q => data_y_tmp,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_phase_add : PROCESS(add_nsub_p_int,phase_in)
  BEGIN
    IF (add_nsub_p_int = '1') THEN
      phase_add <= phase_in + c_rom_data_int;
    ELSE
      phase_add <= phase_in - c_rom_data_int;
    END IF;
  END PROCESS;
  
  phase_add_t0 <= phase_in;
  phase_add_t1 <= c_rom_data_int;

  inst_phase_fb :lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_add,
    q => phase_tmp,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  gen_add_nsub : PROCESS(add_nsub_gen_in)
    VARIABLE add_nsub_x_v : BIT;
    VARIABLE add_nsub_y_v : BIT;
    VARIABLE add_nsub_p_v : BIT;
  BEGIN
    add_nsub_y_v := '0';
    add_nsub_p_v := '1';
    IF ( (c_engine_mode=1 AND add_nsub_gen_in(0)='1') OR
         (c_engine_mode=0 AND add_nsub_gen_in(1)='0')    ) THEN
      add_nsub_y_v := '1';
      add_nsub_p_v := '0';
    END IF;
    add_nsub_x_v:= add_nsub_p_v;
    IF (c_transform_type = 1) THEN
      add_nsub_x_v:= add_nsub_y_v;
    END IF;

    add_nsub_x_int <= add_nsub_x_v;
    add_nsub_y_int <= add_nsub_y_v;
    add_nsub_p_int <= add_nsub_p_v;
   
  END PROCESS;

  --Timing Control
  inst_ctrl_vect_0 : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => ctrl_vect_in(0),
    q => ctrl_vect_int(0),
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  ctrl_vect_int(1) <= ctrl_vect_in(1);

  PROCESS(ctrl_vect_int,ce)
  BEGIN
    nd_and_ce <= '0';
    IF (ctrl_vect_int(0) = '1' AND ce = '1') THEN
      nd_and_ce <= '1';
    END IF;
  END PROCESS;

  inst_ctrl_vect_3_2 : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr,
    p_width => 2
  )
  PORT MAP(
    d => ctrl_vect_in(3 DOWNTO 2),
    q => ctrl_vect_int(3 DOWNTO 2),
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => nd_and_ce
  );
  
  add_nsub_gen_int(0) <= data_y_tmp(p_data_width_int-1);
  add_nsub_gen_int(1) <= phase_tmp(p_data_width_int-1);
    
  data_x_out <= data_x_tmp AFTER 1 ns;
  data_y_out <= data_y_tmp AFTER 1 ns;
  phase_out <= phase_tmp AFTER 1 ns;
  ctrl_vect_out <= ctrl_vect_int AFTER 1 ns;
  add_nsub_gen_out <= add_nsub_gen_int AFTER 1 ns;
  
  
END behav;

--************************************************--

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_slice_par_beh_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4;
    p_data_width_int : INTEGER := 32+5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0) := (OTHERS => 'Z');
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0) := (OTHERS => 'Z');
    phase_in : IN STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0) := (OTHERS => 'Z');
    add_nsub_gen_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0) := (OTHERS => 'Z');
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    add_nsub_gen_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0) := (OTHERS => 'Z');
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0';
    ce : IN STD_LOGIC := '1'
  );
END cordic_eng_slice_par_beh_v1_1;


ARCHITECTURE behav OF cordic_eng_slice_par_beh_v1_1 IS

  SIGNAL engine_mode_bv : BIT;
  SIGNAL data_x_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL phase_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL add_nsub_gen_in_bv : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL data_x_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL phase_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL add_nsub_gen_out_bv : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL ctrl_vect_in_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_out_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
     
BEGIN

  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,
          phase_in,phase_out_bv,ctrl_vect_in,ctrl_vect_out_bv,
          add_nsub_gen_in,add_nsub_gen_out_bv,clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    add_nsub_gen_in_bv <= sl_to_bv(add_nsub_gen_in);
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
    ctrl_vect_out <= bv_to_sl(ctrl_vect_out_bv);
    add_nsub_gen_out <= bv_to_sl(add_nsub_gen_out_bv);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);	
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
  END PROCESS;

  inst_cordic_eng_slice_par_beh_bv_v1_1: cordic_eng_slice_par_beh_bv_v1_1
  GENERIC MAP(
    p_cordic_funct => p_cordic_funct,
    p_ctrl_width => p_ctrl_width,
    p_data_width_int => p_data_width_int,
    p_enable_rlocs => p_enable_rlocs,
    p_hardwired_shift => p_hardwired_shift,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_iteration => p_iteration,
    p_phase_format => p_phase_format
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    phase_in => phase_in_bv,
    add_nsub_gen_in => add_nsub_gen_in_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv, 
    phase_out => phase_out_bv,
    add_nsub_gen_out => add_nsub_gen_out_bv, 
    ctrl_vect_in => ctrl_vect_in_bv,
    ctrl_vect_out => ctrl_vect_out_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );

END;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_slice_wser_beh_bv_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4;
    p_data_width_int : integer := 32+5;
    p_data_extend : integer := 5;
    p_enable_rlocs : integer := 1;
    p_hardwired_shift : integer := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : integer := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : integer := c_format_rad;
    p_rep_count : integer := 4;
    p_slice_width : integer := 8
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width_int - 1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width_int - 1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_eng_slice_wser_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_eng_slice_wser_beh_bv_v1_1 IS

  FUNCTION f_slice_depth RETURN INTEGER IS
    VARIABLE f_slice_tmp : INTEGER;
  BEGIN 
    f_slice_tmp := p_slice_width;
    IF (p_iteration = p_rep_count) THEN
      f_slice_tmp := p_data_width_int - p_data_extend - (p_rep_count * p_slice_width); 
    END	IF;
    RETURN f_slice_tmp;
  END f_slice_depth;
  CONSTANT c_slice_depth : INTEGER := f_slice_depth;

  FUNCTION f_slice_addr RETURN INTEGER IS
    VARIABLE f_slice_addr_tmp : INTEGER;
    VARIABLE f_slice_addr_cnt : INTEGER;
  BEGIN
  	f_slice_addr_tmp := 1;
    f_slice_addr_cnt := 2;
    WHILE (f_slice_addr_cnt < p_slice_width) LOOP
      f_slice_addr_tmp := f_slice_addr_tmp + 1;
      f_slice_addr_cnt := f_slice_addr_cnt + f_slice_addr_cnt;
    END LOOP;
    RETURN f_slice_addr_tmp;  
  END f_slice_addr;    
  CONSTANT c_slice_addr :INTEGER := f_slice_addr; 

  FUNCTION f_rom_depth RETURN INTEGER IS
	VARIABLE v_rom_depth : INTEGER;
  BEGIN
  	v_rom_depth := 16;
    WHILE (v_rom_depth < c_slice_depth) LOOP
      v_rom_depth := v_rom_depth + 16;	
    END LOOP;
    RETURN v_rom_depth;
  END f_rom_depth;
  CONSTANT c_rom_depth : INTEGER := f_rom_depth;

  FUNCTION f_rom_addr_width RETURN INTEGER IS
	VARIABLE v_rom_depth : INTEGER;
	VARIABLE v_rom_addr : INTEGER;
  BEGIN
  	v_rom_depth := 16;
  	v_rom_addr := 4;
    WHILE (v_rom_depth < c_slice_depth) LOOP
      v_rom_depth := v_rom_depth + v_rom_depth;
      v_rom_addr := v_rom_addr +1;	
    END LOOP;
    RETURN v_rom_addr;
  END f_rom_addr_width;
  CONSTANT c_rom_addr_width : INTEGER := f_rom_addr_width;

  FUNCTION f_pad_var_shift(data_in:SIGNED;p_var_shift:INTEGER;
                           p_fixed_shift:INTEGER)RETURN SIGNED IS
    VARIABLE data_shift_int : SIGNED(data_in'length-1 DOWNTO 0); 
  BEGIN
    FOR I IN data_in'length-1 DOWNTO 0 LOOP
      data_shift_int(I) := data_in(data_in'high);
    END LOOP;
    FOR I IN (data_in'length-1-p_var_shift-p_fixed_shift) DOWNTO 0 LOOP
      data_shift_int(I) :=	data_in(data_in'low+p_var_shift+p_fixed_shift+I);
    END LOOP;
    RETURN data_shift_int;  
  END f_pad_var_shift;

  SIGNAL aclr_int : BIT := '0';
  SIGNAL ce_int : BIT := '0';
  SIGNAL sclr_int : BIT := '0';

  SIGNAL rom_data_int : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL rom_data_async : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL add_nsub_x_int : BIT;
  SIGNAL add_nsub_y_int : BIT;
  SIGNAL add_nsub_p_int : BIT;
  SIGNAL rom_addr_int : UNSIGNED(c_rom_addr_width-1 DOWNTO 0);

  -- CTRL Signals
  SIGNAL data_y_in_current : BIT;
  SIGNAL data_y_in_last : BIT;
  SIGNAL phase_in_current : BIT;
  SIGNAL phase_in_last : BIT;

  SIGNAL nd_next : BIT; 
  SIGNAL nd_fb : BIT;
  SIGNAL nd_int : BIT;

  SIGNAL ctrl_vect_int : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL nd_and_ce : BIT;
  
  SIGNAL cnt : UNSIGNED (c_slice_addr DOWNTO 0);
  SIGNAL cnt_next: UNSIGNED(c_slice_addr DOWNTO 0);
  SIGNAL cnt_sclr: UNSIGNED(c_slice_addr DOWNTO 0);
  SIGNAL cnt_rep_next : BIT; 
  SIGNAL cnt_rep_int : BIT; 
  SIGNAL cnt_rep : BIT;
 
  SIGNAL cnt_sclr_int : BIT;
  SIGNAL cnt_ce_int : BIT;

  SIGNAL rfd_next : BIT; 
  SIGNAL rfd_tmp : BIT; 
  SIGNAL rfd_int : BIT; 

  SIGNAL rdy_pre : BIT;
  SIGNAL rdy_int : BIT;
  SIGNAL rdy_tmp : BIT; 
  
  SIGNAL shift_var_int : UNSIGNED (c_slice_addr-1 DOWNTO 0);

  CONSTANT c_tc_vector : UNSIGNED(c_slice_addr downto 0) := 
         UNSIGNED(nat_to_bv(c_slice_depth-1, c_slice_addr+1));
  CONSTANT c_init_vector : UNSIGNED(c_slice_addr downto 0) := 
         (OTHERS => '1');

  -- DATA ACCUM Signals
  SIGNAL data_x_mux : SIGNED(p_data_width_int -1 downto 0);
  SIGNAL data_x_hw_shift : SIGNED(p_data_width_int-1 downto 0); 
  SIGNAL data_x_add : SIGNED(p_data_width_int-1 downto 0); 
  SIGNAL data_x_fb : SIGNED(p_data_width_int-1 downto 0);
  SIGNAL data_y_mux : SIGNED(p_data_width_int-1 downto 0);
  SIGNAL data_y_hw_shift : SIGNED(p_data_width_int-1 downto 0);
  SIGNAL data_y_add : SIGNED(p_data_width_int-1 downto 0); 
  SIGNAL data_y_fb : SIGNED(p_data_width_int-1 downto 0);

  --PHASE ACCUM SIGNALS
  SIGNAL phase_mux : SIGNED(p_data_width_int - 1 DOWNTO 0);
  SIGNAL phase_add : SIGNED(p_data_width_int - 1 DOWNTO 0);
  SIGNAL phase_fb : SIGNED(p_data_width_int - 1 DOWNTO 0);

  --ROM Signals
  SIGNAL rom_addr_start : INTEGER := c_max_rom_width;

  CONSTANT pinit_bv_const : BIT_VECTOR(c_slice_addr DOWNTO 0) :=
         nat_to_bv(c_slice_depth-1,c_slice_addr+1);
  CONSTANT pinit_str_const : STRING(1 to c_slice_addr+1) :=
         bv_to_str(pinit_bv_const);

  SIGNAL zero_sl : BIT := '0';
  
  FUNCTION f_engine_mode(cordic_funct : INTEGER)RETURN INTEGER IS
    VARIABLE engine_mode_v : INTEGER;
  BEGIN
    engine_mode_v := 0;
    IF ((cordic_funct = c_f_rotate) OR (cordic_funct = c_f_sin_cos) OR (cordic_funct = c_f_sinh_cosh)) THEN
      engine_mode_v := 0;
  	END IF; 
    IF ((cordic_funct = c_f_translate) OR (cordic_funct = c_f_atan) OR (cordic_funct = c_f_atanh)) THEN
      engine_mode_v := 1;
  	END IF; 
    RETURN engine_mode_v; 
  END f_engine_mode;
  CONSTANT c_engine_mode : INTEGER := f_engine_mode(p_cordic_funct); 

  FUNCTION f_transform_type(cordic_funct : INTEGER)RETURN INTEGER IS
    VARIABLE transform_type_v : INTEGER;
  BEGIN
    transform_type_v := 0;
  	IF ((cordic_funct = c_f_sinh_cosh) OR (cordic_funct = c_f_atanh)) THEN
      transform_type_v := 1;
  	END IF; RETURN transform_type_v; 
  END f_transform_type;
  CONSTANT c_transform_type : INTEGER := f_transform_type(p_cordic_funct); 
	
BEGIN
    
--  test_pinit_str_const <=  pinit_str_const;
  aclr_int <= aclr WHEN p_has_aclr = 1 ELSE '0';
  ce_int <= ce WHEN p_has_ce = 1 ELSE '1';
  sclr_int <= sclr WHEN p_has_sclr = 1 ELSE '0';

  data_y_in_current <= data_y_fb(p_data_width_int-1);
  data_y_in_last <= data_y_in(p_data_width_int-1);
  phase_in_current <= phase_fb(p_data_width_int-1);
  phase_in_last <= phase_in(p_data_width_int-1);

  gen_add_nsub : PROCESS(data_y_in_last,phase_in_last,data_y_in_current,phase_in_current,nd_int)
    VARIABLE data_y_sign : BIT;
    VARIABLE phase_sign : BIT;     
    VARIABLE add_nsub_x_v : BIT;
    VARIABLE add_nsub_y_v : BIT;
    VARIABLE add_nsub_p_v : BIT;
  BEGIN
    --Mux Phase and Data with Load Signal
    data_y_sign := data_y_in_current;
    phase_sign := phase_in_current;
    IF nd_int = '1' THEN
      data_y_sign := data_y_in_last;
      phase_sign := phase_in_last;    	
    END IF;
    
    add_nsub_y_v := '0';
    add_nsub_p_v := '1';
    IF ( (c_engine_mode=1 AND data_y_sign='1') OR
         (c_engine_mode=0 AND phase_sign='0')    ) THEN
      add_nsub_y_v := '1';
      add_nsub_p_v := '0';
    END IF;
    add_nsub_x_v:= add_nsub_p_v;
    IF (c_transform_type = 1) THEN
      add_nsub_x_v:= add_nsub_y_v;
    END IF;

    add_nsub_x_int <= add_nsub_x_v;
    add_nsub_y_int <= add_nsub_y_v;
    add_nsub_p_int <= add_nsub_p_v;
   
  END PROCESS;
    
  --Delay the New Data Signal.
  nd_next <= ctrl_vect_in(0);
  
  gen_nd_fb : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_next,
    q => nd_fb,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_nd_int : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_fb,
    q => nd_int,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  PROCESS(nd_next, rfd_tmp, rdy_pre)
  BEGIN
    rfd_next <= '0';
    IF ((nd_next = '0' AND rfd_tmp = '1') OR (rdy_pre = '1')) THEN
      rfd_next <= '1';
    END IF;
  END PROCESS;  

  gen_rfd_tmp : lib_fd1i_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ainit => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sinit => p_has_sclr,
    p_init => '1'
  )
  PORT MAP(
    d => rfd_next,
    q => rfd_tmp,
    clk => clk,
    ainit => aclr,
    sinit => sclr,
    ce => ce
  );
  
  cnt_ce_int  <= '1' WHEN ((cnt(c_slice_addr)='0') AND (cnt_rep_int='0') AND (ce_int='1')) ELSE '0';  
  cnt_sclr_int  <= '1' WHEN (((nd_next='1') AND (ce_int='1')) OR (sclr_int='1')) ELSE '0';  

  gen_cnt_next : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
        cnt_next <= (OTHERS => '0');
    ELSIF (CLK'EVENT AND CLK = '1') THEN
      IF (cnt_sclr_int = '1') THEN
        cnt_next <= (OTHERS => '0');
      ELSIF (cnt_ce_int = '1') THEN
        cnt_next <= cnt_next + 1;
      END IF;
    END IF;
  END PROCESS;
  
  gen_rdy_pre : PROCESS(cnt,cnt_rep)
  BEGIN
    rdy_pre <= '0';
    IF (c_transform_type=0) THEN
      IF cnt = c_tc_vector-2 THEN
        rdy_pre <= '1';
      END IF;
    ELSE -- c_transform_type=1
      IF ((c_slice_depth /= 13)AND(c_slice_depth /= 15) AND (cnt = c_tc_vector-2)) THEN
        rdy_pre <= '1';
      END IF;
      IF ((c_slice_depth = 13) AND (cnt = c_tc_vector-1)) THEN
        rdy_pre <= '1';
      END IF;
      IF ((c_slice_depth = 15) AND (cnt = c_tc_vector-2) AND (cnt_rep = '0')) THEN
        rdy_pre <= '1';
      END IF;
    END IF;
  END PROCESS;

  gen_cnt_rep_next : PROCESS(cnt_next)
  BEGIN
    cnt_rep_next <= '0';
    IF (c_transform_type=1) THEN
      IF ((cnt_next = 4-2) OR (cnt_next = 13-2)) THEN
        cnt_rep_next <= '1';
      END IF;
    END IF;
  END PROCESS;

  inst_cnt_rep_int : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => 1
  )
  PORT MAP(
    d => cnt_rep_next,
    q => cnt_rep_int,
    clk => clk,
    aclr => aclr_int,
    sclr => cnt_sclr_int,
    ce => ce_int
  );

  inst_cnt_rep : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => 1
  )
  PORT MAP(
    d => cnt_rep_int,
    q => cnt_rep,
    clk => clk,
    aclr => aclr_int,
    sclr => cnt_sclr_int,
    ce => ce_int
  );
  
  gen_cnt_reg : PROCESS(clk,aclr_int)
  BEGIN
    IF (aclr_int = '1') THEN
      cnt <= c_tc_vector;
    ELSIF (CLK'EVENT AND CLK = '1') THEN
      IF (cnt_sclr_int = '1') THEN
        cnt <= c_tc_vector;
      ELSIF (ce_int = '1') THEN
        cnt <= cnt_next;
      END IF;
    END IF;
  END PROCESS;

  gen_rom_addr_shift_var : PROCESS(cnt)
  BEGIN
    rom_addr_int <= (OTHERS => '0');
    shift_var_int <= (OTHERS => '0');
    rom_addr_int(c_slice_addr-1 DOWNTO 0) <= cnt(c_slice_addr-1 DOWNTO 0);
    shift_var_int(c_slice_addr-1 DOWNTO 0) <= cnt(c_slice_addr-1 DOWNTO 0);
  END PROCESS;

  PROCESS(rdy_pre, rdy_tmp, rfd_tmp)
  BEGIN
    rdy_int <= '0';
    IF (rdy_pre = '1' AND rdy_tmp = '0' AND rfd_tmp = '0') THEN
      rdy_int <= '1';
    END IF;
  END PROCESS;  

  inst_rdy_tmp : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => rdy_int,
    q => rdy_tmp,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  ctrl_vect_int(0) <= rdy_tmp;
  ctrl_vect_int(1) <= ctrl_vect_in(1);

  PROCESS(nd_int, ce)
  BEGIN
    nd_and_ce <= '0';
    IF (nd_int = '1' AND ce = '1') THEN
      nd_and_ce <= '1';
    END IF;
  END PROCESS;  

  inst_ctrl_vect_3_2 : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr,
    p_width => 2
  )
  PORT MAP(
    d => ctrl_vect_in(3 DOWNTO 2),
    q => ctrl_vect_int(3 DOWNTO 2),
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => nd_and_ce
  );
    
  -- C_ACC_SLICE  
  mux_data_in : PROCESS(data_x_fb,data_x_in,nd_int,
                        data_y_fb,data_y_in,phase_fb,phase_in)
  BEGIN
    data_x_mux <= data_x_fb;
    data_y_mux <= data_y_fb;
    phase_mux <= phase_fb;
    IF (nd_int = '1') THEN
      data_x_mux <= data_x_in;
      data_y_mux <= data_y_in;
      phase_mux <= phase_in;
    END IF;
  END PROCESS;
  
    --Pad the input and implement variable shift and the hardware shift
  data_x_hw_shift <= f_pad_var_shift(data_x_mux,bv_to_nat(BIT_VECTOR(shift_var_int)),p_hardwired_shift+1);
  data_y_hw_shift <= f_pad_var_shift(data_y_mux,bv_to_nat(BIT_VECTOR(shift_var_int)),p_hardwired_shift+1);
  
  --Conditional Assignments of data_x_add, data_y_add and phase_add
  data_x_add <= data_x_mux + data_y_hw_shift when (add_nsub_x_int = '1') else
                data_x_mux - data_y_hw_shift;
  data_y_add <= data_y_mux + data_x_hw_shift when (add_nsub_y_int = '1') else
                data_y_mux - data_x_hw_shift;
  phase_add <= phase_mux + rom_data_int when (add_nsub_p_int = '1') else
                phase_mux - rom_data_int;

  inst_data_x_fb : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_add,
    q => data_x_fb,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_y_fb : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_add,
    q => data_y_fb,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  inst_phase_fb : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width_int,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_add,
    q => phase_fb,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  -- C ROM SLICE
--  inst_rom : lib_fd_beh_sb_cordic_v1_1
--  GENERIC MAP(
--    p_width => p_data_width_int,
--    p_has_aclr => p_has_aclr,
--    p_has_ce => p_has_ce,
--    p_has_sclr => p_has_sclr
--  )
--  PORT MAP(
--    d => rom_data_async,
--    q => rom_data_int,
--    clk => clk,
--    aclr => aclr,
--    sclr => sclr,
--    ce => ce
--  );
  rom_data_int <= rom_data_async;

    
  gen_rom_addr_start : PROCESS(rom_addr_int)
  BEGIN
    rom_addr_start <= c_max_rom_width * (bv_to_nat(BIT_VECTOR(rom_addr_int)) + 
                                         c_slice_depth*p_iteration + 1);
  END PROCESS;
  
  gen_rom_data_int : PROCESS(rom_addr_start)
  BEGIN
  	IF (p_phase_format = c_format_rad) THEN
      IF ((p_cordic_funct = c_f_sinh_cosh) OR (p_cordic_funct = c_f_atanh)) THEN
        rom_data_async <= SIGNED(sl_to_bv(c_atanh_rads(rom_addr_start-1 DOWNTO (rom_addr_start-p_data_width_int))));
      ELSE
        rom_data_async <= SIGNED(sl_to_bv(c_atan_rads(rom_addr_start-1 DOWNTO (rom_addr_start-p_data_width_int))));
      END IF;
    ELSE
      IF ((p_cordic_funct = c_f_sinh_cosh) OR (p_cordic_funct = c_f_atanh)) THEN
        rom_data_async <= SIGNED(sl_to_bv(c_atanh_jrads(rom_addr_start-1 DOWNTO (rom_addr_start-p_data_width_int))));
      ELSE
        rom_data_async <= SIGNED(sl_to_bv(c_atan_jrads(rom_addr_start-1 DOWNTO (rom_addr_start-p_data_width_int))));
      END IF;
    END IF;
  END PROCESS;

  data_x_out <= data_x_fb AFTER 1 ns;
  data_y_out <= data_y_fb AFTER 1 ns;
  phase_out <= phase_fb AFTER 1 ns;
  ctrl_vect_out <= ctrl_vect_int AFTER 1 ns;
  
END behav;
	
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_slice_wser_beh_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_ctrl_width : INTEGER := 4;
    p_data_width_int : INTEGER := 32+5;
    p_data_extend : INTEGER := 5;
    p_enable_rlocs : INTEGER := 1;
    p_hardwired_shift : INTEGER := 0;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_iteration : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad;
    p_rep_count : INTEGER := 4;
    p_slice_width : INTEGER := 8
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width_int-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width_int - 1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_eng_slice_wser_beh_v1_1;

ARCHITECTURE behav OF cordic_eng_slice_wser_beh_v1_1 IS

  SIGNAL data_x_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL phase_in_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_x_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL phase_out_bv : SIGNED(p_data_width_int-1 DOWNTO 0);
  SIGNAL ctrl_vect_in_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_out_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
  
BEGIN
  
  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,
          phase_in,phase_out_bv,ctrl_vect_in,ctrl_vect_out_bv,
          clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
    ctrl_vect_in_bv <= sl_to_bv(ctrl_vect_in);
    ctrl_vect_out <= bv_to_sl(ctrl_vect_out_bv);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);	
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
  END PROCESS;

  inst_cordic_eng_slice_wser_beh_bv_v1_1: cordic_eng_slice_wser_beh_bv_v1_1
  GENERIC MAP(
    p_cordic_funct => p_cordic_funct,
    p_ctrl_width => p_ctrl_width,
    p_data_width_int => p_data_width_int,
    p_data_extend => p_data_extend,
    p_enable_rlocs => p_enable_rlocs,
    p_hardwired_shift => p_hardwired_shift,
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr,
    p_iteration => p_iteration,
    p_mif_file_prefix => p_mif_file_prefix,
    p_phase_format => p_phase_format,
    p_rep_count => p_rep_count,
    p_slice_width => p_slice_width
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    phase_in => phase_in_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv, 
    phase_out => phase_out_bv, 
    ctrl_vect_in =>	ctrl_vect_in_bv,
    ctrl_vect_out => ctrl_vect_out_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );  
  
END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
USE XilinxCoreLib.mult_pkg_v4_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_beh_bv_v1_1 IS
  GENERIC (
	p_architecture : INTEGER := c_wser_arch;--Determines Engine Architecture
    p_cordic_funct : INTEGER := c_f_default;
    p_ctrl_width : INTEGER := 4; --Number of bits of control logic stored by engine
    p_data_extend : INTEGER := 5; -- Number of extra bits carried in addition.
    p_data_width : INTEGER := 32; -- Determines Data Path Width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_replications : INTEGER := 1; --Level of internal replication to increase throughput
    p_round_mode : INTEGER := c_round_pos_neg_inf; -- Determines rounding mode.
    p_scale_comp : INTEGER := c_scale_none -- Determines rounding mode.
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    ctrl_vect_in : IN BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_eng_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_eng_beh_bv_v1_1 IS

  FUNCTION f_transform_type(cordic_funct : INTEGER)RETURN INTEGER IS
    VARIABLE transform_type_v : INTEGER;
  BEGIN
    transform_type_v := 0;
  	IF ((cordic_funct = c_f_sinh_cosh) OR (cordic_funct = c_f_atanh)) THEN
      transform_type_v := 1;
  	END IF; RETURN transform_type_v; 
  END f_transform_type;
  CONSTANT c_transform_type : INTEGER := f_transform_type(p_cordic_funct);
  
  FUNCTION f_get_iteration(I : INTEGER;transform_type : INTEGER)RETURN INTEGER IS 
    VARIABLE iteration_v : INTEGER;
  BEGIN
    iteration_v := I;
  	IF (transform_type = c_transform_hyp) THEN
      IF (I > 13) THEN iteration_v := I - 2;
      ELSIF (I >3) THEN iteration_v := I - 1;
      ELSE iteration_v := I;
      END IF;
  	END IF; RETURN iteration_v; 
  END f_get_iteration;

  FUNCTION f_slice_width(architecture_in:INTEGER;data_width_in:INTEGER) RETURN INTEGER IS
    VARIABLE slice_width_v : INTEGER;
  BEGIN
    IF (architecture_in = c_wser_arch) THEN
      slice_width_v := data_width_in;
    ELSE
      slice_width_v := 1;
    END	IF;
    RETURN slice_width_v;
  END f_slice_width;
  CONSTANT c_slice_width :INTEGER := f_slice_width(p_architecture,p_data_width); 
  
  FUNCTION f_rep_count(architecture_in:INTEGER;data_width:INTEGER;
                       slice_width:INTEGER;transform_type:INTEGER) RETURN INTEGER IS
    VARIABLE rep_count_v : INTEGER;
  BEGIN
    rep_count_v := (((data_width-1)/slice_width)+1);
  	IF (transform_type = c_transform_hyp) AND (architecture_in = c_para_arch) THEN
      IF (rep_count_v >= 12) THEN rep_count_v := rep_count_v + 2;
      ELSIF (rep_count_v >= 3) THEN rep_count_v := rep_count_v + 1;
      END IF;
  	END IF; RETURN rep_count_v; 
  END;
  CONSTANT c_rep_count :INTEGER := f_rep_count(p_architecture,p_data_width,c_slice_width,c_transform_type);
  
  FUNCTION f_width_int RETURN INTEGER IS 
  BEGIN
  	RETURN (p_data_width + p_data_extend);
  END;
  CONSTANT c_data_width_int :INTEGER := f_width_int; 

  FUNCTION f_width_rnd return integer is 
    VARIABLE width_int : INTEGER; 
  BEGIN
    --default p_round_mode = c_round_truncate;
  	  width_int := p_data_width;
    --p_round_mode = c_round_pos_inf;
    IF p_round_mode = c_round_pos_inf THEN
      width_int := p_data_width + 1;	
    END IF;
    --p_round_mode = c_pos_neg_inf;
    IF p_round_mode = c_round_pos_neg_inf THEN
      width_int := p_data_width + 1;	
    END IF;
  	RETURN width_int;
  END;
  CONSTANT c_data_width_rnd :INTEGER := f_width_rnd; 

  FUNCTION f_offset(x : INTEGER) RETURN INTEGER IS 
    VARIABLE tmp : INTEGER;
  BEGIN
    tmp := 3;
  	IF x = 0 THEN
    tmp := 2;
    END IF;
  	RETURN tmp;
  END;

  CONSTANT c_inv_scale_bv : BIT_VECTOR(p_data_width+p_data_extend-1 DOWNTO 0) :=
    sl_to_bv(f_inv_cordic_scale_coeff_slv(p_data_width+p_data_extend,p_cordic_funct));
  CONSTANT c_inv_scale_str : STRING(1 TO p_data_width+p_data_extend) :=
    f_inv_cordic_scale_coeff_str(p_data_width+p_data_extend,p_cordic_funct);
    
  CONSTANT c_scale_latency : INTEGER :=	
    calc_latency(
            c_a_width => p_data_width+p_data_extend,
            c_b_width => p_data_width+p_data_extend,
            c_b_type => c_unsigned,
            c_has_a_signed => 0,
            c_reg_a_b_inputs => 1,
            c_mem_type => 0,
            c_pipeline => 1,
            c_mult_type => 2,
            c_has_loadb => 0,
            c_baat => p_data_width+p_data_extend,
            c_b_value => c_inv_scale_str,
            c_a_type => c_signed,
            c_has_swapb => 0,
            c_sqm_type => 0,
            bram_addr_width => 8
         ) + 2;
         
  SUBTYPE data_int_type IS SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  TYPE	data_int_vect IS ARRAY (c_rep_count DOWNTO 0) of data_int_type;
  SUBTYPE control_int_type IS BIT_VECTOR(p_ctrl_width-1 DOWNTO 0); 
  TYPE control_int_vect IS ARRAY (c_rep_count DOWNTO 0) OF control_int_type;
  TYPE add_nsub_vect_type IS ARRAY (c_rep_count DOWNTO 0) OF BIT_VECTOR(1 DOWNTO 0);

  SIGNAL data_x_int_vect : data_int_vect;
  SIGNAL data_y_int_vect : data_int_vect;
  SIGNAL phase_int_vect : data_int_vect;
  SIGNAL ctrl_int_vect : control_int_vect;
  SIGNAL add_nsub_vect : add_nsub_vect_type;

  SIGNAL data_x_int_vect_par : data_int_vect;
  SIGNAL data_y_int_vect_par : data_int_vect;
  SIGNAL phase_int_vect_par : data_int_vect;
  SIGNAL ctrl_int_vect_par : control_int_vect;

  SIGNAL data_x_int_vect_wser : data_int_vect;
  SIGNAL data_y_int_vect_wser : data_int_vect;
  SIGNAL phase_int_vect_wser : data_int_vect;
  SIGNAL ctrl_int_vect_wser : control_int_vect;

  SIGNAL test_c_slice_width : INTEGER := c_slice_width; 
  SIGNAL test_c_rep_count   : INTEGER := c_rep_count;

  --New variable introduced to allow for multiplication and register stages.
  --Structural does both operations simultaneously.
  SIGNAL data_x_pre_scale : SIGNED(2*(p_data_width+p_data_extend)-1 DOWNTO 0);
  SIGNAL data_y_pre_scale : SIGNED(2*(p_data_width+p_data_extend)-1 DOWNTO 0);
  SIGNAL phase_pre_scale : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL ctrl_vect_pre_scale : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  
  SIGNAL data_x_scale : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL data_y_scale : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL phase_scale : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL ctrl_vect_scale : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);

  SIGNAL data_x_select : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL data_y_select : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL phase_select : SIGNED(p_data_width+p_data_extend-1 DOWNTO 0);
  SIGNAL ctrl_vect_select : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);

  SIGNAL data_x_round : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_round : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_round : SIGNED(p_data_width-1 DOWNTO 0);

  SIGNAL data_x_reg : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_reg : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_reg : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_reg : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);

  SIGNAL data_x_tmp : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_tmp : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_tmp : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_tmp : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);

  SIGNAL nd_dummy : BIT;
  SIGNAL rdy_dummy : BIT;
	
BEGIN

  --Allocate Parallel and WSER versions of internal signals
  data_x_int_vect_par(0) <= data_x_int_vect(0);
  data_y_int_vect_par(0) <= data_y_int_vect(0);
  phase_int_vect_par(0) <= phase_int_vect(0);
  ctrl_int_vect_par(0) <= ctrl_int_vect(0);
  data_x_int_vect_wser(0) <= data_x_int_vect(0);
  data_y_int_vect_wser(0) <= data_y_int_vect(0);
  phase_int_vect_wser(0) <= phase_int_vect(0);
  ctrl_int_vect_wser(0) <= ctrl_int_vect(0);

  gen_add_nsub_vect : PROCESS(data_y_int_vect,phase_int_vect)
  BEGIN
    add_nsub_vect(0)(0) <= data_y_int_vect(0)(p_data_width+p_data_extend-1);
    add_nsub_vect(0)(1) <= phase_int_vect(0)(p_data_width+p_data_extend-1);
  END PROCESS;

  --Assign internal signals to selected architecture.
  gen_int_vect : PROCESS(ctrl_vect_in, ctrl_int_vect,
                    data_x_in, data_y_in, phase_in,
                    data_x_int_vect_par, data_y_int_vect_par, 
                    phase_int_vect_par, ctrl_int_vect_par,
                    data_x_int_vect_wser, data_y_int_vect_wser, 
                    phase_int_vect_wser, ctrl_int_vect_wser)                    
  BEGIN

    ctrl_int_vect(0)(3) <= ctrl_vect_in(3);
    ctrl_int_vect(0)(2) <= ctrl_vect_in(2);
    ctrl_int_vect(0)(1) <= ctrl_int_vect(1)(0);
    ctrl_int_vect(0)(0) <= ctrl_vect_in(0);

    FOR I IN 0 TO c_data_width_int-1 LOOP
      IF (I < p_data_extend) THEN
        data_x_int_vect(0)(I) <= '0';
        data_y_int_vect(0)(I) <= '0';
        phase_int_vect(0)(I) <= '0';
      ELSE
        data_x_int_vect(0)(I) <= data_x_in(I-p_data_extend);
        data_y_int_vect(0)(I) <= data_y_in(I-p_data_extend);
        phase_int_vect(0)(I) <= phase_in(I-p_data_extend);
      END IF;
    END LOOP;  	

    IF (p_architecture = c_para_arch) THEN
      data_x_int_vect(c_rep_count) <= data_x_int_vect_par(c_rep_count);
      data_y_int_vect(c_rep_count) <= data_y_int_vect_par(c_rep_count);
      phase_int_vect(c_rep_count) <= phase_int_vect_par(c_rep_count);
      ctrl_int_vect(c_rep_count) <= ctrl_int_vect_par(c_rep_count);
      ctrl_int_vect(1) <= ctrl_int_vect_par(1);
    END IF;
    IF (p_architecture = c_wser_arch) THEN
      data_x_int_vect(c_rep_count) <= data_x_int_vect_wser(c_rep_count);
      data_y_int_vect(c_rep_count) <= data_y_int_vect_wser(c_rep_count);
      phase_int_vect(c_rep_count) <= phase_int_vect_wser(c_rep_count);
      ctrl_int_vect(c_rep_count) <= ctrl_int_vect_par(c_rep_count);
      ctrl_int_vect(1) <= ctrl_int_vect_wser(1);
    END IF;
  END PROCESS;
 
  gen_eng: FOR I IN 0 TO c_rep_count-1 GENERATE

    inst_eng_slice_par: cordic_eng_slice_par_beh_bv_v1_1
    GENERIC MAP(
      p_cordic_funct => p_cordic_funct,
      p_ctrl_width => p_ctrl_width,
      p_data_width_int => c_data_width_int, 
      p_enable_rlocs => p_enable_rlocs,
      p_hardwired_shift => f_get_iteration(I,c_transform_type),
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_iteration => f_get_iteration(I,c_transform_type),
      p_phase_format => p_phase_format
    )
    PORT MAP(
      data_x_in => data_x_int_vect_par(I),
      data_y_in => data_y_int_vect_par(I),
      phase_in => phase_int_vect_par(I),
      data_x_out => data_x_int_vect_par(I+1),
      data_y_out => data_y_int_vect_par(I+1),
      phase_out => phase_int_vect_par(I+1),
      add_nsub_gen_in => add_nsub_vect(I),
      add_nsub_gen_out => add_nsub_vect(I+1),
      ctrl_vect_in => ctrl_int_vect_par(I),
      ctrl_vect_out => ctrl_int_vect_par(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );

    inst_eng_slice_wser: cordic_eng_slice_wser_beh_bv_v1_1
    GENERIC MAP(
      p_cordic_funct => p_cordic_funct,
      p_ctrl_width => p_ctrl_width,
      p_data_width_int => c_data_width_int, 
      p_data_extend => p_data_extend, 
      p_enable_rlocs => p_enable_rlocs,
      p_hardwired_shift => (c_slice_width * I),
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr,
      p_iteration => I,
      p_mif_file_prefix => p_mif_file_prefix,
      p_phase_format => p_phase_format,
      p_rep_count => c_rep_count,
      p_slice_width => c_slice_width
      )
    PORT MAP(
      data_x_in => data_x_int_vect_wser(I),
      data_y_in => data_y_int_vect_wser(I),
      phase_in => phase_int_vect_wser(I),
      data_x_out => data_x_int_vect_wser(I+1),
      data_y_out => data_y_int_vect_wser(I+1),
      phase_out => phase_int_vect_wser(I+1),
      ctrl_vect_in => ctrl_int_vect_wser(I),
      ctrl_vect_out => ctrl_int_vect_wser(I+1),
      clk => clk,
      aclr => aclr,
      sclr => sclr,
      ce => ce
    );
  END GENERATE;  
  
  data_x_pre_scale <= SIGNED(mult_sbv(BIT_VECTOR(data_x_int_vect(c_rep_count)),c_inv_scale_bv));

  inst_data_x_scale_delay : lib_fifo_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_depth => c_scale_latency,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => p_data_width+p_data_extend
  )
  PORT MAP(
    d => data_x_pre_scale(2*(p_data_width+p_data_extend)-3 DOWNTO 
                            (p_data_width+p_data_extend)-2),
    q => data_x_scale,
    clk => clk,
    ce => ce,
    aclr => aclr,
    sclr => sclr
  );

  gen_data_x_select : PROCESS (data_x_int_vect, data_x_scale)
  BEGIN 
    IF (p_scale_comp = c_scale_none) THEN
      data_x_select <= data_x_int_vect(c_rep_count);   
    END IF;
    IF (p_scale_comp = c_scale_ccm) THEN
        data_x_select <= data_x_scale;
    END IF;
  END PROCESS;

  data_x_round <= SIGNED(rnd_sbv(BIT_VECTOR(data_x_select), p_round_mode, p_data_width));
       
  inst_round_data_x_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_round,
    q => data_x_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_data_x_tmp : PROCESS (data_x_reg,data_x_round)
  BEGIN 
    data_x_tmp <= (OTHERS => '0');
    IF (c_funct_has_port(p_cordic_funct,2) = 1) THEN
      IF (p_round_mode = c_round_truncate) THEN
        data_x_tmp <= data_x_round;   
      ELSE      	
        data_x_tmp <= data_x_reg;   
      END IF;
    END IF;
  END PROCESS;

  --generate data_y_tmp
  data_y_pre_scale <= SIGNED(mult_sbv(BIT_VECTOR(data_y_int_vect(c_rep_count)), c_inv_scale_bv));

  inst_data_y_scale_delay : lib_fifo_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_depth => c_scale_latency,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => p_data_width+p_data_extend
  )
  PORT MAP(
    d => data_y_pre_scale(2*(p_data_width+p_data_extend)-3 DOWNTO 
                            (p_data_width+p_data_extend)-2),
    q => data_y_scale,
    clk => clk,
    ce => ce,
    aclr => aclr,
    sclr => sclr
  );

  gen_data_y_select : PROCESS (data_y_int_vect, data_y_scale)
  BEGIN 
    IF (p_scale_comp = c_scale_none) THEN
      data_y_select <= data_y_int_vect(c_rep_count);   
    END IF;
    IF (p_scale_comp = c_scale_ccm) THEN
        data_y_select <= data_y_scale;
    END IF;
  END PROCESS;

  data_y_round <= SIGNED(rnd_sbv(BIT_VECTOR(data_y_select), p_round_mode, p_data_width));

  inst_round_data_y_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC Map(
    p_width => p_data_width,
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT Map(
    d => data_y_round,
    q => data_y_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_data_y_out : PROCESS (data_y_reg,data_y_round)
  BEGIN 
    data_y_tmp <= (OTHERS => '0');
    IF (c_funct_has_port(p_cordic_funct,1) = 1) THEN
      IF (p_round_mode = c_round_truncate) THEN
        data_y_tmp <= data_y_round;   
      ELSE      	
        data_y_tmp <= data_y_reg;   
      END IF;
    END IF;
  END PROCESS;

  phase_pre_scale <= phase_int_vect(c_rep_count);
  
  inst_scale_del_phase : lib_fifo_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_depth => c_scale_latency,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => p_data_width+p_data_extend
  )
  PORT MAP(
    d => phase_pre_scale,
    q => phase_scale,
    clk => clk,
    ce => ce,
    aclr => aclr,
    sclr => sclr
  );

  gen_phase_select : PROCESS (phase_int_vect, phase_scale)
  BEGIN 
    IF (p_scale_comp = c_scale_none) THEN
      phase_select <= phase_int_vect(c_rep_count);   
    END IF;
    IF (p_scale_comp = c_scale_ccm) THEN
      phase_select <= phase_scale;
    END IF;
  END PROCESS;

  phase_round <= SIGNED(rnd_sbv(BIT_VECTOR(phase_select), p_round_mode, p_data_width));

  inst_round_phase_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC Map(
    p_width => p_data_width,
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT Map(
    d => phase_round,
    q => phase_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_phase_out : PROCESS (phase_reg,phase_round)
  BEGIN 
    phase_tmp <= (OTHERS => '0');
    IF (c_funct_has_port(p_cordic_funct,0) = 1) THEN
      IF (p_round_mode = c_round_truncate) THEN
        phase_tmp <= phase_round;   
      ELSE      	
        phase_tmp <= phase_reg;   
      END IF;
    END IF;
  END PROCESS;

  ctrl_vect_pre_scale <= ctrl_int_vect(c_rep_count);
  
  inst_ctrl_vect_scale_del_phase : lib_fifo_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_depth => c_scale_latency,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => p_ctrl_width
  )
  PORT MAP(
    d => ctrl_vect_pre_scale,
    q => ctrl_vect_scale,
    clk => clk,
    ce => ce,
    aclr => aclr,
    sclr => sclr
  );

  gen_ctrl_select : PROCESS (ctrl_int_vect, ctrl_vect_scale)
  BEGIN 
    IF (p_scale_comp = c_scale_none) THEN
      ctrl_vect_select <= ctrl_int_vect(c_rep_count);   
    END IF;
    IF (p_scale_comp = c_scale_ccm) THEN
      ctrl_vect_select <= ctrl_vect_scale;
    END IF;
  END PROCESS;
  
  inst_ctrl_vet_reg : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_width => (p_ctrl_width),
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => ctrl_vect_select,
    q => ctrl_vect_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  ctrl_vect_tmp <= ctrl_vect_reg;
  
  data_x_out <= data_x_tmp AFTER 1 ns;
  data_y_out <= data_y_tmp AFTER 1 ns;
  phase_out <= phase_tmp AFTER 1 ns;
  ctrl_vect_out <= ctrl_vect_reg AFTER 1 ns;  
  
END behav;

	
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;

ENTITY cordic_eng_beh_v1_1 IS
  GENERIC (
	p_architecture : INTEGER := c_wser_arch;--Determines Engine Architecture
    p_cordic_funct : INTEGER := c_f_default;
    p_ctrl_width : INTEGER := 2; --Number of bits of control logic stored by engine
    p_data_extend : INTEGER := 5; -- Number of extra bits carried in addition.
    p_data_width : INTEGER := 30; -- Determines Data Path Width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_mif_file_prefix : STRING := "cor1atan_rom_";
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_replications : INTEGER := 1; --Level of internal replication to increase throughput
    p_round_mode : INTEGER := c_round_pos_neg_inf; -- Determines rounding mode.
    p_scale_comp : INTEGER := c_scale_none -- Determines rounding mode.
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    ctrl_vect_in : IN STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    ctrl_vect_out : OUT STD_LOGIC_VECTOR(p_ctrl_width-1 DOWNTO 0);
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_eng_beh_v1_1;

ARCHITECTURE behav OF cordic_eng_beh_v1_1 IS

  SIGNAL data_x_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_in_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL ctrl_vect_out_bv : BIT_VECTOR(p_ctrl_width-1 DOWNTO 0);
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
  
BEGIN
  
  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,
          phase_in,phase_out_bv,ctrl_vect_in,ctrl_vect_out_bv,
          clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
    ctrl_vect_in_bv <= sl_to_bv(ctrl_vect_in);
    ctrl_vect_out <= bv_to_sl(ctrl_vect_out_bv);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);	
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
  END PROCESS;

  inst_cordic_eng_beh_bv_v1_1: cordic_eng_beh_bv_v1_1
  GENERIC MAP(
    p_architecture => p_architecture,
    p_cordic_funct => p_cordic_funct,
    p_ctrl_width => p_ctrl_width,
    p_data_extend => p_data_extend,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_mif_file_prefix => p_mif_file_prefix,
    p_phase_format => p_phase_format,
    p_replications => p_replications,
    p_round_mode => p_round_mode,
    p_scale_comp => p_scale_comp
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    phase_in => phase_in_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv, 
    phase_out => phase_out_bv, 
    ctrl_vect_in => ctrl_vect_in_bv,
    ctrl_vect_out => ctrl_vect_out_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );  
  
END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;

PACKAGE cordic_main_comps_beh_v1_1 IS

  COMPONENT cordic_main_beh_v1_1
  GENERIC (
    c_architecture	: INTEGER := c_para_arch; 
    c_cordic_funct : INTEGER := c_f_rotate;
    c_enable_rlocs : INTEGER := 1;
    c_has_aclr : INTEGER := 0;
    c_has_ce : INTEGER := 0;
    c_has_nd : INTEGER := 1;
    c_has_rdy : INTEGER := 0;
    c_has_rfd : INTEGER := 0;
    c_has_sclr : INTEGER := 0;
    c_input_width : INTEGER := 32;
    c_mif_file_prefix : STRING := "cor1";
    c_output_width : INTEGER := 32;
    c_phase_format : INTEGER := c_format_rad;
    c_pipeline_mode : INTEGER := c_pipe_max;
    c_reg_inputs : INTEGER := 0;
    c_replications	: INTEGER := c_repl_opt;
    c_round_mode : INTEGER := c_round_pos_neg_inf;
    c_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    x_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    y_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    x_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    y_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
  END COMPONENT;
  
  COMPONENT cordic_rotate_beh_bv_v1_1
  GENERIC (
    p_architecture : INTEGER := c_para_arch; 
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32; --set to output width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode : INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT(
    phase_in : in SIGNED(p_data_width-1 downto 0) := (OTHERS => '0');
    data_x_init : in SIGNED(p_data_width-1 downto 0) := (OTHERS => '0');
    data_y_init : in SIGNED(p_data_width-1 downto 0) := (OTHERS => '0');
    nd : IN BIT := '1';
    data_x_out : OUT SIGNED(p_data_width-1 downto 0);
    data_y_out : OUT SIGNED(p_data_width-1 downto 0);
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT := '0';
    sclr : IN BIT := '0';
    ce : IN BIT := '1'
  );
  END COMPONENT;

  COMPONENT cordic_rotate_beh_v1_1
  GENERIC (
    p_architecture : INTEGER := c_para_arch; 
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32; --set to output width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode : INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT(
    phase_in : in STD_LOGIC_VECTOR(p_data_width-1 downto 0) := (OTHERS => 'Z');
    data_x_init : in STD_LOGIC_VECTOR(p_data_width-1 downto 0) := (OTHERS => 'Z');
    data_y_init : in STD_LOGIC_VECTOR(p_data_width-1 downto 0) := (OTHERS => 'Z');
    nd : IN STD_LOGIC := '1';
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0';
    ce : IN STD_LOGIC := '1'
  );
  END COMPONENT;
  
  COMPONENT cordic_translate_beh_bv_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode	: INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0) := (OTHERS => '0');
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0) := (OTHERS => '0');
    nd : IN BIT := '0';
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT := '0';
    sclr : IN BIT := '0';
    ce : IN BIT := '1'
  );
  END COMPONENT;

  COMPONENT cordic_sqrt_beh_bv_v1_1
  GENERIC (
    p_enable_rlocs :INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_input_width : INTEGER := 64;
    p_output_width : INTEGER := 32;
    p_pipeline_mode : INTEGER := 0;
    p_reg_inputs : INTEGER := 0;
    p_round_mode : INTEGER := 1
    );
  PORT (
    data_in : IN BIT_VECTOR(p_input_width-1 DOWNTO 0);
    sqrt_out : OUT BIT_VECTOR(p_output_width-1 DOWNTO 0);
    nd : IN BIT;
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    ce : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_sqrt_beh_v1_1
  GENERIC (
    p_enable_rlocs :INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_input_width : INTEGER := 64;
    p_output_width : INTEGER := 32;
    p_pipeline_mode : INTEGER := 0;
    p_reg_inputs : INTEGER := 0;
    p_round_mode : INTEGER := 1
    );
  PORT (
    data_in : IN STD_LOGIC_VECTOR(p_input_width-1 DOWNTO 0);
    sqrt_out : OUT STD_LOGIC_VECTOR(p_output_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
  END COMPONENT;

  COMPONENT cordic_translate_beh_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode	: INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := (OTHERS => 'Z');
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := (OTHERS => 'Z');
    nd : IN STD_LOGIC := '0';
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0';
    ce : IN STD_LOGIC := '1'
  );
  END COMPONENT;
  
  COMPONENT cordic_sel_xor_mux_2xtox_beh_bv_v1_1
	GENERIC (p_data_width : INTEGER := 64;
	         p_enable_rlocs : INTEGER := 1);
	PORT (
    a : IN SIGNED(p_data_width-1 DOWNTO 0); -- INPUT VECTOR
    b : IN SIGNED(p_data_width-1 DOWNTO 0); -- INPUT VECTOR
    s : IN BIT := '0'; -- SELECT PIN
    x : IN BIT := '0'; -- XOR PIN
    o : OUT SIGNED(p_data_width-1 DOWNTO 0)-- OUTPUT VALUE
  );
  END COMPONENT;
  
  COMPONENT cordic_sel_xor_mux_2xtox_beh_v1_1
	GENERIC (p_data_width : INTEGER := 64;
	         p_enable_rlocs : INTEGER := 1);
	PORT (
    a : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0); -- INPUT VECTOR
    b : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0); -- INPUT VECTOR
    s : IN STD_LOGIC := '0'; -- SELECT PIN
    x : IN STD_LOGIC := '0'; -- XOR PIN
    o : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0)-- OUTPUT VALUE
  );
  END COMPONENT;
  
  COMPONENT cordic_inp_format_rotate_beh_bv_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_out : OUT BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    nd_out : OUT BIT;
    rfd_in : IN BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_inp_format_rotate_beh_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    nd_out : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
  END COMPONENT;

  COMPONENT cordic_out_format_rotate_beh_bv_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_in : IN BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    rdy_in : IN BIT;
    rdy_out : OUT BIT;
    rfd_in : IN BIT;    
    rfd_out : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;
  
  COMPONENT cordic_out_format_rotate_beh_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := (OTHERS => 'Z');
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := (OTHERS => 'Z');
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0) := "ZZ";
    nd_in : IN STD_LOGIC := 'Z';
    rdy_in : IN STD_LOGIC := 'Z';
    rdy_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC := 'Z';    
    rfd_out : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0';
    ce : IN STD_LOGIC := '1'
  );
  END COMPONENT;
  
  COMPONENT cordic_inp_format_translate_beh_bv_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_out : OUT BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    nd_out : OUT BIT;
    rfd_in : IN BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_inp_format_translate_beh_v1_1
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    nd_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
  END COMPONENT;

  COMPONENT cordic_out_format_translate_beh_bv_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 16;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
    );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_in : IN BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    rdy_in : IN BIT;
    rdy_out : OUT BIT;
    rfd_in : IN BIT;
    rfd_out : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
  END COMPONENT;

  COMPONENT cordic_out_format_translate_beh_v1_1
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 16;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
    );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    rdy_in : IN STD_LOGIC;
    rdy_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;
    rfd_out : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
  END COMPONENT;

END cordic_main_comps_beh_v1_1;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;

ENTITY cordic_inp_format_rotate_beh_bv_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 1
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_out : OUT BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    nd_out : OUT BIT;
    rfd_in : IN BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_inp_format_rotate_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_inp_format_rotate_beh_bv_v1_1 IS

  SIGNAL data_x_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_in_reg : BIT;
  SIGNAL rfd_in_reg : BIT;

  SIGNAL data_x_int : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_int : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_int : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_int : BIT;
  SIGNAL rfd_int : BIT;
  SIGNAL nd_rfd_int : BIT;

  SIGNAL data_x_int_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_int_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_int_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_int_reg : BIT;

  SIGNAL phase_sign : BIT;
  SIGNAL phase_sign_reg : BIT;

  SIGNAL pi_3_sel : BIT;
  SIGNAL pi_1_sel : BIT;
  --SIGNAL inv_phase_sign : BIT;
  
  SIGNAL phase_pi_4_rot : SIGNED(p_data_width-1 downto 0); 
  SIGNAL phase_pi_3_rot : SIGNED(p_data_width-1 downto 0); 
  SIGNAL phase_pi_2_rot : SIGNED(p_data_width-1 downto 0); 
  SIGNAL phase_pi_1_rot : SIGNED(p_data_width-1 downto 0); 
 
  SIGNAL sign_x_min_y : BIT;
  SIGNAL sign_x_plus_y : BIT;
  SIGNAL x_min_y : SIGNED(p_data_width-1 downto 0);
  SIGNAL x_plus_y : SIGNED(p_data_width-1 downto 0);

  CONSTANT zero_vect : SIGNED(p_data_width-1 downto 0) := (OTHERS => '0');
  SIGNAL data_x_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_trans_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_trans_reg : SIGNED(p_data_width-1 downto 0);

  SIGNAL quad_data : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL quad_phase : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL quad_int : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL quad_int_reg : BIT_VECTOR(1 DOWNTO 0);

  FUNCTION f_select_pi_const(rads_const : STD_LOGIC_VECTOR;
                             jrad_const : STD_LOGIC_VECTOR)
                      RETURN STD_LOGIC_VECTOR IS
    VARIABLE pi_tmp : STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
  BEGIN
    pi_tmp := rads_const(c_max_rom_width-1 DOWNTO c_max_rom_width-p_data_width);
    IF (p_phase_format = c_format_sca) THEN
      pi_tmp := jrad_const(c_max_rom_width-1 DOWNTO c_max_rom_width-p_data_width);
    END IF;
    RETURN pi_tmp;
  END;
  CONSTANT c_neg_pi_const : STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(c_neg_pi_rads_const,c_neg_pi_jrads_const); 
  CONSTANT c_neg_pi_3_4_const : STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(c_neg_pi_3_4_rads_const,c_neg_pi_3_4_jrads_const); 
  CONSTANT c_neg_pi_2_4_const : STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(c_neg_pi_2_4_rads_const,c_neg_pi_2_4_jrads_const); 
  CONSTANT c_neg_pi_1_4_const : STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(c_neg_pi_1_4_rads_const,c_neg_pi_1_4_jrads_const); 
             
BEGIN

  inst_data_x_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_in,
    q => data_x_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  inst_data_y_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_in,
    q => data_y_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_phase_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_in,
    q => phase_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
    
  --register nd signal
  inst_nd_in_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_in,
    q => nd_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  --register rfd signal
  inst_rfd_in_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => rfd_in,
    q => rfd_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  PROCESS(data_x_in,data_y_in,phase_in,nd_in,rfd_in,
          data_x_in_reg,data_y_in_reg,phase_in_reg,nd_in_reg,rfd_in_reg)
  BEGIN
    data_x_int <= data_x_in;
    data_y_int <= data_y_in;
    phase_int <= phase_in;
    nd_int <= nd_in;
    rfd_int <= rfd_in;
    IF (p_reg_inputs = 1) THEN
      data_x_int <= data_x_in_reg;
      data_y_int <= data_y_in_reg;
      phase_int <= phase_in_reg;
      nd_int <= nd_in_reg;
      rfd_int <= rfd_in_reg;
    END IF;      	
  END PROCESS;

---------------------------------------  
  --********************************************************
  -- Coarse Rotation of Input Phase
  phase_sign <= phase_int(p_data_width-1);
  phase_sign_reg <= phase_int_reg(p_data_width-1);

  pi_3_sel <= phase_pi_3_rot(p_data_width -1);
  pi_1_sel <= phase_pi_1_rot(p_data_width -1);

  -- Calculate Phase input +/- (4*Pi/4)
  -- The beh model adds the registered phase which is the same 
  -- as the registered adders in struct model.
  gen_phase_pi_sigs : PROCESS(phase_int_reg, phase_sign_reg) 
  BEGIN
    phase_pi_4_rot <= phase_int_reg - SIGNED(sl_to_bv(c_neg_pi_const));
    phase_pi_3_rot <= phase_int_reg - SIGNED(sl_to_bv(c_neg_pi_3_4_const));
    phase_pi_2_rot <= phase_int_reg - SIGNED(sl_to_bv(c_neg_pi_2_4_const));
    phase_pi_1_rot <= phase_int_reg - SIGNED(sl_to_bv(c_neg_pi_1_4_const));
    IF (phase_sign_reg = '0') THEN
      phase_pi_4_rot <= phase_int_reg + SIGNED(sl_to_bv(c_neg_pi_const));
      phase_pi_3_rot <= phase_int_reg + SIGNED(sl_to_bv(c_neg_pi_3_4_const));
      phase_pi_2_rot <= phase_int_reg + SIGNED(sl_to_bv(c_neg_pi_2_4_const));
      phase_pi_1_rot <= phase_int_reg + SIGNED(sl_to_bv(c_neg_pi_1_4_const));
    END IF;
  END PROCESS;

  inst_phase_int_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_int,
    q => phase_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  gen_phase_trans : PROCESS(phase_int_reg,phase_pi_2_rot,phase_pi_4_rot,
                            phase_sign_reg,pi_3_sel,pi_1_sel) 
  BEGIN
    IF (phase_sign_reg = '0') THEN
      phase_trans <= phase_pi_4_rot;
      quad_phase <= "00";
      IF pi_3_sel = '1' THEN
        phase_trans <= phase_pi_2_rot;
        quad_phase <= "01";
      END IF;
      IF pi_1_sel = '1' THEN
        phase_trans <= phase_int_reg;
        quad_phase <= "11";
      END IF;
    END IF;
    IF (phase_sign_reg = '1') THEN
      phase_trans <= phase_pi_4_rot;
      quad_phase <= "00";
      IF (pi_3_sel = '0') THEN
        phase_trans <= phase_pi_2_rot;
        quad_phase <= "10";
      END IF;
      IF (pi_1_sel = '0') THEN
        phase_trans <= phase_int_reg;
        quad_phase <= "11";
      END IF;
    END IF;
  END PROCESS;

  inst_phase_trans_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_trans,
    q => phase_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
----------------------------------------  
  
  --******************************************************
  -- Translate Initial X_Y Vector into 1st Quadrant

  sign_x_min_y  <= x_min_y(p_data_width -1);
  sign_x_plus_y <= x_plus_y(p_data_width -1);

  -- Calculate X Minus Y and X Plus Y
  gen_quad : PROCESS(data_x_int_reg, data_y_int_reg)
  BEGIN
    x_min_y <= data_x_int_reg - data_y_int_reg;
    x_plus_y <= data_x_int_reg + data_y_int_reg;
  END PROCESS gen_quad;

  inst_data_x_int_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_int,
    q => data_x_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_y_int_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_int,
    q => data_y_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  nd_rfd_int <= nd_int AND rfd_int;

  inst_nd_int_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_rfd_int,
    q => nd_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  quad_data <= (NOT(sign_x_min_y),NOT(sign_x_plus_y));

  gen_trans : PROCESS(data_x_int_reg, data_y_int_reg, quad_data)
  BEGIN
    CASE quad_data IS
      WHEN "11" =>
        data_x_trans <= data_x_int_reg;
        data_y_trans <= data_y_int_reg;
      WHEN "01" =>
        data_x_trans <= data_y_int_reg;
        data_y_trans <= zero_vect - data_x_int_reg;
      WHEN "00" =>
        data_x_trans <= zero_vect - data_x_int_reg;
        data_y_trans <= zero_vect - data_y_int_reg;  
      WHEN "10" =>
        data_x_trans <= zero_vect - data_y_int_reg;
        data_y_trans <= data_x_int_reg; 
      WHEN OTHERS =>
        data_x_trans <= data_x_int_reg;
        data_y_trans <= data_y_int_reg;
    END CASE;

  END PROCESS gen_trans;
  
  reg_data_x_trans : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_trans,
    q => data_x_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  reg_data_y_trans : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_trans,
    q => data_y_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  gen_quad_int : PROCESS(quad_data,quad_phase)
  BEGIN
    CASE quad_data IS
      WHEN "00" => quad_int(1) <= NOT(quad_phase(1));
                   quad_int(0) <= NOT(quad_phase(0));
      WHEN "01" => quad_int(1) <= NOT(quad_phase(0));
                   quad_int(0) <= quad_phase(1);
      WHEN "11" => quad_int(1) <= quad_phase(1);
                   quad_int(0) <= quad_phase(0);
      WHEN "10" => quad_int(1) <= quad_phase(0);
                   quad_int(0) <= NOT(quad_phase(1));
    END CASE;  	
  END PROCESS;

  inst_reg_quad : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_width => 2,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => quad_int,
    q => quad_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  --Assign Outputs
  data_x_out <= data_x_trans_reg AFTER 1 ns;
  data_y_out <= data_y_trans_reg AFTER 1 ns;
  phase_out <= phase_trans_reg AFTER 1 ns;

  quad_out(1)  <= quad_int_reg(1) AFTER 1 ns;
  quad_out(0)  <= quad_int_reg(0) AFTER 1 ns;
    
  nd_out <= nd_int_reg AFTER 1 ns;
  
end;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_inp_format_rotate_beh_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    nd_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_inp_format_rotate_beh_v1_1;


ARCHITECTURE behav OF cordic_inp_format_rotate_beh_v1_1 IS

  SIGNAL data_x_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL quad_out_bv : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL nd_in_bv : BIT;
  SIGNAL nd_out_bv : BIT;
  SIGNAL rfd_in_bv : BIT;
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
     
BEGIN

  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,
          phase_in,phase_out_bv,quad_out_bv,nd_in,nd_out_bv,rfd_in,
          clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
    quad_out <= bv_to_sl(quad_out_bv);
    nd_in_bv <= sl_to_b(nd_in);
    nd_out <= b_to_sl(nd_out_bv);
    rfd_in_bv <= sl_to_b(rfd_in);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);	
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
  END PROCESS;

  inst_c_inp_fmt_rotate: cordic_inp_format_rotate_beh_bv_v1_1
  GENERIC MAP(
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format,
    p_reg_inputs => p_reg_inputs
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    phase_in => phase_in_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv, 
    phase_out => phase_out_bv, 
    quad_out => quad_out_bv,
    nd_in => nd_in_bv,
    nd_out => nd_out_bv,
    rfd_in => rfd_in_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;

ENTITY cordic_inp_format_translate_beh_bv_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_out : OUT BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    nd_out : OUT BIT;
    rfd_in : IN BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_inp_format_translate_beh_bv_v1_1;

ARCHITECTURE xilinx OF cordic_inp_format_translate_beh_bv_v1_1 IS

  SIGNAL data_x_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_in_reg : BIT;
  SIGNAL rfd_in_reg : BIT;

  SIGNAL data_x_int : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_int : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_int : BIT;
  SIGNAL rfd_int : BIT;
  SIGNAL nd_rfd_int : BIT;

  SIGNAL data_x_int_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_int_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_int_reg : BIT;

  SIGNAL sign_x_min_y : BIT;
  SIGNAL sign_x_plus_y : BIT;
  SIGNAL x_min_y : SIGNED(p_data_width-1 downto 0);
  SIGNAL x_plus_y : SIGNED(p_data_width-1 downto 0);

  CONSTANT zero_vect : SIGNED(p_data_width-1 downto 0) := (OTHERS => '0');
  SIGNAL data_x_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_trans_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans_reg : SIGNED(p_data_width-1 downto 0);

  SIGNAL quad_int : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL quad_int_reg : BIT_VECTOR(1 DOWNTO 0);

BEGIN

  inst_data_x_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_in,
    q => data_x_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_y_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_in,
    q => data_y_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  --register nd signal
  inst_nd_in_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_in,
    q => nd_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  --register rfd signal
  inst_rfd_in_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => rfd_in,
    q => rfd_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  PROCESS(data_x_in,data_y_in,nd_in,rfd_in,
          data_x_in_reg,data_y_in_reg,nd_in_reg,rfd_in_reg)
  BEGIN
    data_x_int <= data_x_in;
    data_y_int <= data_y_in;
    nd_int <= nd_in;
    rfd_int <= rfd_in;
    IF (p_reg_inputs = 1) THEN
      data_x_int <= data_x_in_reg;
      data_y_int <= data_y_in_reg;
      nd_int <= nd_in_reg;
      rfd_int <= rfd_in_reg;
    END IF;      	
  END PROCESS;

  --******************************************************
  --  Coarse Rotation of Initial X Y Coordinates 
  
  sign_x_min_y  <= x_min_y(p_data_width -1);
  sign_x_plus_y <= x_plus_y(p_data_width -1);

  -- Calculate X Minus Y and X Plus Y
  gen_quad : PROCESS(data_x_int_reg, data_y_int_reg)
  BEGIN
    x_min_y <= data_x_int_reg - data_y_int_reg;
    x_plus_y <= data_x_int_reg + data_y_int_reg;
  END PROCESS gen_quad;
  inst_data_x_int_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_int,
    q => data_x_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_y_int_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_int,
    q => data_y_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  nd_rfd_int <= nd_int AND rfd_int;

  inst_nd_int_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => nd_rfd_int,
    q => nd_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  quad_int <= (NOT(sign_x_min_y),NOT(sign_x_plus_y));

  gen_trans : PROCESS(data_x_int_reg, data_y_int_reg, quad_int)
  BEGIN
    CASE quad_int IS
      WHEN "11" =>
        data_x_trans <= data_x_int_reg;
        data_y_trans <= data_y_int_reg;
      WHEN "01" =>
        data_x_trans <= data_y_int_reg;
        data_y_trans <= zero_vect - data_x_int_reg;
      WHEN "00" =>
        data_x_trans <= zero_vect - data_x_int_reg;
        data_y_trans <= zero_vect - data_y_int_reg;  
      WHEN "10" =>
        data_x_trans <= zero_vect - data_y_int_reg;
        data_y_trans <= data_x_int_reg; 
      WHEN OTHERS =>
        data_x_trans <= data_x_int_reg;
        data_y_trans <= data_y_int_reg;
    END CASE;

  END PROCESS gen_trans;
  
  reg_data_x_trans : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_trans,
    q => data_x_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  reg_data_y_trans : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_y_trans,
    q => data_y_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_reg_quad : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_width => 2,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => quad_int,
    q => quad_int_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  
  --Assign Outputs
  data_x_out <= data_x_trans_reg AFTER 1 ns;
  data_y_out <= data_y_trans_reg AFTER 1 ns;

  quad_out(1)  <= quad_int_reg(1) AFTER 1 ns;
  quad_out(0)  <= quad_int_reg(0) AFTER 1 ns;

  nd_out <= nd_int_reg AFTER 1 ns;
  
END;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_inp_format_translate_beh_v1_1 IS
  GENERIC (
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_reg_inputs : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_out : OUT STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    nd_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_inp_format_translate_beh_v1_1;


ARCHITECTURE xilinx OF cordic_inp_format_translate_beh_v1_1 IS

  SIGNAL data_x_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL quad_out_bv : BIT_VECTOR(1 DOWNTO 0);
  SIGNAL nd_in_bv : BIT;
  SIGNAL nd_out_bv : BIT;
  SIGNAL rfd_in_bv : BIT;
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
     
BEGIN

  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,
          quad_out_bv,nd_in,nd_out_bv,rfd_in,clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    quad_out <= bv_to_sl(quad_out_bv);
    nd_in_bv <= sl_to_b(nd_in);
    nd_out <= b_to_sl(nd_out_bv);
    rfd_in_bv <= sl_to_b(rfd_in);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);	
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
  END PROCESS;

  inst_cordic_inp_fmt_trans: cordic_inp_format_translate_beh_bv_v1_1
  GENERIC MAP(
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format,
    p_reg_inputs => p_reg_inputs
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv, 
    quad_out => quad_out_bv,
    nd_in => nd_in_bv,
    nd_out => nd_out_bv,
    rfd_in => rfd_in_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_out_format_rotate_beh_bv_v1_1 IS
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_y_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    data_y_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_in : IN BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;
    rdy_in : IN BIT;
    rdy_out : OUT BIT;
    rfd_in : IN BIT;
    rfd_out : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_out_format_rotate_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_out_format_rotate_beh_bv_v1_1 IS

  SIGNAL data_x_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_trans_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_trans_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL rdy_int_vect : BIT_VECTOR(3 DOWNTO 0);
  SIGNAL rdy_tmp: BIT;
  SIGNAL rfd_next: BIT;
  SIGNAL rfd_reg: BIT;
  SIGNAL rfd_tmp: BIT;
  SIGNAL ce_and_rdy : BIT;

  SIGNAL zero_vect : SIGNED(p_data_width-1 downto 0);

BEGIN

  zero_vect <= (OTHERS => '0');

  --generate translated coordinates

  gen_trans : PROCESS(data_x_in, data_y_in, quad_in)
  BEGIN
    CASE quad_in IS
      WHEN "11" =>
        data_x_trans <= data_x_in;
        data_y_trans <= data_y_in;
      WHEN "01" =>
        data_x_trans <= zero_vect - data_y_in;
        data_y_trans <= data_x_in; 
      WHEN "00" =>
        data_x_trans <= zero_vect - data_x_in;
        data_y_trans <= zero_vect - data_y_in;  
      WHEN "10" =>
        data_x_trans <= data_y_in;
        data_y_trans <= zero_vect - data_x_in;
      WHEN OTHERS =>
        data_x_trans <= data_x_in;
        data_y_trans <= data_y_in;
    END CASE;

  END PROCESS gen_trans;

  inst_data_x_trans_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_trans,
    q => data_x_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  inst_data_y_trans_reg : lib_fd_beh_sb_cordic_v1_1
  generic map(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  port map(
    d => data_y_trans,
    q => data_y_trans_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_data_x_out_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_trans_reg,
    q => data_x_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce_and_rdy
  );
  
  inst_data_y_out_reg : lib_fd_beh_sb_cordic_v1_1
  generic map(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  port map(
    d => data_y_trans_reg,
    q => data_y_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce_and_rdy
  );

  --********************************************************
  -- Generate RDY   
  ce_and_rdy <= ce AND rdy_int_vect(2);

  rdy_int_vect(0) <= rdy_in;

  inst_rdy_int_vect : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr,
    p_width => 3
  )
  PORT MAP(
    d => rdy_int_vect(2 DOWNTO 0),
    q => rdy_int_vect(3 DOWNTO 1),
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  PROCESS(rdy_int_vect(3))
  BEGIN
    rdy_tmp <= '1';
    IF (p_has_rdy = 1) THEN
      rdy_tmp <= rdy_int_vect(3);
    END IF;      	
  END PROCESS;
  
  --********************************************************
  -- Generate RFD if p_has_rfd is Selected
  gen_rfd: IF (p_architecture = c_wser_arch) GENERATE

    PROCESS(nd_in,rfd_reg,rfd_in)
    BEGIN
      rfd_next <= '0';
      IF (((nd_in = '0')AND(rfd_reg = '1'))OR(rfd_in = '1')) THEN
        rfd_next <= '1';
      END IF;      	
    END PROCESS;
 
    inst_rfd_tmp : lib_fd1i_beh_bv_cordic_v1_1
    GENERIC MAP(
      p_has_ainit => p_has_aclr,
      p_has_ce => p_has_ce,
      p_has_sinit => p_has_sclr,
      p_init => '1'
    )
    PORT MAP(
      d => rfd_next,
      q => rfd_reg,
      clk => clk,
      ainit => aclr,
      sinit => sclr,
      ce => ce
    );

  END GENERATE;

  rfd_tmp <= '1' WHEN (p_architecture = c_para_arch) ELSE rfd_reg;

data_x_out <= data_x_reg AFTER 1 ns;
data_y_out <= data_y_reg AFTER 1 ns;
rdy_out <= rdy_tmp AFTER 1 ns;
rfd_out <= rfd_tmp AFTER 1 ns;

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_out_format_rotate_beh_v1_1 IS
  GENERIC (
	p_architecture : INTEGER := c_para_arch;    
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0
  );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    rdy_in : IN STD_LOGIC;
    rdy_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;    
    rfd_out : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_out_format_rotate_beh_v1_1;

ARCHITECTURE behav OF cordic_out_format_rotate_beh_v1_1 IS

SIGNAL data_x_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL data_x_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL data_y_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL data_y_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL quad_in_bv : BIT_VECTOR(1 DOWNTO 0);
SIGNAL nd_in_bv : BIT;
SIGNAL rdy_in_bv : BIT;
SIGNAL rdy_out_bv : BIT;
SIGNAL rfd_in_bv : BIT;
SIGNAL rfd_out_bv : BIT;
SIGNAL clk_bv : BIT;
SIGNAL aclr_bv : BIT;
SIGNAL sclr_bv : BIT;
SIGNAL ce_bv : BIT;

BEGIN

  PROCESS(data_x_in,data_x_out_bv,data_y_in,data_y_out_bv,quad_in,
          nd_in,rdy_in,rdy_out_bv,rfd_in,rfd_out_bv,clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    quad_in_bv <= sl_to_bv(quad_in);
    nd_in_bv <= sl_to_b(nd_in);
    rdy_in_bv <= sl_to_b(rdy_in);
    rdy_out <= b_to_sl(rdy_out_bv);
    rfd_in_bv <= sl_to_b(rfd_in);
    rfd_out <= b_to_sl(rfd_out_bv);
    clk_bv <= sl_to_b(clk);
    aclr_bv <= sl_to_b(aclr);	
    sclr_bv <= sl_to_b(sclr);
    ce_bv <= sl_to_b(ce);	
  END PROCESS;

  inst_c_out_fmt_rotate: cordic_out_format_rotate_beh_bv_v1_1
  GENERIC MAP(
	p_architecture => p_architecture,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_x_out => data_x_out_bv,
    data_y_in => data_y_in_bv,
    data_y_out => data_y_out_bv,
    quad_in => quad_in_bv,
    nd_in => nd_in_bv,
    rdy_in => rdy_in_bv,
    rdy_out => rdy_out_bv,
    rfd_in => rfd_in_bv,
    rfd_out => rfd_out_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );	

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_out_format_translate_beh_bv_v1_1 IS
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_width : INTEGER := 16;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
    );
  PORT (
    data_x_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    data_x_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    phase_in : IN SIGNED(p_data_width-1 DOWNTO 0);
    phase_out : OUT SIGNED(p_data_width-1 DOWNTO 0);
    quad_in : IN BIT_VECTOR(1 DOWNTO 0);
    nd_in : IN BIT;  -- Used to reset RFD signal
    rdy_in : IN BIT; -- Data Rdy Pulse In
    rdy_out : OUT BIT; -- Data Rdy Delayed for Block
    rfd_in : IN BIT;
    rfd_out : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_out_format_translate_beh_bv_v1_1;

ARCHITECTURE xilinx OF cordic_out_format_translate_beh_bv_v1_1 IS

  SIGNAL phase_rot : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_rot_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_in_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_reg : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_trans : SIGNED(p_data_width-1 downto 0);
  SIGNAL pha_add_nsub : BIT;
  SIGNAL pha_add_nsub_reg : BIT;
  SIGNAL rdy_int_vect: BIT_VECTOR(3 DOWNTO 0);
  SIGNAL rdy_tmp: BIT;
  SIGNAL rfd_next: BIT;
  SIGNAL rfd_reg: BIT;
  SIGNAL rfd_tmp: BIT;
  SIGNAL ce_and_rdy : BIT;

  FUNCTION f_select_pi_const(rads_const : SIGNED;
                             jrad_const : SIGNED)
                      RETURN SIGNED IS
    VARIABLE pi_tmp : SIGNED(p_data_width-1 DOWNTO 0);
  BEGIN
    pi_tmp := rads_const(c_max_rom_width-1 DOWNTO c_max_rom_width-p_data_width);
    IF (p_phase_format = c_format_sca) THEN
      pi_tmp := jrad_const(c_max_rom_width-1 DOWNTO c_max_rom_width-p_data_width);
    END IF;
    RETURN pi_tmp;
  END;
  CONSTANT c_neg_pi_const : SIGNED(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(SIGNED(sl_to_bv(c_neg_pi_rads_const)),SIGNED(sl_to_bv(c_neg_pi_jrads_const))); 
  CONSTANT c_neg_pi_2_4_const : SIGNED(p_data_width-1 DOWNTO 0) := 
             f_select_pi_const(SIGNED(sl_to_bv(c_neg_pi_2_4_rads_const)),SIGNED(sl_to_bv(c_neg_pi_2_4_jrads_const)));

BEGIN
	
  --generate translated coordinates
  --IF (c_funct_has_port(p_cordic_funct,2) = 1)
  inst_data_x_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_in,
    q => data_x_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  inst_data_x_trans : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => data_x_reg,
    q => data_x_trans,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce_and_rdy
  );
  
  gen_phase_rot : PROCESS(quad_in)
  BEGIN 
    CASE quad_in IS
      WHEN "00" => phase_rot <= c_neg_pi_const;
      WHEN "11" => phase_rot <= (OTHERS => '0');
      WHEN OTHERS => phase_rot <= c_neg_pi_2_4_const ;
    END CASE;
  END PROCESS;

  inst_phase_rot_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_rot,
    q => phase_rot_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  inst_phase_in_reg : lib_fd_beh_sb_cordic_v1_1
  GENERIC MAP(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => phase_in,
    q => phase_in_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  pha_add_nsub <= '1' WHEN ((quad_in(1) = '1') OR ((quad_in(0) = '0') AND (phase_in(p_data_width-1) = '0')))
               ELSE '0';
               
  gen_pha_add_nsub_reg : lib_fd1_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => pha_add_nsub,
    q => pha_add_nsub_reg,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
             
  gen_phase_reg : PROCESS(pha_add_nsub_reg,phase_in_reg,phase_rot_reg)
  BEGIN
    IF (pha_add_nsub_reg = '1') THEN
      phase_reg <= phase_in_reg + phase_rot_reg;	
    ELSE
      phase_reg <= phase_in_reg - phase_rot_reg;
    END IF;
  END PROCESS;
  
  inst_phase_out_reg : lib_fd_beh_sb_cordic_v1_1
  generic map(
    p_width => p_data_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  port map(
    d => phase_reg,
    q => phase_trans,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce_and_rdy
  );

  PROCESS(rdy_int_vect, ce)
  BEGIN
    ce_and_rdy <= '0';
    IF (rdy_int_vect(2) = '1' AND ce = '1') THEN
      ce_and_rdy <= '1';
    END IF;
  END PROCESS;  
  
  --********************************************************
  -- Generate RDY if p_has_rdy is Selected
  rdy_int_vect(0) <= rdy_in;

  inst_rdy_int_vect : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ce => p_has_ce,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr,
    p_width => 3
  )
  PORT MAP(
    d => rdy_int_vect(2 DOWNTO 0),
    q => rdy_int_vect(3 DOWNTO 1),
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );

  PROCESS(rdy_int_vect(3))
  BEGIN
    rdy_tmp <= '1';
    IF (p_has_rdy = 1) THEN
      rdy_tmp <= rdy_int_vect(3);
    END IF;      	
  END PROCESS;
  
  --********************************************************
  -- Generate RFD
  PROCESS(nd_in,rfd_reg,rfd_in)
  BEGIN
    rfd_next <= '0';
    IF (((nd_in = '0')AND(rfd_reg = '1'))OR(rfd_in = '1')) THEN
      rfd_next <= '1';
    END IF;      	
  END PROCESS;

  inst_rfd_tmp : lib_fd1i_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_has_ainit => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sinit => p_has_sclr,
    p_init => '1'
  )
  PORT MAP(
    d => rfd_next,
    q => rfd_reg,
    clk => clk,
    ainit => aclr,
    sinit => sclr,
    ce => ce
  );

  rfd_tmp <= '1' WHEN (p_architecture = c_para_arch) ELSE rfd_reg;

  data_x_out <= data_x_trans AFTER 1 ns;
  phase_out <= phase_trans AFTER 1 ns;
  rdy_out <= rdy_tmp AFTER 1 ns;
  rfd_out <= rfd_tmp AFTER 1 ns;

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;

USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_out_format_translate_beh_v1_1 IS
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := 0;
    p_data_width : INTEGER := 16;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad
    );
  PORT (
    data_x_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 DOWNTO 0);
    quad_in : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
    nd_in : IN STD_LOGIC;
    rdy_in : IN STD_LOGIC;
    rdy_out : OUT STD_LOGIC;
    rfd_in : IN STD_LOGIC;
    rfd_out : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_out_format_translate_beh_v1_1;

ARCHITECTURE xilinx OF cordic_out_format_translate_beh_v1_1 IS

SIGNAL data_x_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL data_x_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL phase_in_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL phase_out_bv : SIGNED(p_data_width-1 DOWNTO 0);
SIGNAL quad_in_bv : BIT_VECTOR(1 DOWNTO 0);
SIGNAL nd_in_bv : BIT;
SIGNAL rdy_in_bv : BIT;
SIGNAL rdy_out_bv : BIT;
SIGNAL rfd_in_bv : BIT;
SIGNAL rfd_out_bv : BIT;
SIGNAL clk_bv : BIT;
SIGNAL aclr_bv : BIT;
SIGNAL sclr_bv : BIT;
SIGNAL ce_bv : BIT;

BEGIN

  PROCESS(data_x_in,data_x_out_bv,phase_in,phase_out_bv,quad_in,
          nd_in,rdy_in,rdy_out_bv,rfd_in,rfd_out_bv,clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
	quad_in_bv <= sl_to_bv(quad_in);
    nd_in_bv <= sl_to_b(nd_in);
    rdy_in_bv <= sl_to_b(rdy_in);
    rdy_out <= b_to_sl(rdy_out_bv);
    rfd_in_bv <= sl_to_b(rfd_in);
    rfd_out <= b_to_sl(rfd_out_bv);
    clk_bv <= sl_to_b(clk);
    aclr_bv <= sl_to_b(aclr);	
    sclr_bv <= sl_to_b(sclr);
    ce_bv <= sl_to_b(ce);	
  END PROCESS;

  inst_c_out_fmt_trans: cordic_out_format_translate_beh_bv_v1_1
  GENERIC MAP(
    p_architecture => p_architecture,
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format
  )
  PORT MAP(
    data_x_in => data_x_in_bv,
    data_x_out => data_x_out_bv,
    phase_in => phase_in_bv,
    phase_out => phase_out_bv,
    quad_in => quad_in_bv,
    nd_in => nd_in_bv,
    rdy_in => rdy_in_bv,
    rdy_out => rdy_out_bv,
    rfd_in => rfd_in_bv,
    rfd_out => rfd_out_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );	

END;  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_rotate_beh_bv_v1_1 IS
  GENERIC (
    p_architecture : INTEGER := c_para_arch; 
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32; --set to output width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode : INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT(
    phase_in : in SIGNED(p_data_width-1 downto 0);
    data_x_init : in SIGNED(p_data_width-1 downto 0);
    data_y_init : in SIGNED(p_data_width-1 downto 0);
    nd : IN BIT;
    data_x_out : OUT SIGNED(p_data_width-1 downto 0);
    data_y_out : OUT SIGNED(p_data_width-1 downto 0);
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_rotate_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_rotate_beh_bv_v1_1 IS

  CONSTANT pi_div_two : SIGNED(32-1 DOWNTO 0)
                      := "00011011011110110010101101100010";
  CONSTANT zero : SIGNED(32-1 DOWNTO 0)
                      := "00000000000000000000000000000000";

  SIGNAL data_x_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_fout : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_fout : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL control_fin : BIT_VECTOR(c_ctrl_width_f_rotate-1 DOWNTO 0);
  SIGNAL control_int : BIT_VECTOR(c_ctrl_width_f_rotate-1 DOWNTO 0);
  SIGNAL dummy_phase_out : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_int : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_int : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL rdy_int : BIT_VECTOR(p_data_width-1 DOWNTO 0);
  SIGNAL rdy_tmp : BIT;
  SIGNAL rfd_fout : BIT;
  SIGNAL rdy_fout : BIT;

BEGIN
  --
  -- Instantiate the Sample_Top Level of design
  --
  -- Translate Initial X,Y Data Vector into First Quadrant
  inst_cordic_inp_format_rotate: cordic_inp_format_rotate_beh_bv_v1_1
  GENERIC MAP (
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format,
    p_reg_inputs => p_reg_inputs
  )
  PORT MAP(
    data_x_in => data_x_init,
    data_y_in => data_y_init,
    phase_in => phase_in,
    data_x_out => data_x_fin,
    data_y_out => data_y_fin,
    phase_out => phase_fin,
    quad_out => control_fin(3 DOWNTO 2),
    nd_in => nd,
    nd_out => control_fin(0),
    rfd_in => rfd_fout,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce     
  );  

  inst_cordic_eng: cordic_eng_beh_bv_v1_1
  GENERIC MAP(
    p_architecture => p_architecture,
    p_cordic_funct => p_cordic_funct,
    p_ctrl_width => c_ctrl_width_f_rotate,
    p_data_extend => p_data_extend,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_mif_file_prefix => "",
    p_phase_format => p_phase_format,
    p_replications => p_replications,
    p_round_mode => p_round_mode,
    p_scale_comp => p_scale_comp
    )
  PORT MAP (
    data_x_in => data_x_fin,
    data_y_in => data_y_fin,
    phase_in => phase_fin,
    data_x_out => data_x_int,
    data_y_out => data_y_int,
    phase_out => dummy_phase_out,
    ctrl_vect_in => control_fin,
    ctrl_vect_out => control_int,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  inst_c_out_format_rotate: cordic_out_format_rotate_beh_bv_v1_1
  GENERIC MAP (
    p_architecture => p_architecture,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    data_x_in => data_x_int,
    data_x_out => data_x_fout,
    data_y_in => data_y_int,
    data_y_out => data_y_fout,
    quad_in => control_int(3 DOWNTO 2),
    nd_in => nd,
    rdy_in => control_int(0),
    rdy_out => rdy_fout,
    rfd_in => control_int(1),
    rfd_out => rfd_fout,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce     
  );  
  
  rdy <= rdy_fout;
  rfd <= rfd_fout;
  data_x_out <= data_x_fout;  
  data_y_out <= data_y_fout;

END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_rotate_beh_v1_1 IS
  GENERIC (
    p_architecture : INTEGER := c_para_arch; 
    p_cordic_funct : INTEGER := c_f_rotate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32; --set to output width
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad;
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode : INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT(
    phase_in : in STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    data_x_init : in STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    data_y_init : in STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    nd : IN STD_LOGIC;
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    data_y_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_rotate_beh_v1_1;

ARCHITECTURE behav OF cordic_rotate_beh_v1_1 IS

  SIGNAL phase_in_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_x_init_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_init_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_bv : BIT;
  SIGNAL data_x_out_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_out_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL rdy_bv : BIT;
  SIGNAL rfd_bv : BIT;
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
 
BEGIN
  
  PROCESS(phase_in,data_x_init,data_y_init,nd,data_x_out_bv,
          data_y_out_bv,rdy_bv,rfd_bv,clk,aclr,sclr,ce)
  BEGIN
    phase_in_bv <= SIGNED(sl_to_bv(phase_in));
    data_x_init_bv <= SIGNED(sl_to_bv(data_x_init));
    data_y_init_bv <= SIGNED(sl_to_bv(data_y_init));
    nd_bv <= sl_to_b(nd);
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    data_y_out <= bv_to_sl(BIT_VECTOR(data_y_out_bv));
    rdy <= b_to_sl(rdy_bv);
    rfd <= b_to_sl(rfd_bv);
    clk_bv <= sl_to_b(clk);
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
    ce_bv <= sl_to_b(ce);	
  END PROCESS;
  
  uut_rotate_beh_bv : cordic_rotate_beh_bv_v1_1
  GENERIC MAP (
    p_architecture => p_architecture, 
    p_cordic_funct => p_cordic_funct,
    p_data_extend => p_data_extend,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_rfd => p_has_rfd,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format, 
    p_pipeline_mode => p_pipeline_mode,
    p_reg_inputs => p_reg_inputs,
    p_replications => p_replications, 
    p_round_mode => p_round_mode,
    p_scale_comp => p_scale_comp
  )
  PORT MAP (
    phase_in => phase_in_bv,
    data_x_init => data_x_init_bv,
    data_y_init => data_y_init_bv,
    nd => nd_bv,
    data_x_out => data_x_out_bv,
    data_y_out => data_y_out_bv,
    rdy => rdy_bv,
    rfd => rfd_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );

END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_translate_beh_bv_v1_1 IS
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode	: INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT(
    data_x_in : in SIGNED(p_data_width-1 downto 0);
    data_y_in : in SIGNED(p_data_width-1 downto 0);
    nd : IN BIT;
    data_x_out : OUT SIGNED(p_data_width-1 downto 0);
    phase_out : OUT SIGNED(p_data_width-1 downto 0);
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT;
    ce : IN BIT
  );
END cordic_translate_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_translate_beh_bv_v1_1 IS

CONSTANT pi_div_two : SIGNED(32-1 DOWNTO 0)
                    := "00011011011110110010101101100010";
CONSTANT zero : SIGNED(32-1 DOWNTO 0)
                    := "00000000000000000000000000000000";

  SIGNAL data_x_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_fin : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_int : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_int : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_int : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_x_fout : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL data_y_fout : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL phase_fout : SIGNED(p_data_width-1 DOWNTO 0);
  SIGNAL control_fin : BIT_VECTOR(c_ctrl_width_f_translate-1 DOWNTO 0);
  SIGNAL control_int : BIT_VECTOR(c_ctrl_width_f_translate-1 DOWNTO 0);
  SIGNAL rdy_int : BIT_VECTOR(p_data_width-1 DOWNTO 0);
  SIGNAL rdy_tmp : BIT;
  SIGNAL rfd_fout : BIT;
  SIGNAL rdy_fout : BIT;

BEGIN
  --
  -- Instantiate the Sample_Top Level of design
  --
  --SETUP DEFAULTS
  phase_fin <= (OTHERS => '0');
  --

  -- Translate Initial X,Y Data Vector into First Quadrant
  inst_cordic_inp_format_translate : cordic_inp_format_translate_beh_bv_v1_1
  GENERIC MAP (
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format,
    p_reg_inputs => p_reg_inputs
  )
  PORT MAP(
    data_x_in => data_x_in,
    data_y_in => data_y_in,
    data_x_out => data_x_fin,
    data_y_out => data_y_fin,
    quad_out => control_fin(3 DOWNTO 2),
    nd_in => nd,
    nd_out => control_fin(0),
    rfd_in => rfd_fout,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce     
  );  

  gen_cordic_eng: cordic_eng_beh_bv_v1_1
  GENERIC MAP(
    p_architecture => p_architecture,
    p_cordic_funct => p_cordic_funct,
    p_ctrl_width => c_ctrl_width_f_translate,
    p_data_extend => p_data_extend,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_mif_file_prefix => "",
    p_phase_format => p_phase_format,
    p_replications => p_replications,
    p_round_mode => p_round_mode,
    p_scale_comp => p_scale_comp
    )
  PORT MAP (
    data_x_in => data_x_fin,
    data_y_in => data_y_fin,
    phase_in => phase_fin,
    data_x_out => data_x_int,
    data_y_out => data_y_int,
    phase_out => phase_int,
    ctrl_vect_in => control_fin,
    ctrl_vect_out => control_int,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce
  );
  
  gen_cordic_out_format_translate: cordic_out_format_translate_beh_bv_v1_1
  GENERIC MAP (
    p_architecture => p_architecture,
    p_cordic_funct => p_cordic_funct,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format
  )
  PORT MAP(
    data_x_in => data_x_int,
    data_x_out => data_x_fout,
    phase_in => phase_int,
    phase_out => phase_fout,
    quad_in => control_int(3 DOWNTO 2),
    nd_in => nd,
    rdy_in => control_int(0),
    rdy_out => rdy_fout,
    rfd_in => control_int(1),
    rfd_out => rfd_fout,
    clk => clk,
    aclr => aclr,
    sclr => sclr,
    ce => ce     
  );  

  rdy <= rdy_fout;
  rfd <= rfd_fout;
  data_x_out <= data_x_fout;  
  phase_out <= phase_fout;
  
END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_eng_comps_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_eng_comps_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_translate_beh_v1_1 IS
  GENERIC (
    p_architecture	: INTEGER := c_para_arch;
    p_cordic_funct : INTEGER := c_f_translate;
    p_data_extend : INTEGER := 5;
    p_data_width : INTEGER := 32;
    p_enable_rlocs : INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_phase_format : INTEGER := c_format_rad; -- Sets the format of the Phase I/O.
    p_pipeline_mode : INTEGER := c_pipe_max;
    p_reg_inputs : INTEGER := 0;
    p_replications	: INTEGER := c_repl_none;
    p_round_mode	: INTEGER := c_round_pos_neg_inf;
    p_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    data_x_in : in STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    data_y_in : in STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    nd : IN STD_LOGIC;
    data_x_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    phase_out : OUT STD_LOGIC_VECTOR(p_data_width-1 downto 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END cordic_translate_beh_v1_1;

ARCHITECTURE behav OF cordic_translate_beh_v1_1 IS

  SIGNAL data_x_in_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL data_y_in_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL nd_bv : BIT;
  SIGNAL data_x_out_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL phase_out_bv : SIGNED(p_data_width-1 downto 0);
  SIGNAL rdy_bv : BIT;
  SIGNAL rfd_bv : BIT;
  SIGNAL clk_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  SIGNAL ce_bv : BIT;
 
BEGIN
  
  PROCESS(data_x_in,data_y_in,nd,data_x_out_bv,
          phase_out_bv,rdy_bv,rfd_bv,clk,aclr,sclr,ce)
  BEGIN
    data_x_in_bv <= SIGNED(sl_to_bv(data_x_in));
    data_y_in_bv <= SIGNED(sl_to_bv(data_y_in));
    nd_bv <= sl_to_b(nd);
    data_x_out <= bv_to_sl(BIT_VECTOR(data_x_out_bv));
    phase_out <= bv_to_sl(BIT_VECTOR(phase_out_bv));
    rdy <= b_to_sl(rdy_bv);
    rfd <= b_to_sl(rfd_bv);
    clk_bv <= sl_to_b(clk);
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);	
    ce_bv <= sl_to_b(ce);	
  END PROCESS;
  
  uut_cordic_translate : cordic_translate_beh_bv_v1_1
  GENERIC MAP (
    p_architecture => p_architecture, 
    p_cordic_funct => p_cordic_funct,
    p_data_extend => p_data_extend,
    p_data_width => p_data_width,
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_rdy => p_has_rdy,
    p_has_rfd => p_has_rfd,
    p_has_sclr => p_has_sclr,
    p_phase_format => p_phase_format, 
    p_pipeline_mode => p_pipeline_mode,
    p_reg_inputs => p_reg_inputs,
    p_replications => p_replications, 
    p_round_mode => p_round_mode,
    p_scale_comp => p_scale_comp
  )
  PORT MAP (
    data_x_in => data_x_in_bv,
    data_y_in => data_y_in_bv,
    nd => nd_bv,
    data_x_out => data_x_out_bv,
    phase_out => phase_out_bv,
    rdy => rdy_bv,
    rfd => rfd_bv,
    clk => clk_bv,
    aclr => aclr_bv,
    sclr => sclr_bv,
    ce => ce_bv
  );

END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_bit.ALL;
 
LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;

ENTITY cordic_sqrt_beh_bv_v1_1 IS
  GENERIC (
    p_enable_rlocs :INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_input_width : INTEGER := 64;
    p_output_width : INTEGER := 32;
    p_pipeline_mode : INTEGER := 0;
    p_reg_inputs : INTEGER := 0;
    p_round_mode : INTEGER := 1
    );
  PORT (
    data_in : IN BIT_VECTOR(p_input_width-1 DOWNTO 0);
    sqrt_out : OUT BIT_VECTOR(p_output_width-1 DOWNTO 0);
    nd : IN BIT;
    rdy : OUT BIT;
    rfd : OUT BIT;
    clk : IN BIT;
    ce : IN BIT;
    aclr : IN BIT;
    sclr : IN BIT
  );
END cordic_sqrt_beh_bv_v1_1;

ARCHITECTURE behav OF cordic_sqrt_beh_bv_v1_1 IS
  
  CONSTANT c_data_width_int : INTEGER := p_output_width + get_round_ext(p_round_mode);
  FUNCTION f_round_mode_int (round_mode:INTEGER) RETURN INTEGER IS
    VARIABLE rnd_mode_tmp : INTEGER;
  BEGIN
    rnd_mode_tmp := c_round_pos_inf;
    IF round_mode = c_round_truncate THEN
      rnd_mode_tmp := c_round_truncate;	
    END IF;
    RETURN rnd_mode_tmp;
  END;
  CONSTANT c_round_mode_int : INTEGER := f_round_mode_int(p_round_mode);
  
  FUNCTION f_pipeline_mode_int (pipeline_mode:INTEGER) RETURN INTEGER IS
    VARIABLE pipeline_mode_tmp : INTEGER;
  BEGIN
    pipeline_mode_tmp := -2;
    IF pipeline_mode = 0 THEN
      pipeline_mode_tmp := 0;	
    END IF;
    RETURN pipeline_mode_tmp;
  END;
  CONSTANT c_pipeline_mode_int : INTEGER := f_pipeline_mode_int(p_pipeline_mode);
  
  SIGNAL data_in_ext : BIT_VECTOR(p_input_width DOWNTO 0);
  SIGNAL sqrt_trunc_async : BIT_VECTOR(c_data_width_int-1 DOWNTO 0);
  SIGNAL sqrt_round_async : BIT_VECTOR(p_output_width-1 DOWNTO 0);
  SIGNAL sqrt_round : BIT_VECTOR(p_output_width-1 DOWNTO 0);
  SIGNAL sqrt_tmp : BIT_VECTOR(p_output_width-1 DOWNTO 0);
  SIGNAL aclr_int : BIT;
  SIGNAL ce_int : BIT;
  SIGNAL sclr_int : BIT;
  SIGNAL nd_in_reg : BIT;
  SIGNAL nd_int : BIT;
  SIGNAL nd_vect : BIT_VECTOR(0 DOWNTO 0);
  SIGNAL rdy_int : BIT;
  SIGNAL rdy_tmp : BIT;
  SIGNAL rdy_vect : BIT_VECTOR(0 DOWNTO 0);
  SIGNAL ce_and_rdy : BIT;
  
  signal test_delay : INTEGER;
  
BEGIN

  aclr_int <= aclr when (p_has_aclr = 1) else '0';
  ce_int <= ce when (p_has_ce = 1) else '1';
  sclr_int <= sclr when (p_has_sclr = 1) else '0';
  nd_int <= nd when (p_has_nd = 1) else '1';
 
  data_in_ext <= (data_in & '0');
  
  gen_sqrt : PROCESS(data_in_ext)
  BEGIN
    sqrt_trunc_async <= sqrt_ubv(data_in_ext, c_data_width_int);
  END PROCESS;

  gen_sqrt_round : PROCESS(sqrt_trunc_async)
  BEGIN
    sqrt_round_async <= rnd_ubv( sqrt_trunc_async, c_round_mode_int, p_output_width);
  END PROCESS;

test_delay <= get_sqrt_latency(c_para_arch,p_output_width,
                                c_pipeline_mode_int,c_round_mode_int,p_reg_inputs)-1;
  
  inst_sqrt_delay : lib_fifo_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_depth => get_sqrt_latency(c_para_arch,p_output_width,
                                c_pipeline_mode_int,c_round_mode_int,p_reg_inputs)-1,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => p_output_width
  )
  PORT MAP(
    d => sqrt_round_async,
    q => sqrt_round,
    clk => clk,
    ce => ce_int,
    aclr => aclr_int,
    sclr => sclr_int
  );

  nd_vect(0) <= nd;

  inst_nd_int_delay : lib_fifo_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_depth => get_sqrt_latency(c_para_arch,p_output_width,
                                p_pipeline_mode,c_round_mode_int,p_reg_inputs)-1,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_sclr => p_has_sclr,
    p_width => 1
  )
  PORT MAP(
    d => nd_vect,
    q => rdy_vect,
    clk => clk,
    ce => ce_int,
    aclr => aclr_int,
    sclr => sclr_int
  );

  rdy_int <= rdy_vect(0);

  gen_rdy: IF (p_has_rdy = 1) GENERATE
    inst_nd_in_reg : lib_fd1_beh_bv_cordic_v1_1
    GENERIC MAP(
      p_has_ce => p_has_ce,
      p_has_aclr => p_has_aclr,
      p_has_sclr => p_has_sclr
    )
    PORT MAP(
      d => rdy_int,
      q => rdy_tmp,
      clk => clk,
      ce => ce_int,
      aclr => aclr_int,
      sclr => sclr_int
    );
  END GENERATE;

  ce_and_rdy <= ce AND rdy_int;  

  inst_sqrt_out : lib_fd_beh_bv_cordic_v1_1
  GENERIC MAP(
    p_width => p_output_width,
    p_has_ce => 1,
    p_has_aclr => p_has_aclr,
    p_has_sclr => p_has_sclr
  )
  PORT MAP(
    d => sqrt_round,
    q => sqrt_tmp,
    clk => clk,
    aclr => aclr_int,
    sclr => sclr_int,
    ce => ce_and_rdy
  );

  rdy <= rdy_tmp when (p_has_rdy = 1) else '0';
  rfd <= '1' when (p_has_rfd = 1) else '0';
  sqrt_out <= sqrt_tmp;
  
END;

LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_sqrt_beh_v1_1 IS
  GENERIC (
    p_enable_rlocs :INTEGER := 1;
    p_has_aclr : INTEGER := 0;
    p_has_ce : INTEGER := 0;
    p_has_nd : INTEGER := 0;
    p_has_rdy : INTEGER := 0;
    p_has_rfd : INTEGER := 0;
    p_has_sclr : INTEGER := 0;
    p_input_width : INTEGER := 64;
    p_output_width : INTEGER := 32;
    p_pipeline_mode : INTEGER := 0;
    p_reg_inputs : INTEGER := 0;
    p_round_mode : INTEGER := 1
    );
  PORT (
    data_in : IN STD_LOGIC_VECTOR(p_input_width-1 DOWNTO 0);
    sqrt_out : OUT STD_LOGIC_VECTOR(p_output_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
END cordic_sqrt_beh_v1_1;

ARCHITECTURE behav OF cordic_sqrt_beh_v1_1 IS

  SIGNAL data_in_bv : BIT_VECTOR(p_input_width-1 DOWNTO 0);
  SIGNAL sqrt_out_bv : BIT_VECTOR(p_output_width-1 DOWNTO 0);
  SIGNAL nd_bv : BIT;
  SIGNAL rdy_bv : BIT;
  SIGNAL rfd_bv : BIT;
  SIGNAL clk_bv : BIT;
  SIGNAL ce_bv : BIT;
  SIGNAL aclr_bv : BIT;
  SIGNAL sclr_bv : BIT;
  
BEGIN
  
  PROCESS(data_in, sqrt_out_bv, nd, rdy_bv, rfd_bv, clk, ce, aclr, sclr)
  BEGIN
    data_in_bv <= sl_to_bv(data_in);
    sqrt_out <= bv_to_sl(sqrt_out_bv);
    nd_bv <= sl_to_b(nd);
    rdy <= b_to_sl(rdy_bv);
    rfd <= b_to_sl(rfd_bv);
    clk_bv <= sl_to_b(clk);
    ce_bv <= sl_to_b(ce);
    aclr_bv <= sl_to_b(aclr);
    sclr_bv <= sl_to_b(sclr);
  END PROCESS;
  
  inst_cordic_sqrt : cordic_sqrt_beh_bv_v1_1
  GENERIC MAP (
    p_enable_rlocs => p_enable_rlocs,
    p_has_aclr => p_has_aclr,
    p_has_ce => p_has_ce,
    p_has_nd => p_has_nd,
    p_has_rdy => p_has_rdy,
    p_has_rfd => p_has_rfd,
    p_has_sclr => p_has_sclr,
    p_input_width => p_input_width,
    p_output_width => p_output_width,
    p_pipeline_mode => p_pipeline_mode,
    p_reg_inputs => p_reg_inputs,
    p_round_mode => p_round_mode
    )
  PORT MAP(
    data_in => data_in_bv,
    sqrt_out => sqrt_out_bv,
    nd => nd_bv,
    rdy => rdy_bv,
    rfd => rfd_bv,
    clk => clk_bv,
    ce => ce_bv,
    aclr => aclr_bv,
    sclr => sclr_bv
  );

END behav;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.lib_comps_beh_cordic_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.lib_comps_beh_cordic_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_main_beh_v1_1 IS
  GENERIC (
    c_architecture	: INTEGER := c_para_arch; 
    c_cordic_funct : INTEGER := c_f_rotate;
    c_enable_rlocs : INTEGER := 1;
    c_has_aclr : INTEGER := 0;
    c_has_ce : INTEGER := 0;
    c_has_nd : INTEGER := 1;
    c_has_rdy : INTEGER := 0;
    c_has_rfd : INTEGER := 0;
    c_has_sclr : INTEGER := 0;
    c_input_width : INTEGER := 32;
    c_mif_file_prefix : STRING := "cor1";
    c_output_width : INTEGER := 32;
    c_phase_format : INTEGER := c_format_rad;
    c_pipeline_mode : INTEGER := c_pipe_max;
    c_reg_inputs : INTEGER := 0;
    c_replications	: INTEGER := c_repl_opt;
    c_round_mode : INTEGER := c_round_pos_neg_inf;
    c_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    x_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    y_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    phase_in : IN STD_LOGIC_VECTOR(c_input_width-1 DOWNTO 0);
    nd : IN STD_LOGIC;
    x_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    y_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    aclr : IN STD_LOGIC;
    sclr : IN STD_LOGIC
  );
END cordic_main_beh_v1_1;

ARCHITECTURE behave OF cordic_main_beh_v1_1 IS
   
  CONSTANT c_data_width : INTEGER := c_output_width;

--  FUNCTION f_slice_width RETURN INTEGER IS
--    VARIABLE f_slice_tmp : INTEGER;
--  BEGIN
--    IF (c_architecture = c_wser_arch) THEN
--      IF (c_replications = c_repl_none) THEN
--        f_slice_tmp := c_output_width;
--      ELSE -- (c_replications = c_repl_opt) THEN
--      	f_slice_tmp := c_wser_slice_opt;
--      END IF;
--    ELSE
--      f_slice_tmp := 1;
--    END	IF;
--    RETURN f_slice_tmp;
--  END f_slice_width;
--  CONSTANT c_slice_width :INTEGER := f_slice_width; 
--  
--  FUNCTION f_rep_count RETURN INTEGER IS
--  BEGIN
--    RETURN (((c_output_width-1)/c_slice_width)+1);
--  END;
--  CONSTANT c_rep_count :INTEGER := f_rep_count; 
--
  CONSTANT c_data_extend : INTEGER := f_get_data_extend_length(c_output_width);
--  CONSTANT c_rom_depth : INTEGER := ( ((c_slice_width+c_rom_block_depth-1) / 
--                                        c_rom_block_depth) * c_rom_block_depth);
--  CONSTANT c_rom_width : INTEGER := c_data_width+c_data_extend;
--  
  CONSTANT c_inv_scale : STD_LOGIC_VECTOR :=
         f_inv_cordic_scale_coeff_slv(c_data_width,c_cordic_funct);
 
  SIGNAL nd_int : STD_LOGIC;
  SIGNAL clk_int : STD_LOGIC;
  SIGNAL ce_int : STD_LOGIC;
  SIGNAL aclr_int : STD_LOGIC;
  SIGNAL sclr_int : STD_LOGIC;

  SIGNAL data_x_int : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL data_y_int : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL phase_int : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);

  SIGNAL data_x_int_rotate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL data_y_int_rotate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL phase_int_rotate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);

  SIGNAL data_x_rotate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL data_y_rotate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL rdy_rotate : STD_LOGIC;
  SIGNAL rfd_rotate : STD_LOGIC;
  SIGNAL data_x_translate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL phase_translate : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL rdy_translate : STD_LOGIC;
  SIGNAL rfd_translate : STD_LOGIC;
  SIGNAL data_x_sqrt : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  SIGNAL rdy_sqrt : STD_LOGIC;
  SIGNAL rfd_sqrt : STD_LOGIC;
                          
  SIGNAL atan_rom_data : STD_LOGIC_VECTOR(c_max_rom_width*c_max_rom_length-1 DOWNTO 0);  

  SIGNAL zero_vect : STD_LOGIC_VECTOR(c_output_width-1 DOWNTO 0);
  
--  SUBTYPE rom_data_vect_row_type IS STD_LOGIC_VECTOR(c_rom_depth*c_rom_width-1 DOWNTO 0);
--  TYPE rom_data_vect_type IS ARRAY(0 to c_rep_count-1) OF rom_data_vect_row_type;
--         
--  SUBTYPE int_data_vect_row_type IS STD_LOGIC_VECTOR(c_rom_width-1 DOWNTO 0);
--  TYPE int_data_vect_type IS ARRAY(0 to c_rep_count*c_rom_depth-1) OF int_data_vect_row_type;
--
--  SIGNAL int_data_vect : int_data_vect_type;
--  SIGNAL rnd_data_vect : int_data_vect_type;
--  SIGNAL rom_data_vect : rom_data_vect_type;
--    
--  SIGNAL data_written : INTEGER;
  
BEGIN

  gen_aclr_0 : IF (c_has_aclr = 0) GENERATE
    aclr_int <= '0';
  END GENERATE;
  gen_aclr_1 : IF (c_has_aclr = 1) GENERATE
    aclr_int <= aclr;
  END GENERATE;

  gen_ce_0 : IF (c_has_ce = 0) GENERATE
    ce_int <= '1';
  END GENERATE;
  gen_ce_1 : IF (c_has_ce = 1) GENERATE
    ce_int <= ce;
  END GENERATE;

  gen_nd_0 : IF (c_has_nd = 0) GENERATE
    nd_int <= '1';
  END GENERATE;
  gen_nd_1 : IF (c_has_nd = 1) GENERATE
    nd_int <= nd;
  END GENERATE;

  gen_sclr_0 : IF (c_has_sclr = 0) GENERATE
    sclr_int <= '0';
  END GENERATE;
  gen_sclr_1 : IF (c_has_sclr = 1) GENERATE
    sclr_int <= sclr;
  END GENERATE;

  gen_rom_data_trig: IF ((c_cordic_funct = c_f_sin_cos) OR 
                         (c_cordic_funct = c_f_atan) OR
                         (c_cordic_funct = c_f_rotate) OR 
                         (c_cordic_funct = c_f_translate)
                        ) GENERATE
    gen_rad: IF (c_phase_format = c_format_rad) GENERATE
      atan_rom_data <= c_atan_rads;
    END GENERATE;
    gen_sca: IF (c_phase_format = c_format_sca) GENERATE
      atan_rom_data <= c_atan_jrads;
    END GENERATE;
  END GENERATE;
  gen_rom_data_hyp: IF ((c_cordic_funct = c_f_sinh_cosh) OR 
                          (c_cordic_funct = c_f_atanh)) GENERATE
    gen_rad: IF (c_phase_format = c_format_rad) GENERATE
      atan_rom_data <= c_atanh_rads;
    END GENERATE;
    gen_sca: IF (c_phase_format = c_format_sca) GENERATE
      atan_rom_data <= c_atanh_jrads;
    END GENERATE;
  END GENERATE;  

--  --gen atan_rom_vect
--  gen_rom_file: IF (c_architecture = c_wser_arch) GENERATE
--    gen_reps : FOR I IN 0 TO c_rep_count-1 GENERATE
--        int_data_vect(I*C_ROM_DEPTH)(c_rom_width-1 DOWNTO 0) <= atan_rom_data(
--		c_slice_width*c_max_rom_width*I + c_max_rom_width*f_slice_depth(I) -2 DOWNTO
--		c_slice_width*c_max_rom_width*I + c_max_rom_width*f_slice_depth(I) - c_rom_width -1);
--      gen_rom_slice : FOR J IN 0 TO c_rom_depth-2 GENERATE
--        int_data_vect(I*C_ROM_DEPTH+J+1)(c_rom_width-1 DOWNTO 0) <= sl_to_bv(atan_rom_data(
--		c_slice_width*c_max_rom_width*I + c_max_rom_width*(J+1) -2 DOWNTO
--		c_slice_width*c_max_rom_width*I + c_max_rom_width*(J+1) - c_rom_width -1));
--      END GENERATE;--gen rom_slice 
--      gen_rom_rnd : FOR J IN 0 TO c_rom_depth-1 GENERATE
--        rnd_data_vect(I*C_ROM_DEPTH+J) <= 
--          rnd_sbv(int_data_vect(I*C_ROM_DEPTH+J),c_round_pos_neg_inf,c_rom_width);
--        rom_data_vect(I)(J*c_rom_width+c_rom_width-1 DOWNTO J*c_rom_width) <=  
--          rnd_data_vect(I*C_ROM_DEPTH+J)(c_rom_width-1 DOWNTO 0);
--      END GENERATE;--gen_rom_rnd
--    END GENERATE;-- gen_reps
--  END GENERATE;--gen_rom_files
--
  zero_vect <= set_vect_sl(zero_vect, '0');
  
  gen_data_in : FOR I IN 0 TO c_output_width-1 GENERATE
    gen_pad_top: IF (c_input_width -1 - I >= 0) GENERATE
      data_x_int(c_output_width - 1 - I) <= x_in(x_in'high - I);
      data_y_int(c_output_width - 1 - I) <= y_in(y_in'high - I);
      phase_int(c_output_width - 1 - I) <= phase_in(phase_in'high - I);
    END GENERATE;
    gen_pad_bot: IF (c_input_width -1 - I < 0) GENERATE
      data_x_int(c_output_width - 1 - I) <= '0';
      data_y_int(c_output_width - 1 - I) <= '0';
      phase_int(c_output_width - 1 - I) <= '0';
    END GENERATE;
  END GENERATE;

  gen_sin_cos_sig_init : IF (c_cordic_funct = c_f_sin_cos) GENERATE
    data_x_int_rotate <= c_inv_scale;
    data_y_int_rotate <= zero_vect;
    phase_int_rotate <= phase_int;
  END GENERATE;
  gen_sinh_cosh_sig_init : IF (c_cordic_funct = c_f_sinh_cosh) GENERATE
    data_x_int_rotate <= c_inv_scale;
    data_y_int_rotate <= zero_vect;
    phase_int_rotate <= phase_int;
  END GENERATE;
  gen_tan_sig_init : IF ((c_cordic_funct = c_f_atan) OR
                            (c_cordic_funct = c_f_atanh)) GENERATE
    data_x_int_rotate <= data_x_int;
    data_y_int_rotate <= data_y_int;
    phase_int_rotate <= zero_vect;
  END GENERATE;
  gen_data_sig_init : IF ((c_cordic_funct /= c_f_sin_cos) AND (c_cordic_funct /= c_f_sinh_cosh) AND
               (c_cordic_funct /= c_f_atan) AND (c_cordic_funct /= c_f_atanh)) GENERATE
    data_x_int_rotate <= data_x_int;
    data_y_int_rotate <= data_y_int;
    phase_int_rotate <= phase_int;
  END GENERATE;
    
  gen_cordic_rotate: IF ((c_cordic_funct = c_f_rotate) OR
                         (c_cordic_funct = c_f_sin_cos) OR
                         (c_cordic_funct = c_f_sinh_cosh)) GENERATE

    inst_cordic_rotate : cordic_rotate_beh_v1_1
    GENERIC MAP (
      p_architecture => c_architecture,
      p_cordic_funct => c_cordic_funct,
      p_data_extend => c_data_extend,
      p_data_width => c_data_width,
      p_enable_rlocs => c_enable_rlocs,
      p_has_aclr => c_has_aclr,
      p_has_ce => c_has_ce,
      p_has_rdy => c_has_rdy,
      p_has_rfd => c_has_rfd,
      p_has_sclr => c_has_sclr,
      p_phase_format => c_phase_format,
      p_pipeline_mode => c_pipeline_mode,
      p_reg_inputs => c_reg_inputs,
      p_replications => c_replications,
      p_round_mode => c_round_mode,
      p_scale_comp => c_scale_comp
      )
    PORT MAP(
      phase_in => phase_int_rotate,
      data_x_init => data_x_int_rotate,
      data_y_init => data_y_int_rotate,
      nd => nd_int,
      data_x_out => data_x_rotate,
      data_y_out => data_y_rotate,
      rdy => rdy_rotate,
      rfd => rfd_rotate,
      clk => clk,
      aclr => aclr_int,
      sclr => sclr,
      ce => ce_int
    ); 
  END GENERATE;
  
  gen_cordic_translate: IF ((c_cordic_funct = c_f_translate) OR
                            (c_cordic_funct = c_f_atan)       OR 
                            (c_cordic_funct = c_f_atanh))	  GENERATE
  
    inst_cordic_translate : cordic_translate_beh_v1_1
    GENERIC MAP (
      p_architecture => c_architecture,
      p_cordic_funct => c_cordic_funct,
      p_data_extend => c_data_extend,
      p_data_width => c_data_width,
      p_enable_rlocs => c_enable_rlocs,
      p_has_aclr => c_has_aclr,
      p_has_ce => c_has_ce,
      p_has_rdy => c_has_rdy,
      p_has_rfd => c_has_rfd,
      p_has_sclr => c_has_sclr,
      p_phase_format => c_phase_format,
      p_pipeline_mode => c_pipeline_mode,
      p_reg_inputs => c_reg_inputs,
      p_replications => c_replications,
      p_round_mode => c_round_mode,
      p_scale_comp => c_scale_comp
      )
    PORT MAP(
      data_x_in => data_x_int,
      data_y_in => data_y_int,
      nd => nd_int,
      data_x_out => data_x_translate,
      phase_out => phase_translate,
      rdy => rdy_translate,
      rfd => rfd_translate,
      clk => clk,
      aclr => aclr_int,
      sclr => sclr,
      ce => ce_int
    ); 
  END GENERATE;
  
  gen_cordic_sqrt: IF (c_cordic_funct = c_f_sqrt) GENERATE

  inst_cordic_sqrt : cordic_sqrt_beh_v1_1
    GENERIC MAP (
      p_enable_rlocs => c_enable_rlocs,
      p_has_aclr => c_has_aclr,
      p_has_ce => c_has_ce,
      p_has_nd => c_has_nd,
      p_has_rdy => c_has_rdy,
      p_has_rfd => c_has_rfd,
      p_has_sclr => c_has_sclr,
      p_input_width => c_input_width,
      p_output_width => c_output_width,
      p_pipeline_mode => c_pipeline_mode,
      p_reg_inputs => c_reg_inputs,
      p_round_mode => c_round_mode
      )
    PORT MAP(
      data_in => x_in,
      sqrt_out => data_x_sqrt,
      nd => nd_int,
      rdy => rdy_sqrt,
      rfd => rfd_sqrt,
      clk => clk,
      aclr => aclr_int,
      sclr => sclr,
      ce => ce_int
    );
  END GENERATE;

  gen_output_sig_rotate: IF ((c_cordic_funct = c_f_rotate) OR
                         (c_cordic_funct = c_f_sin_cos) OR
                         (c_cordic_funct = c_f_sinh_cosh)) GENERATE
    x_out <= data_x_rotate;
    y_out <= data_y_rotate;
    gen_rdy: IF (c_has_rdy = 1) GENERATE
      rdy <= rdy_rotate;
    END GENERATE;
    gen_rfd: IF (c_has_rfd = 1) GENERATE
      rfd <= rfd_rotate;
    END GENERATE;
  END GENERATE;

  gen_output_sig_translate: IF (c_cordic_funct = c_f_translate) GENERATE
    x_out <= data_x_translate;
    phase_out <= phase_translate;
    gen_rdy: IF (c_has_rdy = 1) GENERATE
      rdy <= rdy_translate;
    END GENERATE;
    gen_rfd: IF (c_has_rfd = 1) GENERATE
      rfd <= rfd_translate;
    END GENERATE;
  END GENERATE;

  gen_output_sig_atan: IF ((c_cordic_funct = c_f_atan)       OR 
                            (c_cordic_funct = c_f_atanh))	  GENERATE
    phase_out <= phase_translate;
    gen_rdy: IF (c_has_rdy = 1) GENERATE
      rdy <= rdy_translate;
    END GENERATE;
    gen_rfd: IF (c_has_rfd = 1) GENERATE
      rfd <= rfd_translate;
    END GENERATE;
  END GENERATE;

  gen_output_sig_sqrt: IF (c_cordic_funct = c_f_sqrt)	  GENERATE
    x_out <= data_x_sqrt;
    gen_rdy: IF (c_has_rdy = 1) GENERATE
      rdy <= rdy_sqrt;
    END GENERATE;
    gen_rfd: IF (c_has_rfd = 1) GENERATE
      rfd <= rfd_sqrt;
    END GENERATE;
  END GENERATE;

END Behave;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY XilinxCoreLib;
USE XilinxCoreLib.prims_constants_v5_0.ALL;
 
USE XilinxCoreLib.cordic_pack_v1_1.ALL;
USE XilinxCoreLib.cordic_pack_beh_v1_1.ALL;
USE XilinxCoreLib.cordic_main_comps_beh_v1_1.ALL;
--USE work.cordic_pack_v1_1.ALL;
--USE work.cordic_pack_beh_v1_1.ALL;
--USE work.cordic_main_comps_beh_v1_1.ALL;

ENTITY cordic_v1_1 IS
  GENERIC (
    c_architecture	: INTEGER := c_para_arch; 
    c_cordic_function : INTEGER := c_f_rotate;
    c_enable_rlocs : INTEGER := 1;
    c_has_aclr : INTEGER := 0;
    c_has_ce : INTEGER := 0;
    c_has_phase_in : INTEGER := 0;
    c_has_phase_out : INTEGER := 0;
    c_has_rdy : INTEGER := 0;
    c_has_rfd : INTEGER := 0;
    c_has_sclr : INTEGER := 0;
    c_has_x_in : INTEGER := 0;
    c_has_x_out : INTEGER := 0;
    c_has_y_in : INTEGER := 0;
    c_has_y_out : INTEGER := 0;
    c_input_width : INTEGER := 16;
    c_mif_file_prefix : STRING := "cor1";
    c_output_width : INTEGER := 16;
    c_phase_format : INTEGER := c_format_rad;
    c_pipeline_mode : INTEGER := c_pipe_max;
    c_reg_inputs : INTEGER := 0;
    c_replications	: INTEGER := c_repl_none;
    c_round_mode : INTEGER := c_round_pos_neg_inf;
    c_scale_comp : INTEGER := c_scale_none
    );
  PORT (
    x_in : in STD_LOGIC_VECTOR(c_input_width-1 downto 0) := (OTHERS => 'Z');
    y_in : in STD_LOGIC_VECTOR(c_input_width-1 downto 0) := (OTHERS => 'Z');
    phase_in : in STD_LOGIC_VECTOR(c_input_width-1 downto 0) := (OTHERS => 'Z');
    nd : IN STD_LOGIC := '1';
    x_out : OUT STD_LOGIC_VECTOR(c_output_width-1 downto 0);
    y_out : OUT STD_LOGIC_VECTOR(c_output_width-1 downto 0);
    phase_out : OUT STD_LOGIC_VECTOR(c_output_width-1 downto 0);
    rdy : OUT STD_LOGIC;
    rfd : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC := '1';
    aclr : IN STD_LOGIC := '0';
    sclr : IN STD_LOGIC := '0'
  );
END cordic_v1_1;

ARCHITECTURE behavioral OF cordic_v1_1 IS

BEGIN
  --
  -- Instantiate the Sample_Top Level of design
  --
  
  c1 : cordic_main_beh_v1_1
  GENERIC MAP(
    c_architecture => c_architecture, 
    c_cordic_funct => c_cordic_function,
    c_enable_rlocs =>	c_enable_rlocs,
    c_has_aclr => c_has_aclr,
    c_has_ce => c_has_ce,
    c_has_nd => 1,
    c_has_rdy => c_has_rdy,
    c_has_rfd => c_has_rfd,
    c_has_sclr => c_has_sclr,
    c_input_width => c_input_width,
    c_mif_file_prefix => c_mif_file_prefix,
    c_output_width => c_output_width,
    c_phase_format => c_phase_format,
    c_pipeline_mode => c_pipeline_mode,
    c_reg_inputs => c_reg_inputs,
    c_replications	=> c_replications,
    c_round_mode => c_round_mode,
    c_scale_comp => c_scale_comp
    )
  PORT MAP(
    x_in => x_in,
    y_in => y_in,
    phase_in => phase_in,
    nd => nd,
    x_out => x_out,
    y_out => y_out,
    phase_out => phase_out,
    rdy => rdy,
    rfd => rfd,
    clk => clk,
    ce => ce,
    aclr => aclr,
    sclr => sclr
  );
  
END behavioral;


