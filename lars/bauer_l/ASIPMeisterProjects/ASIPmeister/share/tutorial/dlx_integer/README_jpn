##############################################
#  dlx integer アセンブリ・コーディング 情報 #
##############################################

1. アセンブリコード のオペランド順序


1.1 レジスタ-レジスタ形式の命令  ( ADD,SUB,SLL ... etc )
       
   A:  アセンブリコードでは，
       「命令名  ディスティネーション，ソース０，ソース１」
         例： ADD %r10,%r1,%r2   ( 動作： r10 = r1 + r2 )

   B:  ASIP Meister で定義した命令形式では，
       「オペコード ソース０ ソース１ ディスティネーション オペコード」
         例： ADD-opecode r1 r2 r10 Add-opecode

       *メタアセンブラによって，A → B の変換を行なう


1.2 レジスタ-即値形式の命令  ( ADDI,SUBI,SLLI ... etc )
       
   A:  アセンブリコードでは，
       「命令名  ディスティネーション，ソース０，即値」
         例： ADDI %r10,%r1,$7   ( 動作： r10 = r1 + 7 )

   B:  ASIP Meister で定義した命令形式では，
       「オペコード ソース０ ディスティネーション 即値」
         例： ADD-opecode r1 r10 7

       *メタアセンブラによって，A → B の変換を行なう


1.3 メモリアクセスの命令 ( SW,LW,SB ... etc )

   A:  アセンブリコードでは，
       「命令名  ソース０，即値(ソース１)」
         例： SW %r10,20(%r1)   ( 動作： r10 = MEM[r1 + 20] )

   B:  ASIP Meister で定義した命令形式では，
       「オペコード ソース０ ソース１ ディスティネーション」
         例： SW-opecode r10 r1 20 

       *メタアセンブラによって，A → B の変換を行なう


1.4 分岐の命令 ( BEQZ,BNEZ )

   A:  アセンブリコードでは，
       「命令名  ソース０，ラベル」
         例： L1  ...
                  ...
                  BEQZ %r1,$L1   
              L2  ...
              ( 動作： if (r1 == 0) then {jump to L1})

   B:  ASIP Meister で定義した命令形式では，
       「オペコード ソース０ 使用せず 即値」
         例： BEQZ-opecode  r1  使用せず  アドレス・オフセット

       *メタアセンブラによって，A → B の変換を行なう
