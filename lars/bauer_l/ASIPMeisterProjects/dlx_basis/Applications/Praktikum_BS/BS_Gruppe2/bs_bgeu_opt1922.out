****** Source Program List ******
LineNo	LC	Code		Source Program 
1				.addressing	Word
2				.section	.text
3			_main:
4				; Initialize Stack Pointer
5	0000	3c1d0000		lhi	%r29, $(((1024-4)*65536)&0xffff)	; MemSize is 1024
6	0001	00000000		nop
7	0002	00000000		nop
8	0003	00000000		nop
9	0004	27bd03fc		addui	%r29, %r29, $((1024-4)&0xffff)
10	0005	00000000		nop
11	0006	00000000		nop
12	0007	00000000		nop
13	0008	2bbd000c		subi	%r29, %r29, $12		; Adjust Stack Pointer
14	0009	00000000		nop
15	000a	00000000		nop
16	000b	00000000		nop
17	000c	afbe0000		sw	0(%r29), %r30		; Save the old frame pointer
18	000d	afbf0004		sw	4(%r29), %r31		; Save the return address
19	000e	afa10008		sw	8(%r29), %r1		; Save r1, which is used in main.
20	000f	001df020		add	%r30, %r0, %r29		; Establish new frame pointer
21			
22				; Call BubbleSort
23	0010	2bbd0008		subi	%r29, %r29, $8		; create place for the parameters
24	0011	00000000		nop
25	0012	00000000		nop
26	0013	00000000		nop
27	0014	afa00000		sw	0(%r29), %r0		; "const unsigned int startIndex"
28	0015	20010013		addi	%r1, %r0, $19
29	0016	00000000		nop
30	0017	00000000		nop
31	0018	00000000		nop
32	0019	afa10004		sw	4(%r29), %r1		; "const unsigned int endIndex"
33	001a	0c00000c		jal	_bubbleSort
34	001b	00000000		nop
35	001c	23bd0008		addi	%r29, %r29, $8
36			
37	001d	00000000		nop
38	001e	00000000		nop
39	001f	00000000		nop
40	0020	8fbe0000		lw	%r30, 0(%r29)		; Restore frame pointer
41	0021	8fbf0004		lw	%r31, 4(%r29)		; Restore return address
42	0022	8fa10008		lw	%r1,  8(%r29)		; Restore r1
43	0023	001ee820		add	%r29, %r0, %r30		; Restore stack pointer
44			
45				; HALT
46	0024	0c000062		jal	_exit
47	0025	00000000		nop
48			
49			
50			; *****************************************************************************************
51			
52			_bubbleSort:
53	0026	001df020		add	%r30, %r0, %r29		; Establish new frame pointer 
54	0027	2bbd0030		subi	%r29, %r29, $(8 + 10*4)	; Adjust Stack Pointer; 8 for oldFP+RET and x*4 for saved Registers
55			
56	0028	00000000		nop
57	0029	00000000		nop
58	002a	00000000		nop
59			
60	002b	afbe0000		sw	0(%r29), %r30		; Save the frame pointer 
61	002c	afbf0004		sw	4(%r29), %r31		; Save the return address 
62			
63				; Save Registers 
64	002d	3c010000		lhi	%r1, $(_array*65536)&0xffff
65	002e	8fc20000		lw	%r2, 0(%r30)
66	002f	8fc30004		lw	%r3, 4(%r30)
67	0030	afa10008		sw	 8(%r29), %r1		; r1 is used for comparing-results and for temporary stuff.
68	0031	afa2000c		sw	12(%r29), %r2		; r2 is the parameter value "startIndex". (later "innerLoopStart")
69	0032	afa30010		sw	16(%r29), %r3		; r3 is the parameter value "endIndex".	(later "innerLoopEnd")
70	0033	40630002		slli	%r3,%r3,$2
71	0034	24210000		addui	%r1, %r1, $(_array&0xffff)
72	0035	40420002		slli	%r2,%r2,$2
73	0036	afa80024		sw	36(%r29), %r8		; r8 is "value_j".
74	0037	24630004		addui	%r3,%r3,$4		; innerLoopEnd++;
75	0038	afa50018		sw	24(%r29), %r5		; r5 is the loop-variable "j".
76	0039	00411021		addu	%r2,%r2,%r1
77	003a	afa70020		sw	32(%r29), %r7		; r7 is "variable_xchanged".
78	003b	00611821		addu	%r3,%r3,%r1
79	003c	20070001		addi 	%r7,%r0,$1
80			
81	003d	08000003		j	while1_start
82	003e	afa90028		sw	40(%r29), %r9		; r9 is "value_next_j".
83				;nop
84			
85			while1_save_start:
86	003f	aca10000		sw	0(%r5),%r1	;       *next_j = value_j;	
87			
88			while1_start:
89	0040	00022821		addu	%r5,%r0,%r2	; j = innerLoopStart
90	0041	2c630004		subui	%r3,%r3,$4	; innerLoopEnd--;
91	0042	10e00038		beqz	%r7, while1_end
92	0043	00003820		add	%r7,%r0,%r0
93			
94	0044	8ca80000		lw	%r8,0(%r5)	;   value_j = *j;
95			
96			while2_mit_r7_start:
97	0045	8ca90004		lw	%r9,4(%r5)	;     value_next_j = *next_j;
98	0046	f8a3fffa		bgeu	%r5,%r3,while1_start	;   while (j < innerLoopEnd) {
99	0047	24a50004		addui	%r5,%r5,$4	;     j++;
100	0048	00080821		addu	%r1,%r0,%r8	;       tmp = value_j;
101	0049	f928fffc		bgeu	%r9,%r8,while2_mit_r7_start	;     if (value_next_j < value_j) {
102	004a	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
103			
104			;	addu	%r8,%r0,%r1	;       value_j = tmp;
105			;	sw	0(%r5),%r8	;       *next_j = value_j;
106	004b	8ca90004		lw	%r9,4(%r5)
107	004c	f8a3fff3		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
108	004d	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
109			
110	004e	0800000c		j	while2_x_start	;   }
111	004f	20070001		addi	%r7,%r0,$1
112			;	nop
113			
114			while2_save_start:
115	0050	aca1fffc		sw	-4(%r5),%r1	;       *next_j = value_j;	
116			
117			while2_start:
118	0051	8ca90004		lw	%r9,4(%r5)	;     value_next_j = *next_j;
119	0052	f8a3ffee		bgeu	%r5,%r3,while1_start	;   while (j < innerLoopEnd) {
120	0053	24a50004		addui	%r5,%r5,$4	;     j++;
121	0054	00080821		addu	%r1,%r0,%r8	;       tmp = value_j;
122	0055	f928fffc		bgeu	%r9,%r8,while2_start	;     if (value_next_j < value_j) {
123	0056	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
124			
125	0057	8ca90004		lw	%r9,4(%r5)	;     value_next_j = *next_j;
126	0058	f8a3ffe7		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
127	0059	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
128			
129			while2_x_start:
130	005a	24a50004		addui	%r5,%r5,$4	;     j++;
131	005b	f921fff5		bgeu	%r9,%r1,while2_save_start	;     if (value_next_j < value_j) {
132	005c	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
133			
134	005d	8ca90008		lw	%r9,8(%r5)	;     value_next_j = *next_j;
135	005e	f8a3ffe1		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
136	005f	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
137			
138			
139	0060	24a50004		addui	%r5,%r5,$4	;     j++;
140	0061	f921ffef		bgeu	%r9,%r1,while2_save_start	;     if (value_next_j < value_j) {
141	0062	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
142			
143	0063	8ca90008		lw	%r9,8(%r5)	;     value_next_j = *next_j;
144	0064	f8a3ffdb		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
145	0065	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
146			
147			
148	0066	24a50004		addui	%r5,%r5,$4	;     j++;
149	0067	f921ffe9		bgeu	%r9,%r1,while2_save_start	;     if (value_next_j < value_j) {
150	0068	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
151			
152	0069	8ca90008		lw	%r9,8(%r5)	;     value_next_j = *next_j;
153	006a	f8a3ffd5		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
154	006b	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
155			
156			
157	006c	24a50004		addui	%r5,%r5,$4	;     j++;
158	006d	f921ffe3		bgeu	%r9,%r1,while2_save_start	;     if (value_next_j < value_j) {
159	006e	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
160			
161	006f	8ca90008		lw	%r9,8(%r5)	;     value_next_j = *next_j;
162	0070	f8a3ffcf		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
163	0071	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
164			
165			
166	0072	24a50004		addui	%r5,%r5,$4	;     j++;
167	0073	f921ffdd		bgeu	%r9,%r1,while2_save_start	;     if (value_next_j < value_j) {
168	0074	00094021		addu	%r8,%r0,%r9	;       value_j = value_next_j;
169			
170	0075	8ca90008		lw	%r9,8(%r5)	;     value_next_j = *next_j;
171	0076	f8a3ffc9		bgeu	%r5,%r3,while1_save_start	;   while (j < innerLoopEnd) {
172	0077	aca9fffc		sw	-4(%r5),%r9	;       *j = value_next_j;
173			
174			
175	0078	0bffffe2		j	while2_x_start	;   }
176	0079	00000000		nop
177				
178			
179			while1_end:
180			
181			
182			; *****************************************************************************************
183			
184	007a	8fbe0000		lw	%r30, 0(%r29)		; Restore frame pointer
185	007b	8fbf0004		lw	%r31, 4(%r29)		; Restore return address
186			
187				; Restore the saved registers
188	007c	8fa10008		lw	%r1, 8(%r29)
189	007d	8fa2000c		lw	%r2, 12(%r29)
190	007e	8fa30010		lw	%r3, 16(%r29)
191			;	lw	%r4, 20(%r29)
192	007f	8fa50018		lw	%r5, 24(%r29)
193			;	lw	%r6, 28(%r29)
194	0080	8fa70020		lw	%r7, 32(%r29)
195	0081	8fa80024		lw	%r8, 36(%r29)
196	0082	8fa90028		lw	%r9, 40(%r29)
197			;	lw	%r10,48(%r29)
198			
199	0083	001ee820		add	%r29, %r0, %r30		; Restore stack pointer
200			
201				; Return
202	0084	03e00008		jr	%r31
203	0085	00000000		nop
204			
205			
206	0086	00000000	_exit:	nop
207	0087	00000000		nop
208			
209			
210				.section	.data
211			_array:
212	0000	0000002d		.data.32	45
213	0004	0000004b		.data.32	75
214	0008	00000156		.data.32	342
215	000c	00000036		.data.32	54
216	0010	00000007		.data.32	7
217	0014	00000056		.data.32	86
218	0018	0000005c		.data.32	92
219	001c	000000eb		.data.32	235
220	0020	00000004		.data.32	4
221	0024	0000002a		.data.32	42
222	0028	00000063		.data.32	99
223	002c	0000004e		.data.32	78
224	0030	0000003f		.data.32	63
225	0034	00000160		.data.32	352
226	0038	00000015		.data.32	21
227	003c	0000027a		.data.32	634
228	0040	00000006		.data.32	6
229	0044	0000004d		.data.32	77
230	0048	0000015a		.data.32	346
231	004c	00000017		.data.32	23
232			


******** Cross Reference List ********
Defined Symbol
name   	section	lc     	attr   	value  	lineno 
while2_x_start	.text	005a	Label	5a	129 
while1_save_start	.text	003f	Label	3f	85 
_main	.text	0000	Label	0	3 
_bubbleSort	.text	0026	Label	26	52 
_array	.data	0000	Label	0	211 
while2_mit_r7_start	.text	0045	Label	45	96 
_exit	.text	0086	Label	86	206 
while1_start	.text	0040	Label	40	88 
while1_end	.text	007a	Label	7a	179 
while2_start	.text	0051	Label	51	117 
while2_save_start	.text	0050	Label	50	114 


Undefined Symbol
name   	section	lc     	attr   	value  	lineno 


Multiple Defined Symbol
name   	section	lc     	attr   	value  	lineno 


******* Section Data List ******* 
Sec	Attr		Size
.text 	Writable 	88 
addr_space : 16 
addressing : Word 
bitwidth per byte : 8 
word alignment : 4 
.data 	Data		50 
addr_space : 16 
addressing : Byte 
bitwidth per byte : 8 
word alignment : 4 
