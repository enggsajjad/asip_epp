
----------------------------------------------------------------
-- 
-- Created by the Synopsys Library Compiler 2002.05
-- FILENAME     :    tcb015ghd_221a.vhd
-- FILE CONTENTS:    Entity, Structural Architecture(VITAL),
--                   and Configuration
-- DATE CREATED :    Mon Jan 12 10:44:45 2004
-- 
-- LIBRARY      :    tcb015ghd
-- DATE ENTERED :    Mon Jan 12 12:14:29 CST 2004
-- REVISION     :    221
-- TECHNOLOGY   :    cmos
-- TIME SCALE   :    1 ns
-- LOGIC SYSTEM :    IEEE-1164
-- NOTES        :    VITAL, TimingChecksOn(TRUE), XGenerationOn(FALSE), TimingMessage(TRUE), OnDetect 
--                   Copyright TSMC
-- HISTORY      :
-- 
----------------------------------------------------------------



----- CELL AN2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN2D0 : entity is TRUE;
end AN2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN2D0_VITAL of AN2D0 is
   for VITAL
   end for;
end CFG_AN2D0_VITAL;


----- CELL AN2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN2D1 : entity is TRUE;
end AN2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN2D1_VITAL of AN2D1 is
   for VITAL
   end for;
end CFG_AN2D1_VITAL;


----- CELL AN2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN2D2 : entity is TRUE;
end AN2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN2D2_VITAL of AN2D2 is
   for VITAL
   end for;
end CFG_AN2D2_VITAL;


----- CELL AN2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN2D4 : entity is TRUE;
end AN2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN2D4_VITAL of AN2D4 is
   for VITAL
   end for;
end CFG_AN2D4_VITAL;


----- CELL AN2D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN2D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN2D8 : entity is TRUE;
end AN2D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN2D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN2D8_VITAL of AN2D8 is
   for VITAL
   end for;
end CFG_AN2D8_VITAL;


----- CELL AN3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN3D0 : entity is TRUE;
end AN3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN3D0_VITAL of AN3D0 is
   for VITAL
   end for;
end CFG_AN3D0_VITAL;


----- CELL AN3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN3D1 : entity is TRUE;
end AN3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN3D1_VITAL of AN3D1 is
   for VITAL
   end for;
end CFG_AN3D1_VITAL;


----- CELL AN3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN3D2 : entity is TRUE;
end AN3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN3D2_VITAL of AN3D2 is
   for VITAL
   end for;
end CFG_AN3D2_VITAL;


----- CELL AN3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN3D4 : entity is TRUE;
end AN3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN3D4_VITAL of AN3D4 is
   for VITAL
   end for;
end CFG_AN3D4_VITAL;


----- CELL AN3D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN3D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN3D8 : entity is TRUE;
end AN3D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN3D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN3D8_VITAL of AN3D8 is
   for VITAL
   end for;
end CFG_AN3D8_VITAL;


----- CELL AN4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN4D0 : entity is TRUE;
end AN4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN4D0_VITAL of AN4D0 is
   for VITAL
   end for;
end CFG_AN4D0_VITAL;


----- CELL AN4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN4D1 : entity is TRUE;
end AN4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN4D1_VITAL of AN4D1 is
   for VITAL
   end for;
end CFG_AN4D1_VITAL;


----- CELL AN4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN4D2 : entity is TRUE;
end AN4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN4D2_VITAL of AN4D2 is
   for VITAL
   end for;
end CFG_AN4D2_VITAL;


----- CELL AN4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN4D4 : entity is TRUE;
end AN4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN4D4_VITAL of AN4D4 is
   for VITAL
   end for;
end CFG_AN4D4_VITAL;


----- CELL AN4D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AN4D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AN4D8 : entity is TRUE;
end AN4D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AN4D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AN4D8_VITAL of AN4D8 is
   for VITAL
   end for;
end CFG_AN4D8_VITAL;


----- CELL ANTENNA -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ANTENNA is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True);

   port(
      I                              :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of ANTENNA : entity is TRUE;
end ANTENNA;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ANTENNA is

begin

   assert (FALSE)
     report "Cell ANTENNA was not properly created." & LF &
        "Please refer to the library compiler error log file."
     severity ERROR;

end VITAL;

configuration CFG_ANTENNA_VITAL of ANTENNA is
   for VITAL
   end for;
end CFG_ANTENNA_VITAL;


----- CELL AO21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO21AD0 : entity is TRUE;
end AO21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) OR ((A2_ipd) AND (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO21AD0_VITAL of AO21AD0 is
   for VITAL
   end for;
end CFG_AO21AD0_VITAL;


----- CELL AO21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO21AD1 : entity is TRUE;
end AO21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) OR ((A2_ipd) AND (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO21AD1_VITAL of AO21AD1 is
   for VITAL
   end for;
end CFG_AO21AD1_VITAL;


----- CELL AO21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO21AD2 : entity is TRUE;
end AO21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) OR ((A2_ipd) AND (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO21AD2_VITAL of AO21AD2 is
   for VITAL
   end for;
end CFG_AO21AD2_VITAL;


----- CELL AO21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO21AD4 : entity is TRUE;
end AO21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) OR ((A2_ipd) AND (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO21AD4_VITAL of AO21AD4 is
   for VITAL
   end for;
end CFG_AO21AD4_VITAL;


----- CELL AO22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO22AD0 : entity is TRUE;
end AO22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) AND (A1_ipd)) OR ((B2_ipd) AND (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO22AD0_VITAL of AO22AD0 is
   for VITAL
   end for;
end CFG_AO22AD0_VITAL;


----- CELL AO22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO22AD1 : entity is TRUE;
end AO22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) AND (A1_ipd)) OR ((B2_ipd) AND (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO22AD1_VITAL of AO22AD1 is
   for VITAL
   end for;
end CFG_AO22AD1_VITAL;


----- CELL AO22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO22AD2 : entity is TRUE;
end AO22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) AND (A1_ipd)) OR ((B2_ipd) AND (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO22AD2_VITAL of AO22AD2 is
   for VITAL
   end for;
end CFG_AO22AD2_VITAL;


----- CELL AO22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AO22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AO22AD4 : entity is TRUE;
end AO22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AO22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) AND (A1_ipd)) OR ((B2_ipd) AND (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AO22AD4_VITAL of AO22AD4 is
   for VITAL
   end for;
end CFG_AO22AD4_VITAL;


----- CELL AOI211D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI211D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI211D0 : entity is TRUE;
end AOI211D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI211D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI211D0_VITAL of AOI211D0 is
   for VITAL
   end for;
end CFG_AOI211D0_VITAL;


----- CELL AOI211D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI211D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI211D1 : entity is TRUE;
end AOI211D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI211D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI211D1_VITAL of AOI211D1 is
   for VITAL
   end for;
end CFG_AOI211D1_VITAL;


----- CELL AOI211D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI211D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI211D2 : entity is TRUE;
end AOI211D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI211D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI211D2_VITAL of AOI211D2 is
   for VITAL
   end for;
end CFG_AOI211D2_VITAL;


----- CELL AOI211D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI211D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI211D4 : entity is TRUE;
end AOI211D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI211D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI211D4_VITAL of AOI211D4 is
   for VITAL
   end for;
end CFG_AOI211D4_VITAL;


----- CELL AOI21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21AD0 : entity is TRUE;
end AOI21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21AD0_VITAL of AOI21AD0 is
   for VITAL
   end for;
end CFG_AOI21AD0_VITAL;


----- CELL AOI21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21AD1 : entity is TRUE;
end AOI21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21AD1_VITAL of AOI21AD1 is
   for VITAL
   end for;
end CFG_AOI21AD1_VITAL;


----- CELL AOI21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21AD2 : entity is TRUE;
end AOI21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21AD2_VITAL of AOI21AD2 is
   for VITAL
   end for;
end CFG_AOI21AD2_VITAL;


----- CELL AOI21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21AD4 : entity is TRUE;
end AOI21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21AD4_VITAL of AOI21AD4 is
   for VITAL
   end for;
end CFG_AOI21AD4_VITAL;


----- CELL AOI21D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21D0 : entity is TRUE;
end AOI21D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21D0_VITAL of AOI21D0 is
   for VITAL
   end for;
end CFG_AOI21D0_VITAL;


----- CELL AOI21D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21D1 : entity is TRUE;
end AOI21D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21D1_VITAL of AOI21D1 is
   for VITAL
   end for;
end CFG_AOI21D1_VITAL;


----- CELL AOI21D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21D2 : entity is TRUE;
end AOI21D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21D2_VITAL of AOI21D2 is
   for VITAL
   end for;
end CFG_AOI21D2_VITAL;


----- CELL AOI21D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI21D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI21D4 : entity is TRUE;
end AOI21D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI21D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI21D4_VITAL of AOI21D4 is
   for VITAL
   end for;
end CFG_AOI21D4_VITAL;


----- CELL AOI221D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI221D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI221D0 : entity is TRUE;
end AOI221D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI221D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI221D0_VITAL of AOI221D0 is
   for VITAL
   end for;
end CFG_AOI221D0_VITAL;


----- CELL AOI221D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI221D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI221D1 : entity is TRUE;
end AOI221D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI221D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI221D1_VITAL of AOI221D1 is
   for VITAL
   end for;
end CFG_AOI221D1_VITAL;


----- CELL AOI221D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI221D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI221D2 : entity is TRUE;
end AOI221D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI221D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI221D2_VITAL of AOI221D2 is
   for VITAL
   end for;
end CFG_AOI221D2_VITAL;


----- CELL AOI221D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI221D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI221D4 : entity is TRUE;
end AOI221D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI221D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd)) OR (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI221D4_VITAL of AOI221D4 is
   for VITAL
   end for;
end CFG_AOI221D4_VITAL;


----- CELL AOI222D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI222D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI222D0 : entity is TRUE;
end AOI222D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI222D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd)) OR ((C2_ipd) AND (C1_ipd)) OR ((B2_ipd)
         AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI222D0_VITAL of AOI222D0 is
   for VITAL
   end for;
end CFG_AOI222D0_VITAL;


----- CELL AOI222D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI222D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI222D1 : entity is TRUE;
end AOI222D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI222D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd)) OR ((C2_ipd) AND (C1_ipd)) OR ((B2_ipd)
         AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI222D1_VITAL of AOI222D1 is
   for VITAL
   end for;
end CFG_AOI222D1_VITAL;


----- CELL AOI222D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI222D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI222D2 : entity is TRUE;
end AOI222D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI222D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd)) OR ((C2_ipd) AND (C1_ipd)) OR ((B2_ipd)
         AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI222D2_VITAL of AOI222D2 is
   for VITAL
   end for;
end CFG_AOI222D2_VITAL;


----- CELL AOI222D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI222D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI222D4 : entity is TRUE;
end AOI222D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI222D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C2_ipd) AND (C1_ipd)) OR ((A2_ipd) AND (A1_ipd)) OR ((B2_ipd)
         AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI222D4_VITAL of AOI222D4 is
   for VITAL
   end for;
end CFG_AOI222D4_VITAL;


----- CELL AOI22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22AD0 : entity is TRUE;
end AOI22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22AD0_VITAL of AOI22AD0 is
   for VITAL
   end for;
end CFG_AOI22AD0_VITAL;


----- CELL AOI22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22AD1 : entity is TRUE;
end AOI22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22AD1_VITAL of AOI22AD1 is
   for VITAL
   end for;
end CFG_AOI22AD1_VITAL;


----- CELL AOI22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22AD2 : entity is TRUE;
end AOI22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22AD2_VITAL of AOI22AD2 is
   for VITAL
   end for;
end CFG_AOI22AD2_VITAL;


----- CELL AOI22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22AD4 : entity is TRUE;
end AOI22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22AD4_VITAL of AOI22AD4 is
   for VITAL
   end for;
end CFG_AOI22AD4_VITAL;


----- CELL AOI22D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22D0 : entity is TRUE;
end AOI22D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22D0_VITAL of AOI22D0 is
   for VITAL
   end for;
end CFG_AOI22D0_VITAL;


----- CELL AOI22D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22D1 : entity is TRUE;
end AOI22D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22D1_VITAL of AOI22D1 is
   for VITAL
   end for;
end CFG_AOI22D1_VITAL;


----- CELL AOI22D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22D2 : entity is TRUE;
end AOI22D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22D2_VITAL of AOI22D2 is
   for VITAL
   end for;
end CFG_AOI22D2_VITAL;


----- CELL AOI22D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI22D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI22D4 : entity is TRUE;
end AOI22D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI22D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI22D4_VITAL of AOI22D4 is
   for VITAL
   end for;
end CFG_AOI22D4_VITAL;


----- CELL AOI31D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI31D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI31D0 : entity is TRUE;
end AOI31D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI31D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd) AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI31D0_VITAL of AOI31D0 is
   for VITAL
   end for;
end CFG_AOI31D0_VITAL;


----- CELL AOI31D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI31D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI31D1 : entity is TRUE;
end AOI31D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI31D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd) AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI31D1_VITAL of AOI31D1 is
   for VITAL
   end for;
end CFG_AOI31D1_VITAL;


----- CELL AOI31D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI31D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI31D2 : entity is TRUE;
end AOI31D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI31D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd) AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI31D2_VITAL of AOI31D2 is
   for VITAL
   end for;
end CFG_AOI31D2_VITAL;


----- CELL AOI31D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI31D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI31D4 : entity is TRUE;
end AOI31D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI31D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((A2_ipd) AND (A1_ipd) AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI31D4_VITAL of AOI31D4 is
   for VITAL
   end for;
end CFG_AOI31D4_VITAL;


----- CELL AOI32D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI32D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI32D0 : entity is TRUE;
end AOI32D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI32D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd) AND
         (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI32D0_VITAL of AOI32D0 is
   for VITAL
   end for;
end CFG_AOI32D0_VITAL;


----- CELL AOI32D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI32D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI32D1 : entity is TRUE;
end AOI32D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI32D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd) AND
         (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI32D1_VITAL of AOI32D1 is
   for VITAL
   end for;
end CFG_AOI32D1_VITAL;


----- CELL AOI32D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI32D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI32D2 : entity is TRUE;
end AOI32D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI32D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((A2_ipd) AND (A1_ipd) AND
         (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI32D2_VITAL of AOI32D2 is
   for VITAL
   end for;
end CFG_AOI32D2_VITAL;


----- CELL AOI32D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI32D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI32D4 : entity is TRUE;
end AOI32D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI32D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd) AND (A3_ipd)) OR ((B2_ipd) AND
         (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI32D4_VITAL of AOI32D4 is
   for VITAL
   end for;
end CFG_AOI32D4_VITAL;


----- CELL AOI33D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI33D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI33D0 : entity is TRUE;
end AOI33D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI33D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd) AND (B3_ipd)) OR ((A2_ipd) AND (A1_ipd)
         AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI33D0_VITAL of AOI33D0 is
   for VITAL
   end for;
end CFG_AOI33D0_VITAL;


----- CELL AOI33D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI33D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI33D1 : entity is TRUE;
end AOI33D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI33D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd) AND (B3_ipd)) OR ((A2_ipd) AND (A1_ipd)
         AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI33D1_VITAL of AOI33D1 is
   for VITAL
   end for;
end CFG_AOI33D1_VITAL;


----- CELL AOI33D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI33D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI33D2 : entity is TRUE;
end AOI33D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI33D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd) AND (B3_ipd)) OR ((A2_ipd) AND (A1_ipd)
         AND (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI33D2_VITAL of AOI33D2 is
   for VITAL
   end for;
end CFG_AOI33D2_VITAL;


----- CELL AOI33D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity AOI33D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of AOI33D4 : entity is TRUE;
end AOI33D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of AOI33D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd) AND (A3_ipd)) OR ((B2_ipd) AND (B1_ipd)
         AND (B3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_AOI33D4_VITAL of AOI33D4 is
   for VITAL
   end for;
end CFG_AOI33D4_VITAL;


----- CELL BHD -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BHD is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tipd_Z                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      Z                              :	inout STD_ULOGIC := 'Z');
attribute VITAL_LEVEL0 of BHD : entity is TRUE;
end BHD;

architecture dataflow of BHD is
begin
  process(Z)
  begin
    case Z is
      when 'U' => Z <= 'W'; -- Uninitialized
      when 'X' => Z <= 'W'; -- Forcing Unknown
      when '0' => Z <= 'L'; -- Forcing 0
      when '1' => Z <= 'H'; -- Forcing 1
      when 'Z' => null;     -- High Impedance
      when 'W' => Z <= 'W'; -- Weak Unknown
      when 'L' => Z <= 'L'; -- Weak 0
      when 'H' => Z <= 'H'; -- Weak 1
      when '-' => Z <= 'W'; -- Don't care
    end case;
  end process;
end dataflow;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BHD is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;


begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   --  empty
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (Z)


   -- functionality results
   VARIABLE Z_zd : STD_ULOGIC := 'X';

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
   Z_zd := VitalBUF ( Z, ('W', 'W', 'L', 'H'));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0=>(Z'last_event, VitalZeroDelay01Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);


end process;

end VITAL;

configuration CFG_BHD_VITAL of BHD is
   for VITAL
   end for;
end CFG_BHD_VITAL;


----- CELL BUFFD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD0 : entity is TRUE;
end BUFFD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD0_VITAL of BUFFD0 is
   for VITAL
   end for;
end CFG_BUFFD0_VITAL;


----- CELL BUFFD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD1 : entity is TRUE;
end BUFFD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD1_VITAL of BUFFD1 is
   for VITAL
   end for;
end CFG_BUFFD1_VITAL;


----- CELL BUFFD12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD12 : entity is TRUE;
end BUFFD12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD12_VITAL of BUFFD12 is
   for VITAL
   end for;
end CFG_BUFFD12_VITAL;


----- CELL BUFFD16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD16 : entity is TRUE;
end BUFFD16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD16_VITAL of BUFFD16 is
   for VITAL
   end for;
end CFG_BUFFD16_VITAL;


----- CELL BUFFD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD2 : entity is TRUE;
end BUFFD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD2_VITAL of BUFFD2 is
   for VITAL
   end for;
end CFG_BUFFD2_VITAL;


----- CELL BUFFD20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD20 : entity is TRUE;
end BUFFD20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD20_VITAL of BUFFD20 is
   for VITAL
   end for;
end CFG_BUFFD20_VITAL;


----- CELL BUFFD24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD24 : entity is TRUE;
end BUFFD24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD24_VITAL of BUFFD24 is
   for VITAL
   end for;
end CFG_BUFFD24_VITAL;


----- CELL BUFFD3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD3 : entity is TRUE;
end BUFFD3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD3_VITAL of BUFFD3 is
   for VITAL
   end for;
end CFG_BUFFD3_VITAL;


----- CELL BUFFD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD4 : entity is TRUE;
end BUFFD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD4_VITAL of BUFFD4 is
   for VITAL
   end for;
end CFG_BUFFD4_VITAL;


----- CELL BUFFD6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD6 : entity is TRUE;
end BUFFD6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD6_VITAL of BUFFD6 is
   for VITAL
   end for;
end CFG_BUFFD6_VITAL;


----- CELL BUFFD8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFFD8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFFD8 : entity is TRUE;
end BUFFD8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFFD8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_BUFFD8_VITAL of BUFFD8 is
   for VITAL
   end for;
end CFG_BUFFD8_VITAL;


----- CELL BUFTD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD0 : entity is TRUE;
end BUFTD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD0_VITAL of BUFTD0 is
   for VITAL
   end for;
end CFG_BUFTD0_VITAL;


----- CELL BUFTD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD1 : entity is TRUE;
end BUFTD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD1_VITAL of BUFTD1 is
   for VITAL
   end for;
end CFG_BUFTD1_VITAL;


----- CELL BUFTD12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD12 : entity is TRUE;
end BUFTD12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD12_VITAL of BUFTD12 is
   for VITAL
   end for;
end CFG_BUFTD12_VITAL;


----- CELL BUFTD16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD16 : entity is TRUE;
end BUFTD16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD16_VITAL of BUFTD16 is
   for VITAL
   end for;
end CFG_BUFTD16_VITAL;


----- CELL BUFTD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD2 : entity is TRUE;
end BUFTD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD2_VITAL of BUFTD2 is
   for VITAL
   end for;
end CFG_BUFTD2_VITAL;


----- CELL BUFTD20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD20 : entity is TRUE;
end BUFTD20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD20_VITAL of BUFTD20 is
   for VITAL
   end for;
end CFG_BUFTD20_VITAL;


----- CELL BUFTD24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD24 : entity is TRUE;
end BUFTD24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD24_VITAL of BUFTD24 is
   for VITAL
   end for;
end CFG_BUFTD24_VITAL;


----- CELL BUFTD3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD3 : entity is TRUE;
end BUFTD3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD3_VITAL of BUFTD3 is
   for VITAL
   end for;
end CFG_BUFTD3_VITAL;


----- CELL BUFTD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD4 : entity is TRUE;
end BUFTD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD4_VITAL of BUFTD4 is
   for VITAL
   end for;
end CFG_BUFTD4_VITAL;


----- CELL BUFTD6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD6 : entity is TRUE;
end BUFTD6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD6_VITAL of BUFTD6 is
   for VITAL
   end for;
end CFG_BUFTD6_VITAL;


----- CELL BUFTD8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity BUFTD8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_OE_Z                       :	VitalDelayType01z := 
               (0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_OE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      OE                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of BUFTD8 : entity is TRUE;
end BUFTD8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of BUFTD8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';
   SIGNAL OE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   VitalWireDelay (OE_ipd, OE, tipd_OE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd, OE_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalBUFIF0 (data => I_ipd,
              enable => (NOT OE_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01Z (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, VitalExtendToFillDelay(tpd_I_Z), TRUE),
                 1 => (OE_ipd'last_event, VitalExtendToFillDelay(tpd_OE_Z), TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING,
       OutputMap => "UX01ZWLH-");

end process;

end VITAL;

configuration CFG_BUFTD8_VITAL of BUFTD8 is
   for VITAL
   end for;
end CFG_BUFTD8_VITAL;


----- CELL CKBD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD0 : entity is TRUE;
end CKBD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD0_VITAL of CKBD0 is
   for VITAL
   end for;
end CFG_CKBD0_VITAL;


----- CELL CKBD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD1 : entity is TRUE;
end CKBD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD1_VITAL of CKBD1 is
   for VITAL
   end for;
end CFG_CKBD1_VITAL;


----- CELL CKBD12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD12 : entity is TRUE;
end CKBD12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD12_VITAL of CKBD12 is
   for VITAL
   end for;
end CFG_CKBD12_VITAL;


----- CELL CKBD16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD16 : entity is TRUE;
end CKBD16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD16_VITAL of CKBD16 is
   for VITAL
   end for;
end CFG_CKBD16_VITAL;


----- CELL CKBD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD2 : entity is TRUE;
end CKBD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD2_VITAL of CKBD2 is
   for VITAL
   end for;
end CFG_CKBD2_VITAL;


----- CELL CKBD20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD20 : entity is TRUE;
end CKBD20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD20_VITAL of CKBD20 is
   for VITAL
   end for;
end CFG_CKBD20_VITAL;


----- CELL CKBD24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD24 : entity is TRUE;
end CKBD24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD24_VITAL of CKBD24 is
   for VITAL
   end for;
end CFG_CKBD24_VITAL;


----- CELL CKBD3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD3 : entity is TRUE;
end CKBD3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD3_VITAL of CKBD3 is
   for VITAL
   end for;
end CFG_CKBD3_VITAL;


----- CELL CKBD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD4 : entity is TRUE;
end CKBD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD4_VITAL of CKBD4 is
   for VITAL
   end for;
end CFG_CKBD4_VITAL;


----- CELL CKBD6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD6 : entity is TRUE;
end CKBD6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD6_VITAL of CKBD6 is
   for VITAL
   end for;
end CFG_CKBD6_VITAL;


----- CELL CKBD8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKBD8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_C                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      C                              :	out   STD_ULOGIC;
      CLK                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKBD8 : entity is TRUE;
end CKBD8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKBD8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS C_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE C_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      C_zd := TO_X01(CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => C,
       GlitchData => C_GlitchData,
       OutSignalName => "C",
       OutTemp => C_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_C, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKBD8_VITAL of CKBD8 is
   for VITAL
   end for;
end CFG_CKBD8_VITAL;


----- CELL CKLNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD1 : entity is TRUE;
end CKLNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD1_VITAL of CKLNQD1 is
   for VITAL
   end for;
end CFG_CKLNQD1_VITAL;


----- CELL CKLNQD12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD12 : entity is TRUE;
end CKLNQD12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD12",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD12",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD12",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD12_VITAL of CKLNQD12 is
   for VITAL
   end for;
end CFG_CKLNQD12_VITAL;


----- CELL CKLNQD16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD16 : entity is TRUE;
end CKLNQD16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD16",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD16",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD16",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD16_VITAL of CKLNQD16 is
   for VITAL
   end for;
end CFG_CKLNQD16_VITAL;


----- CELL CKLNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD2 : entity is TRUE;
end CKLNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD2_VITAL of CKLNQD2 is
   for VITAL
   end for;
end CFG_CKLNQD2_VITAL;


----- CELL CKLNQD20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD20 : entity is TRUE;
end CKLNQD20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD20",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD20",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD20",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD20_VITAL of CKLNQD20 is
   for VITAL
   end for;
end CFG_CKLNQD20_VITAL;


----- CELL CKLNQD24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD24 : entity is TRUE;
end CKLNQD24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD24",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD24",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD24",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD24_VITAL of CKLNQD24 is
   for VITAL
   end for;
end CFG_CKLNQD24_VITAL;


----- CELL CKLNQD3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD3 : entity is TRUE;
end CKLNQD3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD3",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD3",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD3",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD3_VITAL of CKLNQD3 is
   for VITAL
   end for;
end CFG_CKLNQD3_VITAL;


----- CELL CKLNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD4 : entity is TRUE;
end CKLNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD4_VITAL of CKLNQD4 is
   for VITAL
   end for;
end CFG_CKLNQD4_VITAL;


----- CELL CKLNQD6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD6 : entity is TRUE;
end CKLNQD6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD6",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD6",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD6",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD6_VITAL of CKLNQD6 is
   for VITAL
   end for;
end CFG_CKLNQD6_VITAL;


----- CELL CKLNQD8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKLNQD8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_E_CP_posedge_posedge            :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge            :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_posedge_posedge           :	VitalDelayType := 0.000 ns;
      thold_TE_CP_negedge_posedge           :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_posedge_posedge          :	VitalDelayType := 0.000 ns;
      tsetup_TE_CP_negedge_posedge          :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_TE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      TE                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of CKLNQD8 : entity is TRUE;
end CKLNQD8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKLNQD8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL TE_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (TE_ipd, TE, tipd_TE);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, E_ipd, TE_ipd)

   -- timing check results
   VARIABLE Tviol_E_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_TE_CPcheckpin1_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_TE_CPcheckpin1_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_QD : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE QD : STD_ULOGIC := 'X';
   VARIABLE CPcheckpin1 : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CPcheckpin1_posedge,
          TimingData              => Tmkr_E_CPcheckpin1_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD8",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_TE_CPcheckpin1_posedge,
          TimingData              => Tmkr_TE_CPcheckpin1_posedge,
          TestSignal              => TE_ipd,
          TestSignalName          => "TE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_TE_CP_posedge_posedge,
          SetupLow                => tsetup_TE_CP_negedge_posedge,
          HoldHigh                => thold_TE_CP_negedge_posedge,
          HoldLow                 => thold_TE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/CKLNQD8",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/CKLNQD8",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_E_CPcheckpin1_posedge or Tviol_TE_CPcheckpin1_posedge or Pviol_CP;
      VitalStateTable(
        Result => QD,
        PreviousDataIn => PrevData_QD,
        StateTable => CKLNQD1_QD_tab,
        DataIn => (
               CP_ipd, TE_ipd, E_ipd));
      QD := Violation XOR QD;
      Q_zd := (CP_ipd) AND (QD);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKLNQD8_VITAL of CKLNQD8 is
   for VITAL
   end for;
end CFG_CKLNQD8_VITAL;


----- CELL CKMUX2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKMUX2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKMUX2D0 : entity is TRUE;
end CKMUX2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKMUX2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKMUX2D0_VITAL of CKMUX2D0 is
   for VITAL
   end for;
end CFG_CKMUX2D0_VITAL;


----- CELL CKMUX2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKMUX2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKMUX2D1 : entity is TRUE;
end CKMUX2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKMUX2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKMUX2D1_VITAL of CKMUX2D1 is
   for VITAL
   end for;
end CFG_CKMUX2D1_VITAL;


----- CELL CKMUX2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKMUX2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKMUX2D2 : entity is TRUE;
end CKMUX2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKMUX2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKMUX2D2_VITAL of CKMUX2D2 is
   for VITAL
   end for;
end CFG_CKMUX2D2_VITAL;


----- CELL CKMUX2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKMUX2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKMUX2D4 : entity is TRUE;
end CKMUX2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKMUX2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKMUX2D4_VITAL of CKMUX2D4 is
   for VITAL
   end for;
end CFG_CKMUX2D4_VITAL;


----- CELL CKND0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND0 : entity is TRUE;
end CKND0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND0_VITAL of CKND0 is
   for VITAL
   end for;
end CFG_CKND0_VITAL;


----- CELL CKND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND1 : entity is TRUE;
end CKND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND1_VITAL of CKND1 is
   for VITAL
   end for;
end CFG_CKND1_VITAL;


----- CELL CKND12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND12 : entity is TRUE;
end CKND12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND12_VITAL of CKND12 is
   for VITAL
   end for;
end CFG_CKND12_VITAL;


----- CELL CKND16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND16 : entity is TRUE;
end CKND16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND16_VITAL of CKND16 is
   for VITAL
   end for;
end CFG_CKND16_VITAL;


----- CELL CKND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2 : entity is TRUE;
end CKND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2_VITAL of CKND2 is
   for VITAL
   end for;
end CFG_CKND2_VITAL;


----- CELL CKND20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND20 : entity is TRUE;
end CKND20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND20_VITAL of CKND20 is
   for VITAL
   end for;
end CFG_CKND20_VITAL;


----- CELL CKND24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND24 : entity is TRUE;
end CKND24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND24_VITAL of CKND24 is
   for VITAL
   end for;
end CFG_CKND24_VITAL;


----- CELL CKND2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D0 : entity is TRUE;
end CKND2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D0_VITAL of CKND2D0 is
   for VITAL
   end for;
end CFG_CKND2D0_VITAL;


----- CELL CKND2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D1 : entity is TRUE;
end CKND2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D1_VITAL of CKND2D1 is
   for VITAL
   end for;
end CFG_CKND2D1_VITAL;


----- CELL CKND2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D2 : entity is TRUE;
end CKND2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D2_VITAL of CKND2D2 is
   for VITAL
   end for;
end CFG_CKND2D2_VITAL;


----- CELL CKND2D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D3 : entity is TRUE;
end CKND2D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D3_VITAL of CKND2D3 is
   for VITAL
   end for;
end CFG_CKND2D3_VITAL;


----- CELL CKND2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D4 : entity is TRUE;
end CKND2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D4_VITAL of CKND2D4 is
   for VITAL
   end for;
end CFG_CKND2D4_VITAL;


----- CELL CKND2D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND2D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND2D8 : entity is TRUE;
end CKND2D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND2D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND2D8_VITAL of CKND2D8 is
   for VITAL
   end for;
end CFG_CKND2D8_VITAL;


----- CELL CKND3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND3 : entity is TRUE;
end CKND3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND3_VITAL of CKND3 is
   for VITAL
   end for;
end CFG_CKND3_VITAL;


----- CELL CKND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND4 : entity is TRUE;
end CKND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND4_VITAL of CKND4 is
   for VITAL
   end for;
end CFG_CKND4_VITAL;


----- CELL CKND6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND6 : entity is TRUE;
end CKND6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND6_VITAL of CKND6 is
   for VITAL
   end for;
end CFG_CKND6_VITAL;


----- CELL CKND8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKND8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CLK_CN                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CLK                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CLK                            :	in    STD_ULOGIC;
      CN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKND8 : entity is TRUE;
end CKND8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKND8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CLK_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CLK_ipd, CLK, tipd_CLK);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CLK_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS CN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE CN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CN_zd := (NOT CLK_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CN,
       GlitchData => CN_GlitchData,
       OutSignalName => "CN",
       OutTemp => CN_zd,
       Paths => (0 => (CLK_ipd'last_event, tpd_CLK_CN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKND8_VITAL of CKND8 is
   for VITAL
   end for;
end CFG_CKND8_VITAL;


----- CELL CKXOR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKXOR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKXOR2D0 : entity is TRUE;
end CKXOR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKXOR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKXOR2D0_VITAL of CKXOR2D0 is
   for VITAL
   end for;
end CFG_CKXOR2D0_VITAL;


----- CELL CKXOR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKXOR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKXOR2D1 : entity is TRUE;
end CKXOR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKXOR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKXOR2D1_VITAL of CKXOR2D1 is
   for VITAL
   end for;
end CFG_CKXOR2D1_VITAL;


----- CELL CKXOR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKXOR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKXOR2D2 : entity is TRUE;
end CKXOR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKXOR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKXOR2D2_VITAL of CKXOR2D2 is
   for VITAL
   end for;
end CFG_CKXOR2D2_VITAL;


----- CELL CKXOR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity CKXOR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of CKXOR2D4 : entity is TRUE;
end CKXOR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of CKXOR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_CKXOR2D4_VITAL of CKXOR2D4 is
   for VITAL
   end for;
end CFG_CKXOR2D4_VITAL;


----- CELL DCAP -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DCAP is
attribute VITAL_LEVEL0 of DCAP : entity is TRUE;
end DCAP;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DCAP is

begin

   assert (FALSE)
     report "Cell DCAP was not properly created." & LF &
        "Please refer to the library compiler error log file."
     severity ERROR;

end VITAL;

configuration CFG_DCAP_VITAL of DCAP is
   for VITAL
   end for;
end CFG_DCAP_VITAL;


----- CELL DEL1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DEL1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DEL1 : entity is TRUE;
end DEL1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DEL1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DEL1_VITAL of DEL1 is
   for VITAL
   end for;
end CFG_DEL1_VITAL;


----- CELL DEL2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DEL2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DEL2 : entity is TRUE;
end DEL2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DEL2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DEL2_VITAL of DEL2 is
   for VITAL
   end for;
end CFG_DEL2_VITAL;


----- CELL DEL3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DEL3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DEL3 : entity is TRUE;
end DEL3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DEL3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DEL3_VITAL of DEL3 is
   for VITAL
   end for;
end CFG_DEL3_VITAL;


----- CELL DEL4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DEL4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DEL4 : entity is TRUE;
end DEL4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DEL4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := TO_X01(I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DEL4_VITAL of DEL4 is
   for VITAL
   end for;
end CFG_DEL4_VITAL;


----- CELL DFCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCND1 : entity is TRUE;
end DFCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCND1_VITAL of DFCND1 is
   for VITAL
   end for;
end CFG_DFCND1_VITAL;


----- CELL DFCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCND2 : entity is TRUE;
end DFCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCND2_VITAL of DFCND2 is
   for VITAL
   end for;
end CFG_DFCND2_VITAL;


----- CELL DFCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCND4 : entity is TRUE;
end DFCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCND4_VITAL of DFCND4 is
   for VITAL
   end for;
end CFG_DFCND4_VITAL;


----- CELL DFCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCNQD1 : entity is TRUE;
end DFCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCNQD1_VITAL of DFCNQD1 is
   for VITAL
   end for;
end CFG_DFCNQD1_VITAL;


----- CELL DFCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCNQD2 : entity is TRUE;
end DFCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCNQD2_VITAL of DFCNQD2 is
   for VITAL
   end for;
end CFG_DFCNQD2_VITAL;


----- CELL DFCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCNQD4 : entity is TRUE;
end DFCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCNQD4_VITAL of DFCNQD4 is
   for VITAL
   end for;
end CFG_DFCNQD4_VITAL;


----- CELL DFCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCSND1 : entity is TRUE;
end DFCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, CDN_ipd, D_delayed, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCSND1_VITAL of DFCSND1 is
   for VITAL
   end for;
end CFG_DFCSND1_VITAL;


----- CELL DFCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCSND2 : entity is TRUE;
end DFCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, CDN_ipd, D_delayed, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCSND2_VITAL of DFCSND2 is
   for VITAL
   end for;
end CFG_DFCSND2_VITAL;


----- CELL DFCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFCSND4 : entity is TRUE;
end DFCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, CDN_ipd, D_delayed, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFCSND4_VITAL of DFCSND4 is
   for VITAL
   end for;
end CFG_DFCSND4_VITAL;


----- CELL DFD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFD1 : entity is TRUE;
end DFD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFD1_VITAL of DFD1 is
   for VITAL
   end for;
end CFG_DFD1_VITAL;


----- CELL DFD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFD2 : entity is TRUE;
end DFD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFD2_VITAL of DFD2 is
   for VITAL
   end for;
end CFG_DFD2_VITAL;


----- CELL DFD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFD4 : entity is TRUE;
end DFD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFD4_VITAL of DFD4 is
   for VITAL
   end for;
end CFG_DFD4_VITAL;


----- CELL DFKCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCND1 : entity is TRUE;
end DFKCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCND1_VITAL of DFKCND1 is
   for VITAL
   end for;
end CFG_DFKCND1_VITAL;


----- CELL DFKCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCND2 : entity is TRUE;
end DFKCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCND2_VITAL of DFKCND2 is
   for VITAL
   end for;
end CFG_DFKCND2_VITAL;


----- CELL DFKCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCND4 : entity is TRUE;
end DFKCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCND4_VITAL of DFKCND4 is
   for VITAL
   end for;
end CFG_DFKCND4_VITAL;


----- CELL DFKCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCNQD1 : entity is TRUE;
end DFKCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCNQD1_VITAL of DFKCNQD1 is
   for VITAL
   end for;
end CFG_DFKCNQD1_VITAL;


----- CELL DFKCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCNQD2 : entity is TRUE;
end DFKCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCNQD2_VITAL of DFKCNQD2 is
   for VITAL
   end for;
end CFG_DFKCNQD2_VITAL;


----- CELL DFKCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCNQD4 : entity is TRUE;
end DFKCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCNQD4_VITAL of DFKCNQD4 is
   for VITAL
   end for;
end CFG_DFKCNQD4_VITAL;


----- CELL DFKCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCSND1 : entity is TRUE;
end DFKCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCSND1_VITAL of DFKCSND1 is
   for VITAL
   end for;
end CFG_DFKCSND1_VITAL;


----- CELL DFKCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCSND2 : entity is TRUE;
end DFKCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCSND2_VITAL of DFKCSND2 is
   for VITAL
   end for;
end CFG_DFKCSND2_VITAL;


----- CELL DFKCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKCSND4 : entity is TRUE;
end DFKCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKCSND4_VITAL of DFKCSND4 is
   for VITAL
   end for;
end CFG_DFKCSND4_VITAL;


----- CELL DFKSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKSND1 : entity is TRUE;
end DFKSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKSND1_VITAL of DFKSND1 is
   for VITAL
   end for;
end CFG_DFKSND1_VITAL;


----- CELL DFKSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKSND2 : entity is TRUE;
end DFKSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKSND2_VITAL of DFKSND2 is
   for VITAL
   end for;
end CFG_DFKSND2_VITAL;


----- CELL DFKSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFKSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFKSND4 : entity is TRUE;
end DFKSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFKSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFKSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFKSND4_VITAL of DFKSND4 is
   for VITAL
   end for;
end CFG_DFKSND4_VITAL;


----- CELL DFNCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCND1 : entity is TRUE;
end DFNCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCND1_VITAL of DFNCND1 is
   for VITAL
   end for;
end CFG_DFNCND1_VITAL;


----- CELL DFNCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCND2 : entity is TRUE;
end DFNCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCND2_VITAL of DFNCND2 is
   for VITAL
   end for;
end CFG_DFNCND2_VITAL;


----- CELL DFNCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCND4 : entity is TRUE;
end DFNCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCND4_VITAL of DFNCND4 is
   for VITAL
   end for;
end CFG_DFNCND4_VITAL;


----- CELL DFNCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCSND1 : entity is TRUE;
end DFNCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SDN_CDN_posedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, CDN_ipd, D_delayed, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCSND1_VITAL of DFNCSND1 is
   for VITAL
   end for;
end CFG_DFNCSND1_VITAL;


----- CELL DFNCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCSND2 : entity is TRUE;
end DFNCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SDN_CDN_posedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, CDN_ipd, D_delayed, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCSND2_VITAL of DFNCSND2 is
   for VITAL
   end for;
end CFG_DFNCSND2_VITAL;


----- CELL DFNCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNCSND4 : entity is TRUE;
end DFNCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SDN_CDN_posedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => DFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, CDN_ipd, D_delayed, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNCSND4_VITAL of DFNCSND4 is
   for VITAL
   end for;
end CFG_DFNCSND4_VITAL;


----- CELL DFND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFND1 : entity is TRUE;
end DFND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFND1_VITAL of DFND1 is
   for VITAL
   end for;
end CFG_DFND1_VITAL;


----- CELL DFND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFND2 : entity is TRUE;
end DFND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFND2_VITAL of DFND2 is
   for VITAL
   end for;
end CFG_DFND2_VITAL;


----- CELL DFND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFND4 : entity is TRUE;
end DFND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFND4_VITAL of DFND4 is
   for VITAL
   end for;
end CFG_DFND4_VITAL;


----- CELL DFNSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNSND1 : entity is TRUE;
end DFNSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNSND1_VITAL of DFNSND1 is
   for VITAL
   end for;
end CFG_DFNSND1_VITAL;


----- CELL DFNSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNSND2 : entity is TRUE;
end DFNSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNSND2_VITAL of DFNSND2 is
   for VITAL
   end for;
end CFG_DFNSND2_VITAL;


----- CELL DFNSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFNSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFNSND4 : entity is TRUE;
end DFNSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFNSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/DFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, D_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFNSND4_VITAL of DFNSND4 is
   for VITAL
   end for;
end CFG_DFNSND4_VITAL;


----- CELL DFQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFQD1 : entity is TRUE;
end DFQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFQD1_VITAL of DFQD1 is
   for VITAL
   end for;
end CFG_DFQD1_VITAL;


----- CELL DFQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFQD2 : entity is TRUE;
end DFQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFQD2_VITAL of DFQD2 is
   for VITAL
   end for;
end CFG_DFQD2_VITAL;


----- CELL DFQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of DFQD4 : entity is TRUE;
end DFQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFD1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFQD4_VITAL of DFQD4 is
   for VITAL
   end for;
end CFG_DFQD4_VITAL;


----- CELL DFSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFSND1 : entity is TRUE;
end DFSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Pviol_SDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFSND1_VITAL of DFSND1 is
   for VITAL
   end for;
end CFG_DFSND1_VITAL;


----- CELL DFSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFSND2 : entity is TRUE;
end DFSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Pviol_SDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFSND2_VITAL of DFSND2 is
   for VITAL
   end for;
end CFG_DFSND2_VITAL;


----- CELL DFSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFSND4 : entity is TRUE;
end DFSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/DFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Pviol_SDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFNSND1_Q_tab,
        DataIn => (
               CP_delayed, D_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFSND4_VITAL of DFSND4 is
   for VITAL
   end for;
end CFG_DFSND4_VITAL;


----- CELL DFXD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFXD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFXD1 : entity is TRUE;
end DFXD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFXD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, DB_delayed, DA_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFXD1_VITAL of DFXD1 is
   for VITAL
   end for;
end CFG_DFXD1_VITAL;


----- CELL DFXD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFXD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFXD2 : entity is TRUE;
end DFXD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFXD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, DB_delayed, DA_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFXD2_VITAL of DFXD2 is
   for VITAL
   end for;
end CFG_DFXD2_VITAL;


----- CELL DFXD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity DFXD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of DFXD4 : entity is TRUE;
end DFXD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of DFXD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/DFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/DFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, DB_delayed, DA_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_DFXD4_VITAL of DFXD4 is
   for VITAL
   end for;
end CFG_DFXD4_VITAL;


----- CELL EDFCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCND1 : entity is TRUE;
end EDFCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCND1_VITAL of EDFCND1 is
   for VITAL
   end for;
end CFG_EDFCND1_VITAL;


----- CELL EDFCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCND2 : entity is TRUE;
end EDFCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCND2_VITAL of EDFCND2 is
   for VITAL
   end for;
end CFG_EDFCND2_VITAL;


----- CELL EDFCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCND4 : entity is TRUE;
end EDFCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCND4_VITAL of EDFCND4 is
   for VITAL
   end for;
end CFG_EDFCND4_VITAL;


----- CELL EDFCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCNQD1 : entity is TRUE;
end EDFCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCNQD1_VITAL of EDFCNQD1 is
   for VITAL
   end for;
end CFG_EDFCNQD1_VITAL;


----- CELL EDFCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCNQD2 : entity is TRUE;
end EDFCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCNQD2_VITAL of EDFCNQD2 is
   for VITAL
   end for;
end CFG_EDFCNQD2_VITAL;


----- CELL EDFCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFCNQD4 : entity is TRUE;
end EDFCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/EDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFCNQD4_VITAL of EDFCNQD4 is
   for VITAL
   end for;
end CFG_EDFCNQD4_VITAL;


----- CELL EDFD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFD1 : entity is TRUE;
end EDFD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFD1_VITAL of EDFD1 is
   for VITAL
   end for;
end CFG_EDFD1_VITAL;


----- CELL EDFD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFD2 : entity is TRUE;
end EDFD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFD2_VITAL of EDFD2 is
   for VITAL
   end for;
end CFG_EDFD2_VITAL;


----- CELL EDFD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFD4 : entity is TRUE;
end EDFD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFD4_VITAL of EDFD4 is
   for VITAL
   end for;
end CFG_EDFD4_VITAL;


----- CELL EDFKCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCND1 : entity is TRUE;
end EDFKCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCND1_VITAL of EDFKCND1 is
   for VITAL
   end for;
end CFG_EDFKCND1_VITAL;


----- CELL EDFKCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCND2 : entity is TRUE;
end EDFKCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCND2_VITAL of EDFKCND2 is
   for VITAL
   end for;
end CFG_EDFKCND2_VITAL;


----- CELL EDFKCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCND4 : entity is TRUE;
end EDFKCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCND4_VITAL of EDFKCND4 is
   for VITAL
   end for;
end CFG_EDFKCND4_VITAL;


----- CELL EDFKCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCNQD1 : entity is TRUE;
end EDFKCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCNQD1_VITAL of EDFKCNQD1 is
   for VITAL
   end for;
end CFG_EDFKCNQD1_VITAL;


----- CELL EDFKCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCNQD2 : entity is TRUE;
end EDFKCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCNQD2_VITAL of EDFKCNQD2 is
   for VITAL
   end for;
end CFG_EDFKCNQD2_VITAL;


----- CELL EDFKCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFKCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFKCNQD4 : entity is TRUE;
end EDFKCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFKCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => EDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFKCNQD4_VITAL of EDFKCNQD4 is
   for VITAL
   end for;
end CFG_EDFKCNQD4_VITAL;


----- CELL EDFQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFQD1 : entity is TRUE;
end EDFQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFQD1_VITAL of EDFQD1 is
   for VITAL
   end for;
end CFG_EDFQD1_VITAL;


----- CELL EDFQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFQD2 : entity is TRUE;
end EDFQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFQD2_VITAL of EDFQD2 is
   for VITAL
   end for;
end CFG_EDFQD2_VITAL;


----- CELL EDFQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity EDFQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of EDFQD4 : entity is TRUE;
end EDFQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of EDFQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/EDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/EDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => DFXD1_Q_tab,
        DataIn => (
               CP_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_EDFQD4_VITAL of EDFQD4 is
   for VITAL
   end for;
end CFG_EDFQD4_VITAL;


----- CELL FA1D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity FA1D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO_B_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO_B_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_0_AN_B_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_1_AN_B_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CI                             :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of FA1D1 : entity is TRUE;
end FA1D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of FA1D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (CI_ipd, CI, tipd_CI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, CI_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd :=
       ((CI_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (CI_ipd));
      S_zd := (B_ipd) XOR (A_ipd) XOR (CI_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_CO_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 2 => (A_ipd'last_event, tpd_A_CO,
                        (TO_X01(((CI_ipd) AND ((NOT B_ipd))) OR (((NOT
                         CI_ipd)) AND (B_ipd)))/='1')),
                 3 => (B_ipd'last_event, tpd_B_CO_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 4 => (B_ipd'last_event, tpd_B_CO_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 5 => (B_ipd'last_event, tpd_B_CO,
                        (TO_X01(((CI_ipd) AND ((NOT A_ipd))) OR (((NOT
                         CI_ipd)) AND (A_ipd)))/='1')),
                 6 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 8 => (CI_ipd'last_event, tpd_CI_CO,
                        (TO_X01(((B_ipd) AND ((NOT A_ipd))) OR (((NOT B_ipd))
                         AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 2 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 3 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (B_ipd))='1')),
                 4 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT B_ipd))) OR
                         ((CI_ipd) AND ((NOT B_ipd))) OR (((NOT CI_ipd)) AND
                         (B_ipd)) OR ((CI_ipd) AND (B_ipd)))/='1')),
                 5 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT A_ipd)))='1')),
                 6 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 8 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (A_ipd))='1')),
                 9 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT A_ipd))) OR
                         ((CI_ipd) AND ((NOT A_ipd))) OR (((NOT CI_ipd)) AND
                         (A_ipd)) OR ((CI_ipd) AND (A_ipd)))/='1')),
                 10 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND ((NOT A_ipd)))='1')),
                 11 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 12 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 13 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND (A_ipd))='1')),
                 14 => (CI_ipd'last_event, tpd_CI_S,
                        (TO_X01((((NOT B_ipd)) AND ((NOT A_ipd))) OR ((B_ipd)
                         AND ((NOT A_ipd))) OR (((NOT B_ipd)) AND (A_ipd)) OR
                         ((B_ipd) AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_FA1D1_VITAL of FA1D1 is
   for VITAL
   end for;
end CFG_FA1D1_VITAL;


----- CELL FA1D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity FA1D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO_B_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO_B_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_0_AN_B_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_1_AN_B_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CI                             :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of FA1D2 : entity is TRUE;
end FA1D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of FA1D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (CI_ipd, CI, tipd_CI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, CI_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd :=
       ((CI_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (CI_ipd));
      S_zd := (B_ipd) XOR (A_ipd) XOR (CI_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_CO_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 2 => (A_ipd'last_event, tpd_A_CO,
                        (TO_X01(((CI_ipd) AND ((NOT B_ipd))) OR (((NOT
                         CI_ipd)) AND (B_ipd)))/='1')),
                 3 => (B_ipd'last_event, tpd_B_CO_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 4 => (B_ipd'last_event, tpd_B_CO_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 5 => (B_ipd'last_event, tpd_B_CO,
                        (TO_X01(((CI_ipd) AND ((NOT A_ipd))) OR (((NOT
                         CI_ipd)) AND (A_ipd)))/='1')),
                 6 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 8 => (CI_ipd'last_event, tpd_CI_CO,
                        (TO_X01(((B_ipd) AND ((NOT A_ipd))) OR (((NOT B_ipd))
                         AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 2 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 3 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (B_ipd))='1')),
                 4 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT B_ipd))) OR
                         ((CI_ipd) AND ((NOT B_ipd))) OR (((NOT CI_ipd)) AND
                         (B_ipd)) OR ((CI_ipd) AND (B_ipd)))/='1')),
                 5 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT A_ipd)))='1')),
                 6 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 8 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (A_ipd))='1')),
                 9 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT A_ipd))) OR
                         ((CI_ipd) AND ((NOT A_ipd))) OR (((NOT CI_ipd)) AND
                         (A_ipd)) OR ((CI_ipd) AND (A_ipd)))/='1')),
                 10 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND ((NOT A_ipd)))='1')),
                 11 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 12 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 13 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND (A_ipd))='1')),
                 14 => (CI_ipd'last_event, tpd_CI_S,
                        (TO_X01((((NOT B_ipd)) AND ((NOT A_ipd))) OR ((B_ipd)
                         AND ((NOT A_ipd))) OR (((NOT B_ipd)) AND (A_ipd)) OR
                         ((B_ipd) AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_FA1D2_VITAL of FA1D2 is
   for VITAL
   end for;
end CFG_FA1D2_VITAL;


----- CELL FA1D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity FA1D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO_B_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO_B_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_0_AN_CI_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO_A_EQ_1_AN_CI_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_0_AN_B_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO_A_EQ_1_AN_B_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_CO                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1_AN_CI_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_0_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_0      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S_A_EQ_1_AN_B_EQ_1      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CI_S                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CI                             :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of FA1D4 : entity is TRUE;
end FA1D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of FA1D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (CI_ipd, CI, tipd_CI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, CI_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd :=
       ((CI_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (CI_ipd));
      S_zd := (B_ipd) XOR (A_ipd) XOR (CI_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_CO_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 2 => (A_ipd'last_event, tpd_A_CO,
                        (TO_X01(((CI_ipd) AND ((NOT B_ipd))) OR (((NOT
                         CI_ipd)) AND (B_ipd)))/='1')),
                 3 => (B_ipd'last_event, tpd_B_CO_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 4 => (B_ipd'last_event, tpd_B_CO_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 5 => (B_ipd'last_event, tpd_B_CO,
                        (TO_X01(((CI_ipd) AND ((NOT A_ipd))) OR (((NOT
                         CI_ipd)) AND (A_ipd)))/='1')),
                 6 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (CI_ipd'last_event, tpd_CI_CO_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 8 => (CI_ipd'last_event, tpd_CI_CO,
                        (TO_X01(((B_ipd) AND ((NOT A_ipd))) OR (((NOT B_ipd))
                         AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT B_ipd)))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT B_ipd)))='1')),
                 2 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (B_ipd))='1')),
                 3 => (A_ipd'last_event, tpd_A_S_B_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (B_ipd))='1')),
                 4 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT B_ipd))) OR
                         ((CI_ipd) AND ((NOT B_ipd))) OR (((NOT CI_ipd)) AND
                         (B_ipd)) OR ((CI_ipd) AND (B_ipd)))/='1')),
                 5 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND ((NOT A_ipd)))='1')),
                 6 => (B_ipd'last_event, tpd_B_S_A_EQ_0_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND ((NOT A_ipd)))='1')),
                 7 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_0,
                        (TO_X01(((NOT CI_ipd)) AND (A_ipd))='1')),
                 8 => (B_ipd'last_event, tpd_B_S_A_EQ_1_AN_CI_EQ_1,
                        (TO_X01((CI_ipd) AND (A_ipd))='1')),
                 9 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01((((NOT CI_ipd)) AND ((NOT A_ipd))) OR
                         ((CI_ipd) AND ((NOT A_ipd))) OR (((NOT CI_ipd)) AND
                         (A_ipd)) OR ((CI_ipd) AND (A_ipd)))/='1')),
                 10 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND ((NOT A_ipd)))='1')),
                 11 => (CI_ipd'last_event, tpd_CI_S_A_EQ_0_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND ((NOT A_ipd)))='1')),
                 12 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_0,
                        (TO_X01(((NOT B_ipd)) AND (A_ipd))='1')),
                 13 => (CI_ipd'last_event, tpd_CI_S_A_EQ_1_AN_B_EQ_1,
                        (TO_X01((B_ipd) AND (A_ipd))='1')),
                 14 => (CI_ipd'last_event, tpd_CI_S,
                        (TO_X01((((NOT B_ipd)) AND ((NOT A_ipd))) OR ((B_ipd)
                         AND ((NOT A_ipd))) OR (((NOT B_ipd)) AND (A_ipd)) OR
                         ((B_ipd) AND (A_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_FA1D4_VITAL of FA1D4 is
   for VITAL
   end for;
end CFG_FA1D4_VITAL;


----- CELL HA1D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity HA1D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of HA1D1 : entity is TRUE;
end HA1D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of HA1D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd := (B_ipd) AND (A_ipd);
      S_zd := (B_ipd) XOR (A_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO, TRUE),
                 1 => (B_ipd'last_event, tpd_B_CO, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0,
                        (TO_X01((NOT B_ipd))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_1,
                        (TO_X01(B_ipd)='1')),
                 2 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01(((NOT B_ipd)) OR (B_ipd))/='1')),
                 3 => (B_ipd'last_event, tpd_B_S_A_EQ_0,
                        (TO_X01((NOT A_ipd))='1')),
                 4 => (B_ipd'last_event, tpd_B_S_A_EQ_1,
                        (TO_X01(A_ipd)='1')),
                 5 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01(((NOT A_ipd)) OR (A_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_HA1D1_VITAL of HA1D1 is
   for VITAL
   end for;
end CFG_HA1D1_VITAL;


----- CELL HA1D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity HA1D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of HA1D2 : entity is TRUE;
end HA1D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of HA1D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd := (B_ipd) AND (A_ipd);
      S_zd := (B_ipd) XOR (A_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO, TRUE),
                 1 => (B_ipd'last_event, tpd_B_CO, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0,
                        (TO_X01((NOT B_ipd))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_1,
                        (TO_X01(B_ipd)='1')),
                 2 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01(((NOT B_ipd)) OR (B_ipd))/='1')),
                 3 => (B_ipd'last_event, tpd_B_S_A_EQ_0,
                        (TO_X01((NOT A_ipd))='1')),
                 4 => (B_ipd'last_event, tpd_B_S_A_EQ_1,
                        (TO_X01(A_ipd)='1')),
                 5 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01(((NOT A_ipd)) OR (A_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_HA1D2_VITAL of HA1D2 is
   for VITAL
   end for;
end CFG_HA1D2_VITAL;


----- CELL HA1D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity HA1D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_CO                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S_B_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_0                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S_A_EQ_1                 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_S                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      CO                             :	out   STD_ULOGIC;
      S                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of HA1D4 : entity is TRUE;
end HA1D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of HA1D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS CO_zd : STD_LOGIC is Results(1);
   ALIAS S_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE CO_GlitchData	: VitalGlitchDataType;
   VARIABLE S_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      CO_zd := (B_ipd) AND (A_ipd);
      S_zd := (B_ipd) XOR (A_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => CO,
       GlitchData => CO_GlitchData,
       OutSignalName => "CO",
       OutTemp => CO_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_CO, TRUE),
                 1 => (B_ipd'last_event, tpd_B_CO, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => S,
       GlitchData => S_GlitchData,
       OutSignalName => "S",
       OutTemp => S_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_S_B_EQ_0,
                        (TO_X01((NOT B_ipd))='1')),
                 1 => (A_ipd'last_event, tpd_A_S_B_EQ_1,
                        (TO_X01(B_ipd)='1')),
                 2 => (A_ipd'last_event, tpd_A_S,
                        (TO_X01(((NOT B_ipd)) OR (B_ipd))/='1')),
                 3 => (B_ipd'last_event, tpd_B_S_A_EQ_0,
                        (TO_X01((NOT A_ipd))='1')),
                 4 => (B_ipd'last_event, tpd_B_S_A_EQ_1,
                        (TO_X01(A_ipd)='1')),
                 5 => (B_ipd'last_event, tpd_B_S,
                        (TO_X01(((NOT A_ipd)) OR (A_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_HA1D4_VITAL of HA1D4 is
   for VITAL
   end for;
end CFG_HA1D4_VITAL;


----- CELL IAO21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO21AD0 : entity is TRUE;
end IAO21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO21AD0_VITAL of IAO21AD0 is
   for VITAL
   end for;
end CFG_IAO21AD0_VITAL;


----- CELL IAO21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO21AD1 : entity is TRUE;
end IAO21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO21AD1_VITAL of IAO21AD1 is
   for VITAL
   end for;
end CFG_IAO21AD1_VITAL;


----- CELL IAO21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO21AD2 : entity is TRUE;
end IAO21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO21AD2_VITAL of IAO21AD2 is
   for VITAL
   end for;
end CFG_IAO21AD2_VITAL;


----- CELL IAO21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO21AD4 : entity is TRUE;
end IAO21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO21AD4_VITAL of IAO21AD4 is
   for VITAL
   end for;
end CFG_IAO21AD4_VITAL;


----- CELL IAO22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO22AD0 : entity is TRUE;
end IAO22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO22AD0_VITAL of IAO22AD0 is
   for VITAL
   end for;
end CFG_IAO22AD0_VITAL;


----- CELL IAO22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO22AD1 : entity is TRUE;
end IAO22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) AND (B1_ipd)) OR ((NOT ((A2_ipd) OR (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO22AD1_VITAL of IAO22AD1 is
   for VITAL
   end for;
end CFG_IAO22AD1_VITAL;


----- CELL IAO22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO22AD2 : entity is TRUE;
end IAO22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((A2_ipd) OR (A1_ipd)) AND ((NOT ((B2_ipd) AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO22AD2_VITAL of IAO22AD2 is
   for VITAL
   end for;
end CFG_IAO22AD2_VITAL;


----- CELL IAO22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IAO22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IAO22AD4 : entity is TRUE;
end IAO22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IAO22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((A2_ipd) OR (A1_ipd)) AND ((NOT ((B2_ipd) AND (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IAO22AD4_VITAL of IAO22AD4 is
   for VITAL
   end for;
end CFG_IAO22AD4_VITAL;


----- CELL IIND4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IIND4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IIND4D0 : entity is TRUE;
end IIND4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IIND4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND (B1_ipd) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IIND4D0_VITAL of IIND4D0 is
   for VITAL
   end for;
end CFG_IIND4D0_VITAL;


----- CELL IIND4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IIND4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IIND4D1 : entity is TRUE;
end IIND4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IIND4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND (B1_ipd) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IIND4D1_VITAL of IIND4D1 is
   for VITAL
   end for;
end CFG_IIND4D1_VITAL;


----- CELL IIND4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IIND4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IIND4D2 : entity is TRUE;
end IIND4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IIND4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND (B1_ipd) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IIND4D2_VITAL of IIND4D2 is
   for VITAL
   end for;
end CFG_IIND4D2_VITAL;


----- CELL IIND4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IIND4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IIND4D4 : entity is TRUE;
end IIND4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IIND4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND (B1_ipd) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IIND4D4_VITAL of IIND4D4 is
   for VITAL
   end for;
end CFG_IIND4D4_VITAL;


----- CELL IINR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IINR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IINR4D0 : entity is TRUE;
end IINR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IINR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) OR ((NOT A1_ipd)) OR (B1_ipd) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IINR4D0_VITAL of IINR4D0 is
   for VITAL
   end for;
end CFG_IINR4D0_VITAL;


----- CELL IINR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IINR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IINR4D1 : entity is TRUE;
end IINR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IINR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A1_ipd)) OR ((NOT A2_ipd)) OR (B1_ipd) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IINR4D1_VITAL of IINR4D1 is
   for VITAL
   end for;
end CFG_IINR4D1_VITAL;


----- CELL IINR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IINR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IINR4D2 : entity is TRUE;
end IINR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IINR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A2_ipd)) OR ((NOT A1_ipd)) OR (B1_ipd) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IINR4D2_VITAL of IINR4D2 is
   for VITAL
   end for;
end CFG_IINR4D2_VITAL;


----- CELL IINR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IINR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IINR4D4 : entity is TRUE;
end IINR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IINR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((NOT A1_ipd)) OR ((NOT A2_ipd)) OR (B1_ipd) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IINR4D4_VITAL of IINR4D4 is
   for VITAL
   end for;
end CFG_IINR4D4_VITAL;


----- CELL IND2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND2D0 : entity is TRUE;
end IND2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND2D0_VITAL of IND2D0 is
   for VITAL
   end for;
end CFG_IND2D0_VITAL;


----- CELL IND2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND2D1 : entity is TRUE;
end IND2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND2D1_VITAL of IND2D1 is
   for VITAL
   end for;
end CFG_IND2D1_VITAL;


----- CELL IND2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND2D2 : entity is TRUE;
end IND2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND2D2_VITAL of IND2D2 is
   for VITAL
   end for;
end CFG_IND2D2_VITAL;


----- CELL IND2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND2D4 : entity is TRUE;
end IND2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND2D4_VITAL of IND2D4 is
   for VITAL
   end for;
end CFG_IND2D4_VITAL;


----- CELL IND3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND3D0 : entity is TRUE;
end IND3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND3D0_VITAL of IND3D0 is
   for VITAL
   end for;
end CFG_IND3D0_VITAL;


----- CELL IND3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND3D1 : entity is TRUE;
end IND3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND3D1_VITAL of IND3D1 is
   for VITAL
   end for;
end CFG_IND3D1_VITAL;


----- CELL IND3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND3D2 : entity is TRUE;
end IND3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND3D2_VITAL of IND3D2 is
   for VITAL
   end for;
end CFG_IND3D2_VITAL;


----- CELL IND3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND3D4 : entity is TRUE;
end IND3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND3D4_VITAL of IND3D4 is
   for VITAL
   end for;
end CFG_IND3D4_VITAL;


----- CELL IND4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND4D0 : entity is TRUE;
end IND4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd) AND (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND4D0_VITAL of IND4D0 is
   for VITAL
   end for;
end CFG_IND4D0_VITAL;


----- CELL IND4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND4D1 : entity is TRUE;
end IND4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd) AND (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND4D1_VITAL of IND4D1 is
   for VITAL
   end for;
end CFG_IND4D1_VITAL;


----- CELL IND4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND4D2 : entity is TRUE;
end IND4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd) AND (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND4D2_VITAL of IND4D2 is
   for VITAL
   end for;
end CFG_IND4D2_VITAL;


----- CELL IND4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IND4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IND4D4 : entity is TRUE;
end IND4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IND4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT ((B1_ipd) AND ((NOT A1_ipd)) AND (B2_ipd) AND (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IND4D4_VITAL of IND4D4 is
   for VITAL
   end for;
end CFG_IND4D4_VITAL;


----- CELL INR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR2D0 : entity is TRUE;
end INR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR2D0_VITAL of INR2D0 is
   for VITAL
   end for;
end CFG_INR2D0_VITAL;


----- CELL INR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR2D1 : entity is TRUE;
end INR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR2D1_VITAL of INR2D1 is
   for VITAL
   end for;
end CFG_INR2D1_VITAL;


----- CELL INR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR2D2 : entity is TRUE;
end INR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR2D2_VITAL of INR2D2 is
   for VITAL
   end for;
end CFG_INR2D2_VITAL;


----- CELL INR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR2D4 : entity is TRUE;
end INR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR2D4_VITAL of INR2D4 is
   for VITAL
   end for;
end CFG_INR2D4_VITAL;


----- CELL INR3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR3D0 : entity is TRUE;
end INR3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR3D0_VITAL of INR3D0 is
   for VITAL
   end for;
end CFG_INR3D0_VITAL;


----- CELL INR3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR3D1 : entity is TRUE;
end INR3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR3D1_VITAL of INR3D1 is
   for VITAL
   end for;
end CFG_INR3D1_VITAL;


----- CELL INR3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR3D2 : entity is TRUE;
end INR3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR3D2_VITAL of INR3D2 is
   for VITAL
   end for;
end CFG_INR3D2_VITAL;


----- CELL INR3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR3D4 : entity is TRUE;
end INR3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR3D4_VITAL of INR3D4 is
   for VITAL
   end for;
end CFG_INR3D4_VITAL;


----- CELL INR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR4D0 : entity is TRUE;
end INR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd) OR (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR4D0_VITAL of INR4D0 is
   for VITAL
   end for;
end CFG_INR4D0_VITAL;


----- CELL INR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR4D1 : entity is TRUE;
end INR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd) OR (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR4D1_VITAL of INR4D1 is
   for VITAL
   end for;
end CFG_INR4D1_VITAL;


----- CELL INR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR4D2 : entity is TRUE;
end INR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd) OR (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR4D2_VITAL of INR4D2 is
   for VITAL
   end for;
end CFG_INR4D2_VITAL;


----- CELL INR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INR4D4 : entity is TRUE;
end INR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B1_ipd) OR ((NOT A1_ipd)) OR (B2_ipd) OR (B3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 2 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 3 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INR4D4_VITAL of INR4D4 is
   for VITAL
   end for;
end CFG_INR4D4_VITAL;


----- CELL INVD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD0 : entity is TRUE;
end INVD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD0_VITAL of INVD0 is
   for VITAL
   end for;
end CFG_INVD0_VITAL;


----- CELL INVD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD1 : entity is TRUE;
end INVD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD1_VITAL of INVD1 is
   for VITAL
   end for;
end CFG_INVD1_VITAL;


----- CELL INVD12 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD12 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD12 : entity is TRUE;
end INVD12;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD12 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD12_VITAL of INVD12 is
   for VITAL
   end for;
end CFG_INVD12_VITAL;


----- CELL INVD16 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD16 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD16 : entity is TRUE;
end INVD16;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD16 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD16_VITAL of INVD16 is
   for VITAL
   end for;
end CFG_INVD16_VITAL;


----- CELL INVD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD2 : entity is TRUE;
end INVD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD2_VITAL of INVD2 is
   for VITAL
   end for;
end CFG_INVD2_VITAL;


----- CELL INVD20 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD20 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD20 : entity is TRUE;
end INVD20;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD20 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD20_VITAL of INVD20 is
   for VITAL
   end for;
end CFG_INVD20_VITAL;


----- CELL INVD24 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD24 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD24 : entity is TRUE;
end INVD24;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD24 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD24_VITAL of INVD24 is
   for VITAL
   end for;
end CFG_INVD24_VITAL;


----- CELL INVD3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD3 : entity is TRUE;
end INVD3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD3_VITAL of INVD3 is
   for VITAL
   end for;
end CFG_INVD3_VITAL;


----- CELL INVD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD4 : entity is TRUE;
end INVD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD4_VITAL of INVD4 is
   for VITAL
   end for;
end CFG_INVD4_VITAL;


----- CELL INVD6 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD6 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD6 : entity is TRUE;
end INVD6;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD6 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD6_VITAL of INVD6 is
   for VITAL
   end for;
end CFG_INVD6_VITAL;


----- CELL INVD8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity INVD8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of INVD8 : entity is TRUE;
end INVD8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of INVD8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I_ipd, I, tipd_I);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT I_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I_ipd'last_event, tpd_I_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_INVD8_VITAL of INVD8 is
   for VITAL
   end for;
end CFG_INVD8_VITAL;


----- CELL IOA21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA21AD0 : entity is TRUE;
end IOA21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA21AD0_VITAL of IOA21AD0 is
   for VITAL
   end for;
end CFG_IOA21AD0_VITAL;


----- CELL IOA21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA21AD1 : entity is TRUE;
end IOA21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA21AD1_VITAL of IOA21AD1 is
   for VITAL
   end for;
end CFG_IOA21AD1_VITAL;


----- CELL IOA21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA21AD2 : entity is TRUE;
end IOA21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA21AD2_VITAL of IOA21AD2 is
   for VITAL
   end for;
end CFG_IOA21AD2_VITAL;


----- CELL IOA21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA21AD4 : entity is TRUE;
end IOA21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA21AD4_VITAL of IOA21AD4 is
   for VITAL
   end for;
end CFG_IOA21AD4_VITAL;


----- CELL IOA22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA22AD0 : entity is TRUE;
end IOA22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA22AD0_VITAL of IOA22AD0 is
   for VITAL
   end for;
end CFG_IOA22AD0_VITAL;


----- CELL IOA22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA22AD1 : entity is TRUE;
end IOA22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((NOT ((A2_ipd) AND (A1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA22AD1_VITAL of IOA22AD1 is
   for VITAL
   end for;
end CFG_IOA22AD1_VITAL;


----- CELL IOA22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA22AD2 : entity is TRUE;
end IOA22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((A2_ipd) AND (A1_ipd)) OR ((NOT ((B2_ipd) OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA22AD2_VITAL of IOA22AD2 is
   for VITAL
   end for;
end CFG_IOA22AD2_VITAL;


----- CELL IOA22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity IOA22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of IOA22AD4 : entity is TRUE;
end IOA22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of IOA22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((A2_ipd) AND (A1_ipd)) OR ((NOT ((B2_ipd) OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_IOA22AD4_VITAL of IOA22AD4 is
   for VITAL
   end for;
end CFG_IOA22AD4_VITAL;


----- CELL LHCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCND1 : entity is TRUE;
end LHCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_D_E_negedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCND1_VITAL of LHCND1 is
   for VITAL
   end for;
end CFG_LHCND1_VITAL;


----- CELL LHCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCND2 : entity is TRUE;
end LHCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_D_E_negedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCND2_VITAL of LHCND2 is
   for VITAL
   end for;
end CFG_LHCND2_VITAL;


----- CELL LHCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCND4 : entity is TRUE;
end LHCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_D_E_negedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCND4_VITAL of LHCND4 is
   for VITAL
   end for;
end CFG_LHCND4_VITAL;


----- CELL LHCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCSND1 : entity is TRUE;
end LHCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_CDN_SDN_posedge or Tviol_D_E_negedge or Pviol_SDN or Tviol_SDN_E_negedge or Tviol_SDN_CDN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCSND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCSND1_VITAL of LHCSND1 is
   for VITAL
   end for;
end CFG_LHCSND1_VITAL;


----- CELL LHCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCSND2 : entity is TRUE;
end LHCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_CDN_SDN_posedge or Tviol_D_E_negedge or Pviol_SDN or Tviol_SDN_E_negedge or Tviol_SDN_CDN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCSND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCSND2_VITAL of LHCSND2 is
   for VITAL
   end for;
end CFG_LHCSND2_VITAL;


----- CELL LHCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHCSND4 : entity is TRUE;
end LHCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_E_negedge,
          TimingData              => Tmkr_CDN_E_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_E_posedge_negedge,
          Removal                 => thold_CDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_E_negedge or Pviol_E or Tviol_CDN_SDN_posedge or Tviol_D_E_negedge or Pviol_SDN or Tviol_SDN_E_negedge or Tviol_SDN_CDN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHCSND1_Q_tab,
        DataIn => (
               CDN_ipd, D_ipd, E_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHCSND4_VITAL of LHCSND4 is
   for VITAL
   end for;
end CFG_LHCSND4_VITAL;


----- CELL LHD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHD1 : entity is TRUE;
end LHD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHD1_Q_tab,
        DataIn => (
               D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHD1_VITAL of LHD1 is
   for VITAL
   end for;
end CFG_LHD1_VITAL;


----- CELL LHD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHD2 : entity is TRUE;
end LHD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHD1_Q_tab,
        DataIn => (
               D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHD2_VITAL of LHD2 is
   for VITAL
   end for;
end CFG_LHD2_VITAL;


----- CELL LHD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LHD4 : entity is TRUE;
end LHD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHD1_Q_tab,
        DataIn => (
               D_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHD4_VITAL of LHD4 is
   for VITAL
   end for;
end CFG_LHD4_VITAL;


----- CELL LHSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHSND1 : entity is TRUE;
end LHSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E or Tviol_SDN_E_negedge or Pviol_SDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHSND1_Q_tab,
        DataIn => (
               D_ipd, SDN_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHSND1_VITAL of LHSND1 is
   for VITAL
   end for;
end CFG_LHSND1_VITAL;


----- CELL LHSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHSND2 : entity is TRUE;
end LHSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E or Tviol_SDN_E_negedge or Pviol_SDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHSND1_Q_tab,
        DataIn => (
               D_ipd, SDN_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHSND2_VITAL of LHSND2 is
   for VITAL
   end for;
end CFG_LHSND2_VITAL;


----- CELL LHSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LHSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_Q_posedge                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_E_QN_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_E_posedge_negedge                      :	VitalDelayType := 0.000 ns;
      thold_D_E_negedge_negedge                      :	VitalDelayType := 0.000 ns;
      tsetup_D_E_posedge_negedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_E_negedge_negedge                     :	VitalDelayType := 0.000 ns;
      trecovery_SDN_E_posedge_negedge                :	VitalDelayType := 0.000 ns;
      thold_SDN_E_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      tpw_E_posedge                  :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LHSND4 : entity is TRUE;
end LHSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LHSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, E_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_E_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_E_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_E	: STD_ULOGIC := '0';
   VARIABLE PInfo_E	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_E_negedge,
          TimingData              => Tmkr_D_E_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_E_posedge_negedge,
          SetupLow                => tsetup_D_E_negedge_negedge,
          HoldHigh                => thold_D_E_negedge_negedge,
          HoldLow                 => thold_D_E_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_E_negedge,
          TimingData              => Tmkr_SDN_E_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => E_ipd,
          RefSignalName          => "E",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_E_posedge_negedge,
          Removal                 => thold_SDN_E_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/LHSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_E,
          PeriodData              => PInfo_E,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_E_posedge,
          PulseWidthLow           => 0 ns,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LHSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LHSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_E_negedge or Pviol_E or Tviol_SDN_E_negedge or Pviol_SDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LHSND1_Q_tab,
        DataIn => (
               D_ipd, SDN_ipd, E_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (E_ipd'last_event, tpd_E_Q_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (E_ipd'last_event, tpd_E_QN_posedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LHSND4_VITAL of LHSND4 is
   for VITAL
   end for;
end CFG_LHSND4_VITAL;


----- CELL LNCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCND1 : entity is TRUE;
end LNCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_D_EN_posedge or Pviol_EN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCND1_VITAL of LNCND1 is
   for VITAL
   end for;
end CFG_LNCND1_VITAL;


----- CELL LNCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCND2 : entity is TRUE;
end LNCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_D_EN_posedge or Pviol_EN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCND2_VITAL of LNCND2 is
   for VITAL
   end for;
end CFG_LNCND2_VITAL;


----- CELL LNCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCND4 : entity is TRUE;
end LNCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_D_EN_posedge or Pviol_EN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCND4_VITAL of LNCND4 is
   for VITAL
   end for;
end CFG_LNCND4_VITAL;


----- CELL LNCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCSND1 : entity is TRUE;
end LNCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_EN_posedge or Tviol_SDN_CDN_posedge or Pviol_EN or Tviol_SDN_EN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCSND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCSND1_VITAL of LNCSND1 is
   for VITAL
   end for;
end CFG_LNCSND1_VITAL;


----- CELL LNCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCSND2 : entity is TRUE;
end LNCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_EN_posedge or Tviol_SDN_CDN_posedge or Pviol_EN or Tviol_SDN_EN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCSND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCSND2_VITAL of LNCSND2 is
   for VITAL
   end for;
end CFG_LNCSND2_VITAL;


----- CELL LNCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNCSND4 : entity is TRUE;
end LNCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 3);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_EN_posedge,
          TimingData              => Tmkr_CDN_EN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_EN_posedge_posedge,
          Removal                 => thold_CDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_EN_posedge or Tviol_CDN_SDN_posedge or Pviol_SDN or Tviol_D_EN_posedge or Tviol_SDN_CDN_posedge or Pviol_EN or Tviol_SDN_EN_posedge or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNCSND1_Q_tab,
        DataIn => (
               CDN_ipd, EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 2 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 3 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNCSND4_VITAL of LNCSND4 is
   for VITAL
   end for;
end CFG_LNCSND4_VITAL;


----- CELL LND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LND1 : entity is TRUE;
end LND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LND1_VITAL of LND1 is
   for VITAL
   end for;
end CFG_LND1_VITAL;


----- CELL LND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LND2 : entity is TRUE;
end LND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LND2_VITAL of LND2 is
   for VITAL
   end for;
end CFG_LND2_VITAL;


----- CELL LND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of LND4 : entity is TRUE;
end LND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 1);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LND4_VITAL of LND4 is
   for VITAL
   end for;
end CFG_LND4_VITAL;


----- CELL LNSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNSND1 : entity is TRUE;
end LNSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN or Pviol_SDN or Tviol_SDN_EN_posedge;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNSND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNSND1_VITAL of LNSND1 is
   for VITAL
   end for;
end CFG_LNSND1_VITAL;


----- CELL LNSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNSND2 : entity is TRUE;
end LNSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN or Pviol_SDN or Tviol_SDN_EN_posedge;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNSND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNSND2_VITAL of LNSND2 is
   for VITAL
   end for;
end CFG_LNSND2_VITAL;


----- CELL LNSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity LNSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_D_Q                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_Q_negedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_D_QN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_EN_QN_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_EN_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_EN_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_EN_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_EN_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_EN_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_EN_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_EN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      D                              :	in    STD_ULOGIC;
      EN                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of LNSND4 : entity is TRUE;
end LNSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of LNSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL EN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (EN_ipd, EN, tipd_EN);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (D_ipd, EN_ipd, SDN_ipd)

   -- timing check results
   VARIABLE Tviol_D_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_EN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_EN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_EN	: STD_ULOGIC := '0';
   VARIABLE PInfo_EN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 2);
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_EN_posedge,
          TimingData              => Tmkr_D_EN_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_EN_posedge_posedge,
          SetupLow                => tsetup_D_EN_negedge_posedge,
          HoldHigh                => thold_D_EN_negedge_posedge,
          HoldLow                 => thold_D_EN_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_EN_posedge,
          TimingData              => Tmkr_SDN_EN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => EN_ipd,
          RefSignalName          => "EN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_EN_posedge_posedge,
          Removal                 => thold_SDN_EN_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/LNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_EN,
          PeriodData              => PInfo_EN,
          TestSignal              => EN_ipd,
          TestSignalName          => "EN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_EN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/LNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/LNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_EN_posedge or Pviol_EN or Pviol_SDN or Tviol_SDN_EN_posedge;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => LNSND1_Q_tab,
        DataIn => (
               EN_ipd, D_ipd, SDN_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_Q, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_Q_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (D_ipd'last_event, tpd_D_QN, TRUE),
                 1 => (EN_ipd'last_event, tpd_EN_QN_negedge, TRUE),
                 2 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_LNSND4_VITAL of LNSND4 is
   for VITAL
   end for;
end CFG_LNSND4_VITAL;


----- CELL MAOI222D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI222D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI222D0 : entity is TRUE;
end MAOI222D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI222D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (C_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_ZN, TRUE),
                 1 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 2 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI222D0_VITAL of MAOI222D0 is
   for VITAL
   end for;
end CFG_MAOI222D0_VITAL;


----- CELL MAOI222D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI222D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI222D1 : entity is TRUE;
end MAOI222D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI222D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (C_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_ZN, TRUE),
                 1 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 2 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI222D1_VITAL of MAOI222D1 is
   for VITAL
   end for;
end CFG_MAOI222D1_VITAL;


----- CELL MAOI222D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI222D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI222D2 : entity is TRUE;
end MAOI222D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI222D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (C_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_ZN, TRUE),
                 1 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 2 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI222D2_VITAL of MAOI222D2 is
   for VITAL
   end for;
end CFG_MAOI222D2_VITAL;


----- CELL MAOI222D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI222D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A                              :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI222D4 : entity is TRUE;
end MAOI222D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI222D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A_ipd, A, tipd_A);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C_ipd) AND (B_ipd)) OR ((B_ipd) AND (A_ipd)) OR ((A_ipd) AND
         (C_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A_ipd'last_event, tpd_A_ZN, TRUE),
                 1 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 2 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI222D4_VITAL of MAOI222D4 is
   for VITAL
   end for;
end CFG_MAOI222D4_VITAL;


----- CELL MAOI22D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI22D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI22D0 : entity is TRUE;
end MAOI22D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI22D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd)) OR ((NOT ((B2_ipd) OR (B1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI22D0_VITAL of MAOI22D0 is
   for VITAL
   end for;
end CFG_MAOI22D0_VITAL;


----- CELL MAOI22D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI22D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI22D1 : entity is TRUE;
end MAOI22D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI22D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) AND (A1_ipd)) OR ((NOT ((B2_ipd) OR (B1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI22D1_VITAL of MAOI22D1 is
   for VITAL
   end for;
end CFG_MAOI22D1_VITAL;


----- CELL MAOI22D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI22D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI22D2 : entity is TRUE;
end MAOI22D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI22D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((B2_ipd) OR (B1_ipd)) AND ((NOT ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI22D2_VITAL of MAOI22D2 is
   for VITAL
   end for;
end CFG_MAOI22D2_VITAL;


----- CELL MAOI22D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MAOI22D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MAOI22D4 : entity is TRUE;
end MAOI22D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MAOI22D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((B2_ipd) OR (B1_ipd)) AND ((NOT ((A2_ipd) AND (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MAOI22D4_VITAL of MAOI22D4 is
   for VITAL
   end for;
end CFG_MAOI22D4_VITAL;


----- CELL MOAI22D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MOAI22D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MOAI22D0 : entity is TRUE;
end MOAI22D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MOAI22D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd)) AND ((NOT ((B2_ipd) AND (B1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MOAI22D0_VITAL of MOAI22D0 is
   for VITAL
   end for;
end CFG_MOAI22D0_VITAL;


----- CELL MOAI22D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MOAI22D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MOAI22D1 : entity is TRUE;
end MOAI22D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MOAI22D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd)) AND ((NOT ((B2_ipd) AND (B1_ipd))))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MOAI22D1_VITAL of MOAI22D1 is
   for VITAL
   end for;
end CFG_MOAI22D1_VITAL;


----- CELL MOAI22D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MOAI22D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MOAI22D2 : entity is TRUE;
end MOAI22D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MOAI22D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((B2_ipd) AND (B1_ipd)) OR ((NOT ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MOAI22D2_VITAL of MOAI22D2 is
   for VITAL
   end for;
end CFG_MOAI22D2_VITAL;


----- CELL MOAI22D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MOAI22D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MOAI22D4 : entity is TRUE;
end MOAI22D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MOAI22D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := ((B2_ipd) AND (B1_ipd)) OR ((NOT ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MOAI22D4_VITAL of MOAI22D4 is
   for VITAL
   end for;
end CFG_MOAI22D4_VITAL;


----- CELL MUX2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2D0 : entity is TRUE;
end MUX2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2D0_VITAL of MUX2D0 is
   for VITAL
   end for;
end CFG_MUX2D0_VITAL;


----- CELL MUX2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2D1 : entity is TRUE;
end MUX2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2D1_VITAL of MUX2D1 is
   for VITAL
   end for;
end CFG_MUX2D1_VITAL;


----- CELL MUX2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2D2 : entity is TRUE;
end MUX2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2D2_VITAL of MUX2D2 is
   for VITAL
   end for;
end CFG_MUX2D2_VITAL;


----- CELL MUX2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_0_AN_I1_EQ_1     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z_I0_EQ_1_AN_I1_EQ_0     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2D4 : entity is TRUE;
end MUX2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (S_ipd'last_event, tpd_S_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_Z_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2D4_VITAL of MUX2D4 is
   for VITAL
   end for;
end CFG_MUX2D4_VITAL;


----- CELL MUX2ND0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2ND0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2ND0 : entity is TRUE;
end MUX2ND0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2ND0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2ND0_VITAL of MUX2ND0 is
   for VITAL
   end for;
end CFG_MUX2ND0_VITAL;


----- CELL MUX2ND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2ND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2ND1 : entity is TRUE;
end MUX2ND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2ND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2ND1_VITAL of MUX2ND1 is
   for VITAL
   end for;
end CFG_MUX2ND1_VITAL;


----- CELL MUX2ND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2ND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2ND2 : entity is TRUE;
end MUX2ND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2ND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2ND2_VITAL of MUX2ND2 is
   for VITAL
   end for;
end CFG_MUX2ND2_VITAL;


----- CELL MUX2ND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX2ND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      S                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX2ND4 : entity is TRUE;
end MUX2ND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX2ND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (S_ipd, S, tipd_S);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, S_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I1_ipd, I0_ipd),
                  dselect => (0 => S_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 3 => (S_ipd'last_event, tpd_S_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 4 => (S_ipd'last_event, tpd_S_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX2ND4_VITAL of MUX2ND4 is
   for VITAL
   end for;
end CFG_MUX2ND4_VITAL;


----- CELL MUX3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3D0 : entity is TRUE;
end MUX3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT
                         S1_ipd))))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3D0_VITAL of MUX3D0 is
   for VITAL
   end for;
end CFG_MUX3D0_VITAL;


----- CELL MUX3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3D1 : entity is TRUE;
end MUX3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT
                         S1_ipd))))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3D1_VITAL of MUX3D1 is
   for VITAL
   end for;
end CFG_MUX3D1_VITAL;


----- CELL MUX3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3D2 : entity is TRUE;
end MUX3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT
                         S1_ipd))))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3D2_VITAL of MUX3D2 is
   for VITAL
   end for;
end CFG_MUX3D2_VITAL;


----- CELL MUX3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3D4 : entity is TRUE;
end MUX3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT
                         S1_ipd))))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3D4_VITAL of MUX3D4 is
   for VITAL
   end for;
end CFG_MUX3D4_VITAL;


----- CELL MUX3ND0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3ND0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3ND0 : entity is TRUE;
end MUX3ND0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3ND0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd)))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3ND0_VITAL of MUX3ND0 is
   for VITAL
   end for;
end CFG_MUX3ND0_VITAL;


----- CELL MUX3ND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3ND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3ND1 : entity is TRUE;
end MUX3ND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3ND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd)))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3ND1_VITAL of MUX3ND1 is
   for VITAL
   end for;
end CFG_MUX3ND1_VITAL;


----- CELL MUX3ND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3ND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3ND2 : entity is TRUE;
end MUX3ND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3ND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd)))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3ND2_VITAL of MUX3ND2 is
   for VITAL
   end for;
end CFG_MUX3ND2_VITAL;


----- CELL MUX3ND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX3ND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX3ND4 : entity is TRUE;
end MUX3ND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX3ND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I2_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd)))='1')),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT S1_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd)))/='1')),
                 6 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd)))='1')),
                 7 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT S0_ipd)))='1')),
                 8 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd))='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (S0_ipd))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT S0_ipd))) OR (((NOT I1_ipd)) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX3ND4_VITAL of MUX3ND4 is
   for VITAL
   end for;
end CFG_MUX3ND4_VITAL;


----- CELL MUX4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4D0 : entity is TRUE;
end MUX4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_Z, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4D0_VITAL of MUX4D0 is
   for VITAL
   end for;
end CFG_MUX4D0_VITAL;


----- CELL MUX4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4D1 : entity is TRUE;
end MUX4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_Z, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4D1_VITAL of MUX4D1 is
   for VITAL
   end for;
end CFG_MUX4D1_VITAL;


----- CELL MUX4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4D2 : entity is TRUE;
end MUX4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_Z, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4D2_VITAL of MUX4D2 is
   for VITAL
   end for;
end CFG_MUX4D2_VITAL;


----- CELL MUX4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4D4 : entity is TRUE;
end MUX4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_Z, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_Z, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_Z, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_Z, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_Z,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_Z_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_Z,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4D4_VITAL of MUX4D4 is
   for VITAL
   end for;
end CFG_MUX4D4_VITAL;


----- CELL MUX4ND0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4ND0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4ND0 : entity is TRUE;
end MUX4ND0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4ND0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_ZN, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4ND0_VITAL of MUX4ND0 is
   for VITAL
   end for;
end CFG_MUX4ND0_VITAL;


----- CELL MUX4ND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4ND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4ND1 : entity is TRUE;
end MUX4ND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4ND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_ZN, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4ND1_VITAL of MUX4ND1 is
   for VITAL
   end for;
end CFG_MUX4ND1_VITAL;


----- CELL MUX4ND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4ND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4ND2 : entity is TRUE;
end MUX4ND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4ND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_ZN, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4ND2_VITAL of MUX4ND2 is
   for VITAL
   end for;
end CFG_MUX4ND2_VITAL;


----- CELL MUX4ND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity MUX4ND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_I0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_I3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S0_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_S1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_I3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S0                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_S1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      I0                             :	in    STD_ULOGIC;
      I1                             :	in    STD_ULOGIC;
      I2                             :	in    STD_ULOGIC;
      I3                             :	in    STD_ULOGIC;
      S0                             :	in    STD_ULOGIC;
      S1                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of MUX4ND4 : entity is TRUE;
end MUX4ND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of MUX4ND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL I0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL I3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S0_ipd	 : STD_ULOGIC := 'X';
   SIGNAL S1_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (I0_ipd, I0, tipd_I0);
   VitalWireDelay (I1_ipd, I1, tipd_I1);
   VitalWireDelay (I2_ipd, I2, tipd_I2);
   VitalWireDelay (I3_ipd, I3, tipd_I3);
   VitalWireDelay (S0_ipd, S0, tipd_S0);
   VitalWireDelay (S1_ipd, S1, tipd_S1);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (I0_ipd, I1_ipd, I2_ipd, I3_ipd, S0_ipd, S1_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := VitalMUX
                 (data => (I3_ipd, I2_ipd, I1_ipd, I0_ipd),
                  dselect => (S1_ipd, S0_ipd));
      ZN_zd := NOT ZN_zd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (I0_ipd'last_event, tpd_I0_ZN, TRUE),
                 1 => (I1_ipd'last_event, tpd_I1_ZN, TRUE),
                 2 => (I2_ipd'last_event, tpd_I2_ZN, TRUE),
                 3 => (I3_ipd'last_event, tpd_I3_ZN, TRUE),
                 4 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_0_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 5 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S1_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd)))='1')),
                 6 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_0_AN_I3_EQ_1_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         (I3_ipd) AND (S1_ipd))='1')),
                 7 => (S0_ipd'last_event, tpd_S0_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S1_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S1_ipd))='1')),
                 8 => (S0_ipd'last_event, tpd_S0_ZN,
                        (TO_X01(((I1_ipd) AND ((NOT I0_ipd)) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S1_ipd))) OR ((I1_ipd) AND
                         (I0_ipd) AND ((NOT I2_ipd)) AND (I3_ipd) AND
                         (S1_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S1_ipd)))/='1')),
                 9 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_0_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 10 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_0_AN_I3_EQ_0_AN_S0_EQ_0,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND ((NOT
                         I2_ipd)) AND ((NOT I3_ipd)) AND ((NOT S0_ipd)))='1')),
                 11 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_0_AN_I2_EQ_1_AN_I3_EQ_1_AN_S0_EQ_1,
                        (TO_X01(((NOT I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND
                         (I3_ipd) AND (S0_ipd))='1')),
                 12 => (S1_ipd'last_event, tpd_S1_ZN_I0_EQ_1_AN_I1_EQ_1_AN_I2_EQ_1_AN_I3_EQ_0_AN_S0_EQ_1,
                        (TO_X01((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND ((NOT
                         I3_ipd)) AND (S0_ipd))='1')),
                 13 => (S1_ipd'last_event, tpd_S1_ZN,
                        (TO_X01((((NOT I1_ipd)) AND ((NOT I0_ipd)) AND
                         (I2_ipd) AND ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR
                         (((NOT I1_ipd)) AND (I0_ipd) AND ((NOT I2_ipd)) AND
                         ((NOT I3_ipd)) AND ((NOT S0_ipd))) OR (((NOT
                         I1_ipd)) AND (I0_ipd) AND (I2_ipd) AND (I3_ipd) AND
                         (S0_ipd)) OR ((I1_ipd) AND (I0_ipd) AND (I2_ipd) AND
                         ((NOT I3_ipd)) AND (S0_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_MUX4ND4_VITAL of MUX4ND4 is
   for VITAL
   end for;
end CFG_MUX4ND4_VITAL;


----- CELL ND2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D0 : entity is TRUE;
end ND2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D0_VITAL of ND2D0 is
   for VITAL
   end for;
end CFG_ND2D0_VITAL;


----- CELL ND2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D1 : entity is TRUE;
end ND2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D1_VITAL of ND2D1 is
   for VITAL
   end for;
end CFG_ND2D1_VITAL;


----- CELL ND2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D2 : entity is TRUE;
end ND2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D2_VITAL of ND2D2 is
   for VITAL
   end for;
end CFG_ND2D2_VITAL;


----- CELL ND2D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D3 : entity is TRUE;
end ND2D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D3_VITAL of ND2D3 is
   for VITAL
   end for;
end CFG_ND2D3_VITAL;


----- CELL ND2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D4 : entity is TRUE;
end ND2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D4_VITAL of ND2D4 is
   for VITAL
   end for;
end CFG_ND2D4_VITAL;


----- CELL ND2D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND2D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND2D8 : entity is TRUE;
end ND2D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND2D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND2D8_VITAL of ND2D8 is
   for VITAL
   end for;
end CFG_ND2D8_VITAL;


----- CELL ND3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D0 : entity is TRUE;
end ND3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D0_VITAL of ND3D0 is
   for VITAL
   end for;
end CFG_ND3D0_VITAL;


----- CELL ND3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D1 : entity is TRUE;
end ND3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D1_VITAL of ND3D1 is
   for VITAL
   end for;
end CFG_ND3D1_VITAL;


----- CELL ND3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D2 : entity is TRUE;
end ND3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D2_VITAL of ND3D2 is
   for VITAL
   end for;
end CFG_ND3D2_VITAL;


----- CELL ND3D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D3 : entity is TRUE;
end ND3D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D3_VITAL of ND3D3 is
   for VITAL
   end for;
end CFG_ND3D3_VITAL;


----- CELL ND3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D4 : entity is TRUE;
end ND3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D4_VITAL of ND3D4 is
   for VITAL
   end for;
end CFG_ND3D4_VITAL;


----- CELL ND3D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND3D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND3D8 : entity is TRUE;
end ND3D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND3D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND3D8_VITAL of ND3D8 is
   for VITAL
   end for;
end CFG_ND3D8_VITAL;


----- CELL ND4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D0 : entity is TRUE;
end ND4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D0_VITAL of ND4D0 is
   for VITAL
   end for;
end CFG_ND4D0_VITAL;


----- CELL ND4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D1 : entity is TRUE;
end ND4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D1_VITAL of ND4D1 is
   for VITAL
   end for;
end CFG_ND4D1_VITAL;


----- CELL ND4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D2 : entity is TRUE;
end ND4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D2_VITAL of ND4D2 is
   for VITAL
   end for;
end CFG_ND4D2_VITAL;


----- CELL ND4D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D3 : entity is TRUE;
end ND4D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D3_VITAL of ND4D3 is
   for VITAL
   end for;
end CFG_ND4D3_VITAL;


----- CELL ND4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D4 : entity is TRUE;
end ND4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D4_VITAL of ND4D4 is
   for VITAL
   end for;
end CFG_ND4D4_VITAL;


----- CELL ND4D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity ND4D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of ND4D8 : entity is TRUE;
end ND4D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of ND4D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) AND (A1_ipd) AND (A3_ipd) AND (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_ND4D8_VITAL of ND4D8 is
   for VITAL
   end for;
end CFG_ND4D8_VITAL;


----- CELL NR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D0 : entity is TRUE;
end NR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D0_VITAL of NR2D0 is
   for VITAL
   end for;
end CFG_NR2D0_VITAL;


----- CELL NR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D1 : entity is TRUE;
end NR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D1_VITAL of NR2D1 is
   for VITAL
   end for;
end CFG_NR2D1_VITAL;


----- CELL NR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D2 : entity is TRUE;
end NR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D2_VITAL of NR2D2 is
   for VITAL
   end for;
end CFG_NR2D2_VITAL;


----- CELL NR2D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D3 : entity is TRUE;
end NR2D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D3_VITAL of NR2D3 is
   for VITAL
   end for;
end CFG_NR2D3_VITAL;


----- CELL NR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D4 : entity is TRUE;
end NR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D4_VITAL of NR2D4 is
   for VITAL
   end for;
end CFG_NR2D4_VITAL;


----- CELL NR2D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR2D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR2D8 : entity is TRUE;
end NR2D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR2D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR2D8_VITAL of NR2D8 is
   for VITAL
   end for;
end CFG_NR2D8_VITAL;


----- CELL NR3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D0 : entity is TRUE;
end NR3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D0_VITAL of NR3D0 is
   for VITAL
   end for;
end CFG_NR3D0_VITAL;


----- CELL NR3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D1 : entity is TRUE;
end NR3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D1_VITAL of NR3D1 is
   for VITAL
   end for;
end CFG_NR3D1_VITAL;


----- CELL NR3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D2 : entity is TRUE;
end NR3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D2_VITAL of NR3D2 is
   for VITAL
   end for;
end CFG_NR3D2_VITAL;


----- CELL NR3D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D3 : entity is TRUE;
end NR3D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D3_VITAL of NR3D3 is
   for VITAL
   end for;
end CFG_NR3D3_VITAL;


----- CELL NR3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D4 : entity is TRUE;
end NR3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D4_VITAL of NR3D4 is
   for VITAL
   end for;
end CFG_NR3D4_VITAL;


----- CELL NR3D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR3D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR3D8 : entity is TRUE;
end NR3D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR3D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR3D8_VITAL of NR3D8 is
   for VITAL
   end for;
end CFG_NR3D8_VITAL;


----- CELL NR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D0 : entity is TRUE;
end NR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D0_VITAL of NR4D0 is
   for VITAL
   end for;
end CFG_NR4D0_VITAL;


----- CELL NR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D1 : entity is TRUE;
end NR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D1_VITAL of NR4D1 is
   for VITAL
   end for;
end CFG_NR4D1_VITAL;


----- CELL NR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D2 : entity is TRUE;
end NR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D2_VITAL of NR4D2 is
   for VITAL
   end for;
end CFG_NR4D2_VITAL;


----- CELL NR4D3 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D3 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D3 : entity is TRUE;
end NR4D3;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D3 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D3_VITAL of NR4D3 is
   for VITAL
   end for;
end CFG_NR4D3_VITAL;


----- CELL NR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D4 : entity is TRUE;
end NR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D4_VITAL of NR4D4 is
   for VITAL
   end for;
end CFG_NR4D4_VITAL;


----- CELL NR4D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity NR4D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of NR4D8 : entity is TRUE;
end NR4D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of NR4D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_NR4D8_VITAL of NR4D8 is
   for VITAL
   end for;
end CFG_NR4D8_VITAL;


----- CELL OA21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA21AD0 : entity is TRUE;
end OA21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) AND ((A2_ipd) OR (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA21AD0_VITAL of OA21AD0 is
   for VITAL
   end for;
end CFG_OA21AD0_VITAL;


----- CELL OA21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA21AD1 : entity is TRUE;
end OA21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) AND ((A2_ipd) OR (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA21AD1_VITAL of OA21AD1 is
   for VITAL
   end for;
end CFG_OA21AD1_VITAL;


----- CELL OA21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA21AD2 : entity is TRUE;
end OA21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) AND ((A2_ipd) OR (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA21AD2_VITAL of OA21AD2 is
   for VITAL
   end for;
end CFG_OA21AD2_VITAL;


----- CELL OA21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_Z                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA21AD4 : entity is TRUE;
end OA21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (B_ipd) AND ((A2_ipd) OR (A1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B_ipd'last_event, tpd_B_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA21AD4_VITAL of OA21AD4 is
   for VITAL
   end for;
end CFG_OA21AD4_VITAL;


----- CELL OA22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA22AD0 : entity is TRUE;
end OA22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) OR (A1_ipd)) AND ((B2_ipd) OR (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA22AD0_VITAL of OA22AD0 is
   for VITAL
   end for;
end CFG_OA22AD0_VITAL;


----- CELL OA22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA22AD1 : entity is TRUE;
end OA22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) OR (A1_ipd)) AND ((B2_ipd) OR (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA22AD1_VITAL of OA22AD1 is
   for VITAL
   end for;
end CFG_OA22AD1_VITAL;


----- CELL OA22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA22AD2 : entity is TRUE;
end OA22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) OR (A1_ipd)) AND ((B2_ipd) OR (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA22AD2_VITAL of OA22AD2 is
   for VITAL
   end for;
end CFG_OA22AD2_VITAL;


----- CELL OA22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OA22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OA22AD4 : entity is TRUE;
end OA22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OA22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := ((A2_ipd) OR (A1_ipd)) AND ((B2_ipd) OR (B1_ipd));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_Z, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OA22AD4_VITAL of OA22AD4 is
   for VITAL
   end for;
end CFG_OA22AD4_VITAL;


----- CELL OAI211D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI211D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI211D0 : entity is TRUE;
end OAI211D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI211D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI211D0_VITAL of OAI211D0 is
   for VITAL
   end for;
end CFG_OAI211D0_VITAL;


----- CELL OAI211D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI211D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI211D1 : entity is TRUE;
end OAI211D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI211D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI211D1_VITAL of OAI211D1 is
   for VITAL
   end for;
end CFG_OAI211D1_VITAL;


----- CELL OAI211D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI211D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI211D2 : entity is TRUE;
end OAI211D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI211D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI211D2_VITAL of OAI211D2 is
   for VITAL
   end for;
end CFG_OAI211D2_VITAL;


----- CELL OAI211D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI211D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI211D4 : entity is TRUE;
end OAI211D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI211D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE),
                 3 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI211D4_VITAL of OAI211D4 is
   for VITAL
   end for;
end CFG_OAI211D4_VITAL;


----- CELL OAI21AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21AD0 : entity is TRUE;
end OAI21AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21AD0_VITAL of OAI21AD0 is
   for VITAL
   end for;
end CFG_OAI21AD0_VITAL;


----- CELL OAI21AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21AD1 : entity is TRUE;
end OAI21AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21AD1_VITAL of OAI21AD1 is
   for VITAL
   end for;
end CFG_OAI21AD1_VITAL;


----- CELL OAI21AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21AD2 : entity is TRUE;
end OAI21AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21AD2_VITAL of OAI21AD2 is
   for VITAL
   end for;
end CFG_OAI21AD2_VITAL;


----- CELL OAI21AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21AD4 : entity is TRUE;
end OAI21AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21AD4_VITAL of OAI21AD4 is
   for VITAL
   end for;
end CFG_OAI21AD4_VITAL;


----- CELL OAI21D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21D0 : entity is TRUE;
end OAI21D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21D0_VITAL of OAI21D0 is
   for VITAL
   end for;
end CFG_OAI21D0_VITAL;


----- CELL OAI21D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21D1 : entity is TRUE;
end OAI21D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21D1_VITAL of OAI21D1 is
   for VITAL
   end for;
end CFG_OAI21D1_VITAL;


----- CELL OAI21D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21D2 : entity is TRUE;
end OAI21D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21D2_VITAL of OAI21D2 is
   for VITAL
   end for;
end CFG_OAI21D2_VITAL;


----- CELL OAI21D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI21D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI21D4 : entity is TRUE;
end OAI21D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI21D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI21D4_VITAL of OAI21D4 is
   for VITAL
   end for;
end CFG_OAI21D4_VITAL;


----- CELL OAI221D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI221D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI221D0 : entity is TRUE;
end OAI221D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI221D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI221D0_VITAL of OAI221D0 is
   for VITAL
   end for;
end CFG_OAI221D0_VITAL;


----- CELL OAI221D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI221D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI221D1 : entity is TRUE;
end OAI221D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI221D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI221D1_VITAL of OAI221D1 is
   for VITAL
   end for;
end CFG_OAI221D1_VITAL;


----- CELL OAI221D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI221D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI221D2 : entity is TRUE;
end OAI221D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI221D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI221D2_VITAL of OAI221D2 is
   for VITAL
   end for;
end CFG_OAI221D2_VITAL;


----- CELL OAI221D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI221D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI221D4 : entity is TRUE;
end OAI221D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI221D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C_ipd, C, tipd_C);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd)) AND (C_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C_ipd'last_event, tpd_C_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI221D4_VITAL of OAI221D4 is
   for VITAL
   end for;
end CFG_OAI221D4_VITAL;


----- CELL OAI222D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI222D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI222D0 : entity is TRUE;
end OAI222D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI222D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd)) AND ((C2_ipd) OR (C1_ipd)) AND ((B2_ipd)
         OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI222D0_VITAL of OAI222D0 is
   for VITAL
   end for;
end CFG_OAI222D0_VITAL;


----- CELL OAI222D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI222D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI222D1 : entity is TRUE;
end OAI222D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI222D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd)) AND ((C2_ipd) OR (C1_ipd)) AND ((B2_ipd)
         OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI222D1_VITAL of OAI222D1 is
   for VITAL
   end for;
end CFG_OAI222D1_VITAL;


----- CELL OAI222D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI222D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI222D2 : entity is TRUE;
end OAI222D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI222D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd)) AND ((C2_ipd) OR (C1_ipd)) AND ((B2_ipd)
         OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI222D2_VITAL of OAI222D2 is
   for VITAL
   end for;
end CFG_OAI222D2_VITAL;


----- CELL OAI222D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI222D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_C2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_C2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      C1                             :	in    STD_ULOGIC;
      C2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI222D4 : entity is TRUE;
end OAI222D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI222D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL C2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (C1_ipd, C1, tipd_C1);
   VitalWireDelay (C2_ipd, C2, tipd_C2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd, C1_ipd, C2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((C2_ipd) OR (C1_ipd)) AND ((A2_ipd) OR (A1_ipd)) AND ((B2_ipd)
         OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 4 => (C1_ipd'last_event, tpd_C1_ZN, TRUE),
                 5 => (C2_ipd'last_event, tpd_C2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI222D4_VITAL of OAI222D4 is
   for VITAL
   end for;
end CFG_OAI222D4_VITAL;


----- CELL OAI22AD0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22AD0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22AD0 : entity is TRUE;
end OAI22AD0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22AD0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22AD0_VITAL of OAI22AD0 is
   for VITAL
   end for;
end CFG_OAI22AD0_VITAL;


----- CELL OAI22AD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22AD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22AD1 : entity is TRUE;
end OAI22AD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22AD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22AD1_VITAL of OAI22AD1 is
   for VITAL
   end for;
end CFG_OAI22AD1_VITAL;


----- CELL OAI22AD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22AD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22AD2 : entity is TRUE;
end OAI22AD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22AD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22AD2_VITAL of OAI22AD2 is
   for VITAL
   end for;
end CFG_OAI22AD2_VITAL;


----- CELL OAI22AD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22AD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22AD4 : entity is TRUE;
end OAI22AD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22AD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22AD4_VITAL of OAI22AD4 is
   for VITAL
   end for;
end CFG_OAI22AD4_VITAL;


----- CELL OAI22D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22D0 : entity is TRUE;
end OAI22D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22D0_VITAL of OAI22D0 is
   for VITAL
   end for;
end CFG_OAI22D0_VITAL;


----- CELL OAI22D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22D1 : entity is TRUE;
end OAI22D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22D1_VITAL of OAI22D1 is
   for VITAL
   end for;
end CFG_OAI22D1_VITAL;


----- CELL OAI22D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22D2 : entity is TRUE;
end OAI22D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22D2_VITAL of OAI22D2 is
   for VITAL
   end for;
end CFG_OAI22D2_VITAL;


----- CELL OAI22D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI22D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI22D4 : entity is TRUE;
end OAI22D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI22D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 3 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI22D4_VITAL of OAI22D4 is
   for VITAL
   end for;
end CFG_OAI22D4_VITAL;


----- CELL OAI31D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI31D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI31D0 : entity is TRUE;
end OAI31D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI31D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI31D0_VITAL of OAI31D0 is
   for VITAL
   end for;
end CFG_OAI31D0_VITAL;


----- CELL OAI31D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI31D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI31D1 : entity is TRUE;
end OAI31D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI31D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI31D1_VITAL of OAI31D1 is
   for VITAL
   end for;
end CFG_OAI31D1_VITAL;


----- CELL OAI31D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI31D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI31D2 : entity is TRUE;
end OAI31D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI31D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI31D2_VITAL of OAI31D2 is
   for VITAL
   end for;
end CFG_OAI31D2_VITAL;


----- CELL OAI31D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI31D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B_ZN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B                         :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B                              :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI31D4 : entity is TRUE;
end OAI31D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI31D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B_ipd, B, tipd_B);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((B_ipd) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B_ipd'last_event, tpd_B_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI31D4_VITAL of OAI31D4 is
   for VITAL
   end for;
end CFG_OAI31D4_VITAL;


----- CELL OAI32D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI32D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI32D0 : entity is TRUE;
end OAI32D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI32D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI32D0_VITAL of OAI32D0 is
   for VITAL
   end for;
end CFG_OAI32D0_VITAL;


----- CELL OAI32D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI32D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI32D1 : entity is TRUE;
end OAI32D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI32D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd)) AND ((A2_ipd) OR (A1_ipd) OR (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI32D1_VITAL of OAI32D1 is
   for VITAL
   end for;
end CFG_OAI32D1_VITAL;


----- CELL OAI32D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI32D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI32D2 : entity is TRUE;
end OAI32D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI32D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd) OR (A3_ipd)) AND ((B2_ipd) OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI32D2_VITAL of OAI32D2 is
   for VITAL
   end for;
end CFG_OAI32D2_VITAL;


----- CELL OAI32D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI32D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI32D4 : entity is TRUE;
end OAI32D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI32D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd) OR (A3_ipd)) AND ((B2_ipd) OR (B1_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI32D4_VITAL of OAI32D4 is
   for VITAL
   end for;
end CFG_OAI32D4_VITAL;


----- CELL OAI33D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI33D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI33D0 : entity is TRUE;
end OAI33D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI33D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd) OR (A3_ipd)) AND ((B2_ipd) OR (B1_ipd) OR
         (B3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI33D0_VITAL of OAI33D0 is
   for VITAL
   end for;
end CFG_OAI33D0_VITAL;


----- CELL OAI33D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI33D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI33D1 : entity is TRUE;
end OAI33D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI33D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd) OR (B3_ipd)) AND ((A2_ipd) OR (A1_ipd) OR
         (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI33D1_VITAL of OAI33D1 is
   for VITAL
   end for;
end CFG_OAI33D1_VITAL;


----- CELL OAI33D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI33D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI33D2 : entity is TRUE;
end OAI33D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI33D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((B2_ipd) OR (B1_ipd) OR (B3_ipd)) AND ((A2_ipd) OR (A1_ipd) OR
         (A3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI33D2_VITAL of OAI33D2 is
   for VITAL
   end for;
end CFG_OAI33D2_VITAL;


----- CELL OAI33D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OAI33D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_B3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_B3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      B1                             :	in    STD_ULOGIC;
      B2                             :	in    STD_ULOGIC;
      B3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OAI33D4 : entity is TRUE;
end OAI33D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OAI33D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL B3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (B1_ipd, B1, tipd_B1);
   VitalWireDelay (B2_ipd, B2, tipd_B2);
   VitalWireDelay (B3_ipd, B3, tipd_B3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, B1_ipd, B2_ipd, B3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd :=
       (NOT (((A2_ipd) OR (A1_ipd) OR (A3_ipd)) AND ((B2_ipd) OR (B1_ipd) OR
         (B3_ipd))));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_ZN, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_ZN, TRUE),
                 3 => (B1_ipd'last_event, tpd_B1_ZN, TRUE),
                 4 => (B2_ipd'last_event, tpd_B2_ZN, TRUE),
                 5 => (B3_ipd'last_event, tpd_B3_ZN, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OAI33D4_VITAL of OAI33D4 is
   for VITAL
   end for;
end CFG_OAI33D4_VITAL;


----- CELL OR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR2D0 : entity is TRUE;
end OR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR2D0_VITAL of OR2D0 is
   for VITAL
   end for;
end CFG_OR2D0_VITAL;


----- CELL OR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR2D1 : entity is TRUE;
end OR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR2D1_VITAL of OR2D1 is
   for VITAL
   end for;
end CFG_OR2D1_VITAL;


----- CELL OR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR2D2 : entity is TRUE;
end OR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR2D2_VITAL of OR2D2 is
   for VITAL
   end for;
end CFG_OR2D2_VITAL;


----- CELL OR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR2D4 : entity is TRUE;
end OR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR2D4_VITAL of OR2D4 is
   for VITAL
   end for;
end CFG_OR2D4_VITAL;


----- CELL OR2D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR2D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR2D8 : entity is TRUE;
end OR2D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR2D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR2D8_VITAL of OR2D8 is
   for VITAL
   end for;
end CFG_OR2D8_VITAL;


----- CELL OR3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR3D0 : entity is TRUE;
end OR3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR3D0_VITAL of OR3D0 is
   for VITAL
   end for;
end CFG_OR3D0_VITAL;


----- CELL OR3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR3D1 : entity is TRUE;
end OR3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR3D1_VITAL of OR3D1 is
   for VITAL
   end for;
end CFG_OR3D1_VITAL;


----- CELL OR3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR3D2 : entity is TRUE;
end OR3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR3D2_VITAL of OR3D2 is
   for VITAL
   end for;
end CFG_OR3D2_VITAL;


----- CELL OR3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR3D4 : entity is TRUE;
end OR3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR3D4_VITAL of OR3D4 is
   for VITAL
   end for;
end CFG_OR3D4_VITAL;


----- CELL OR3D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR3D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR3D8 : entity is TRUE;
end OR3D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR3D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR3D8_VITAL of OR3D8 is
   for VITAL
   end for;
end CFG_OR3D8_VITAL;


----- CELL OR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR4D0 : entity is TRUE;
end OR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR4D0_VITAL of OR4D0 is
   for VITAL
   end for;
end CFG_OR4D0_VITAL;


----- CELL OR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR4D1 : entity is TRUE;
end OR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR4D1_VITAL of OR4D1 is
   for VITAL
   end for;
end CFG_OR4D1_VITAL;


----- CELL OR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR4D2 : entity is TRUE;
end OR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR4D2_VITAL of OR4D2 is
   for VITAL
   end for;
end CFG_OR4D2_VITAL;


----- CELL OR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR4D4 : entity is TRUE;
end OR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR4D4_VITAL of OR4D4 is
   for VITAL
   end for;
end CFG_OR4D4_VITAL;


----- CELL OR4D8 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity OR4D8 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of OR4D8 : entity is TRUE;
end OR4D8;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of OR4D8 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) OR (A1_ipd) OR (A3_ipd) OR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z, TRUE),
                 1 => (A2_ipd'last_event, tpd_A2_Z, TRUE),
                 2 => (A3_ipd'last_event, tpd_A3_Z, TRUE),
                 3 => (A4_ipd'last_event, tpd_A4_Z, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_OR4D8_VITAL of OR4D8 is
   for VITAL
   end for;
end CFG_OR4D8_VITAL;


----- CELL SDFCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCND1 : entity is TRUE;
end SDFCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCND1_VITAL of SDFCND1 is
   for VITAL
   end for;
end CFG_SDFCND1_VITAL;


----- CELL SDFCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCND2 : entity is TRUE;
end SDFCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCND2_VITAL of SDFCND2 is
   for VITAL
   end for;
end CFG_SDFCND2_VITAL;


----- CELL SDFCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCND4 : entity is TRUE;
end SDFCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCND4_VITAL of SDFCND4 is
   for VITAL
   end for;
end CFG_SDFCND4_VITAL;


----- CELL SDFCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCNQD1 : entity is TRUE;
end SDFCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCNQD1_VITAL of SDFCNQD1 is
   for VITAL
   end for;
end CFG_SDFCNQD1_VITAL;


----- CELL SDFCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCNQD2 : entity is TRUE;
end SDFCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCNQD2_VITAL of SDFCNQD2 is
   for VITAL
   end for;
end CFG_SDFCNQD2_VITAL;


----- CELL SDFCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCNQD4 : entity is TRUE;
end SDFCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCNQD4_VITAL of SDFCNQD4 is
   for VITAL
   end for;
end CFG_SDFCNQD4_VITAL;


----- CELL SDFCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCSND1 : entity is TRUE;
end SDFCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCSND1_VITAL of SDFCSND1 is
   for VITAL
   end for;
end CFG_SDFCSND1_VITAL;


----- CELL SDFCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCSND2 : entity is TRUE;
end SDFCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCSND2_VITAL of SDFCSND2 is
   for VITAL
   end for;
end CFG_SDFCSND2_VITAL;


----- CELL SDFCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFCSND4 : entity is TRUE;
end SDFCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_CDN_SDN_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_D_CP_posedge or Tviol_SDN_CDN_posedge or Tviol_SDN_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CP_delayed, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CP_ipd));
      QN_zd := Violation XOR QN_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFCSND4_VITAL of SDFCSND4 is
   for VITAL
   end for;
end CFG_SDFCSND4_VITAL;


----- CELL SDFD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFD1 : entity is TRUE;
end SDFD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFD1_VITAL of SDFD1 is
   for VITAL
   end for;
end CFG_SDFD1_VITAL;


----- CELL SDFD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFD2 : entity is TRUE;
end SDFD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFD2_VITAL of SDFD2 is
   for VITAL
   end for;
end CFG_SDFD2_VITAL;


----- CELL SDFD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFD4 : entity is TRUE;
end SDFD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFD4_VITAL of SDFD4 is
   for VITAL
   end for;
end CFG_SDFD4_VITAL;


----- CELL SDFKCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCND1 : entity is TRUE;
end SDFKCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCND1_VITAL of SDFKCND1 is
   for VITAL
   end for;
end CFG_SDFKCND1_VITAL;


----- CELL SDFKCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCND2 : entity is TRUE;
end SDFKCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCND2_VITAL of SDFKCND2 is
   for VITAL
   end for;
end CFG_SDFKCND2_VITAL;


----- CELL SDFKCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCND4 : entity is TRUE;
end SDFKCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCND4_VITAL of SDFKCND4 is
   for VITAL
   end for;
end CFG_SDFKCND4_VITAL;


----- CELL SDFKCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCNQD1 : entity is TRUE;
end SDFKCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCNQD1_VITAL of SDFKCNQD1 is
   for VITAL
   end for;
end CFG_SDFKCNQD1_VITAL;


----- CELL SDFKCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCNQD2 : entity is TRUE;
end SDFKCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCNQD2_VITAL of SDFKCNQD2 is
   for VITAL
   end for;
end CFG_SDFKCNQD2_VITAL;


----- CELL SDFKCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCNQD4 : entity is TRUE;
end SDFKCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, D_delayed, CN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCNQD4_VITAL of SDFKCNQD4 is
   for VITAL
   end for;
end CFG_SDFKCNQD4_VITAL;


----- CELL SDFKCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCSND1 : entity is TRUE;
end SDFKCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, CN_delayed, SE_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCSND1_VITAL of SDFKCSND1 is
   for VITAL
   end for;
end CFG_SDFKCSND1_VITAL;


----- CELL SDFKCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCSND2 : entity is TRUE;
end SDFKCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, CN_delayed, SE_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCSND2_VITAL of SDFKCSND2 is
   for VITAL
   end for;
end CFG_SDFKCSND2_VITAL;


----- CELL SDFKCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKCSND4 : entity is TRUE;
end SDFKCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKCSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, CN_delayed, SE_delayed, D_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKCSND4_VITAL of SDFKCSND4 is
   for VITAL
   end for;
end CFG_SDFKCSND4_VITAL;


----- CELL SDFKSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKSND1 : entity is TRUE;
end SDFKSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKSND1_VITAL of SDFKSND1 is
   for VITAL
   end for;
end CFG_SDFKSND1_VITAL;


----- CELL SDFKSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKSND2 : entity is TRUE;
end SDFKSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKSND2_VITAL of SDFKSND2 is
   for VITAL
   end for;
end CFG_SDFKSND2_VITAL;


----- CELL SDFKSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFKSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC;
      SN                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFKSND4 : entity is TRUE;
end SDFKSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFKSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SN_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   VitalWireDelay (SN_ipd, SN, tipd_SN);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd, SN_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE SN_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SN_CP_posedge,
          TimingData              => Tmkr_SN_CP_posedge,
          TestSignal              => SN_ipd,
          TestSignalName          => "SN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SN_CP_posedge_posedge,
          SetupLow                => tsetup_SN_CP_negedge_posedge,
          HoldHigh                => thold_SN_CP_negedge_posedge,
          HoldLow                 => thold_SN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFKSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Tviol_SN_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFKSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SN_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;
      SN_delayed := SN_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFKSND4_VITAL of SDFKSND4 is
   for VITAL
   end for;
end CFG_SDFKSND4_VITAL;


----- CELL SDFNCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCND1 : entity is TRUE;
end SDFNCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCND1_VITAL of SDFNCND1 is
   for VITAL
   end for;
end CFG_SDFNCND1_VITAL;


----- CELL SDFNCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCND2 : entity is TRUE;
end SDFNCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCND2_VITAL of SDFNCND2 is
   for VITAL
   end for;
end CFG_SDFNCND2_VITAL;


----- CELL SDFNCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCND4 : entity is TRUE;
end SDFNCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCND4_VITAL of SDFNCND4 is
   for VITAL
   end for;
end CFG_SDFNCND4_VITAL;


----- CELL SDFNCSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCSND1 : entity is TRUE;
end SDFNCSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SDN_CDN_posedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCSND1_VITAL of SDFNCSND1 is
   for VITAL
   end for;
end CFG_SDFNCSND1_VITAL;


----- CELL SDFNCSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCSND2 : entity is TRUE;
end SDFNCSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SDN_CDN_posedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCSND2_VITAL of SDFNCSND2 is
   for VITAL
   end for;
end CFG_SDFNCSND2_VITAL;


----- CELL SDFNCSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNCSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_CDN_SDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_CDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CDN_posedge_posedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SDN_CDN                  :	VitalDelayType := 0.000 ns;
      thold_CDN_SDN                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNCSND4 : entity is TRUE;
end SDFNCSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNCSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_CDN_SDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_SDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CDN_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CDN_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE PrevData_QN : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CPN_negedge,
          TimingData              => Tmkr_CDN_CPN_negedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CPN_posedge_negedge,
          Removal                 => thold_CDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_SDN_posedge,
          TimingData              => Tmkr_CDN_SDN_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => SDN_ipd,
          RefSignalName          => "SDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_SDN_posedge_posedge,
          Removal                 => thold_CDN_SDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CDN_posedge,
          TimingData              => Tmkr_SDN_CDN_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CDN_ipd,
          RefSignalName          => "CDN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CDN_posedge_posedge,
          Removal                 => thold_SDN_CDN,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01(( (NOT SDN_ipd) ) OR ( (NOT CDN_ipd) ) ) /=
                            '1',
          HeaderMsg               => InstancePath &"/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNCSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CPN_negedge or Tviol_CDN_SDN_posedge or Tviol_SDN_CPN_negedge or Pviol_SDN or Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SDN_CDN_posedge or Tviol_SE_CPN_negedge or Pviol_CPN or Pviol_CDN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFCSND1_Q_tab,
        DataIn => (
               CDN_ipd, CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      VitalStateTable(
        Result => QN_zd,
        PreviousDataIn => PrevData_QN,
        StateTable => SDFCSND1_QN_tab,
        DataIn => (
               SDN_ipd, CPN_ipd, SE_delayed, SI_delayed, D_delayed, CDN_ipd, CPN_delayed));
      QN_zd := Violation XOR QN_zd;
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 2 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNCSND4_VITAL of SDFNCSND4 is
   for VITAL
   end for;
end CFG_SDFNCSND4_VITAL;


----- CELL SDFND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFND1 : entity is TRUE;
end SDFND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFND1_VITAL of SDFND1 is
   for VITAL
   end for;
end CFG_SDFND1_VITAL;


----- CELL SDFND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFND2 : entity is TRUE;
end SDFND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFND2_VITAL of SDFND2 is
   for VITAL
   end for;
end CFG_SDFND2_VITAL;


----- CELL SDFND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFND4 : entity is TRUE;
end SDFND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SI_CPN_negedge or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFND4_VITAL of SDFND4 is
   for VITAL
   end for;
end CFG_SDFND4_VITAL;


----- CELL SDFNSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNSND1 : entity is TRUE;
end SDFNSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Tviol_SI_CPN_negedge or Pviol_SDN or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNSND1_VITAL of SDFNSND1 is
   for VITAL
   end for;
end CFG_SDFNSND1_VITAL;


----- CELL SDFNSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNSND2 : entity is TRUE;
end SDFNSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Tviol_SI_CPN_negedge or Pviol_SDN or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNSND2_VITAL of SDFNSND2 is
   for VITAL
   end for;
end CFG_SDFNSND2_VITAL;


----- CELL SDFNSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFNSND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CPN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CPN_posedge_negedge                    :	VitalDelayType := 0.000 ns;
      thold_D_CPN_negedge_negedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_D_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CPN_posedge_negedge              :	VitalDelayType := 0.000 ns;
      thold_SDN_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SE_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_posedge_negedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CPN_negedge_negedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_posedge_negedge                  :	VitalDelayType := 0.000 ns;
      tsetup_SI_CPN_negedge_negedge                  :	VitalDelayType := 0.000 ns;
      tpw_CPN_posedge                :	VitalDelayType := 0.000 ns;
      tpw_CPN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CPN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CPN                            :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFNSND4 : entity is TRUE;
end SDFNSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFNSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CPN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CPN_ipd, CPN, tipd_CPN);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CPN_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CPN_negedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CPN_negedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CPN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CPN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CPN_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CPN_negedge,
          TimingData              => Tmkr_D_CPN_negedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CPN_posedge_negedge,
          SetupLow                => tsetup_D_CPN_negedge_negedge,
          HoldHigh                => thold_D_CPN_negedge_negedge,
          HoldLow                 => thold_D_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CPN_negedge,
          TimingData              => Tmkr_SDN_CPN_negedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CPN_posedge_negedge,
          Removal                 => thold_SDN_CPN_posedge_negedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CPN_negedge,
          TimingData              => Tmkr_SE_CPN_negedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CPN_posedge_negedge,
          SetupLow                => tsetup_SE_CPN_negedge_negedge,
          HoldHigh                => thold_SE_CPN_negedge_negedge,
          HoldLow                 => thold_SE_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CPN_negedge,
          TimingData              => Tmkr_SI_CPN_negedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CPN_ipd,
          RefSignalName          => "CPN",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CPN_posedge_negedge,
          SetupLow                => tsetup_SI_CPN_negedge_negedge,
          HoldHigh                => thold_SI_CPN_negedge_negedge,
          HoldLow                 => thold_SI_CPN_posedge_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'F',
          HeaderMsg               => InstancePath & "/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CPN,
          PeriodData              => PInfo_CPN,
          TestSignal              => CPN_ipd,
          TestSignalName          => "CPN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CPN_posedge,
          PulseWidthLow           => tpw_CPN_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFNSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CPN_negedge or Tviol_SDN_CPN_negedge or Tviol_SI_CPN_negedge or Pviol_SDN or Tviol_SE_CPN_negedge or Pviol_CPN;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CPN_ipd, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CPN_delayed));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CPN_delayed := CPN_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_Q_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CPN_ipd'last_event, tpd_CPN_QN_negedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFNSND4_VITAL of SDFNSND4 is
   for VITAL
   end for;
end CFG_SDFNSND4_VITAL;


----- CELL SDFQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFQD1 : entity is TRUE;
end SDFQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFQD1_VITAL of SDFQD1 is
   for VITAL
   end for;
end CFG_SDFQD1_VITAL;


----- CELL SDFQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFQD2 : entity is TRUE;
end SDFQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFQD2_VITAL of SDFQD2 is
   for VITAL
   end for;
end CFG_SDFQD2_VITAL;


----- CELL SDFQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFQD4 : entity is TRUE;
end SDFQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 4);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDF4CQD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFQD4_VITAL of SDFQD4 is
   for VITAL
   end for;
end CFG_SDFQD4_VITAL;


----- CELL SDFSND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFSND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFSND1 : entity is TRUE;
end SDFSND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFSND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFSND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFSND1_VITAL of SDFSND1 is
   for VITAL
   end for;
end CFG_SDFSND1_VITAL;


----- CELL SDFSND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFSND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_SDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_SDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      trecovery_SDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_SDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tpw_SDN_negedge                :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFSND2 : entity is TRUE;
end SDFSND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFSND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFSND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFSND2_VITAL of SDFSND2 is
   for VITAL
   end for;
end CFG_SDFSND2_VITAL;


----- CELL SDFSND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFSND4 is
   generic(
      TimingChecksOn: Boolean := True; InstancePath: STRING := "*"; Xon:
      Boolean := False; MsgOn: Boolean := True; tpd_SDN_Q_negedge :
      VitalDelayType01 := (0.000 ns, 0.000 ns); tpd_CP_Q_posedge :
      VitalDelayType01 := (0.000 ns, 0.000 ns); tpd_SDN_QN_negedge :
      VitalDelayType01 := (0.000 ns, 0.000 ns); tpd_CP_QN_posedge :
      VitalDelayType01 := (0.000 ns, 0.000 ns); thold_D_CP_posedge_posedge :
      VitalDelayType := 0.000 ns; thold_D_CP_negedge_posedge :
      VitalDelayType := 0.000 ns; tsetup_D_CP_posedge_posedge :
      VitalDelayType := 0.000 ns; tsetup_D_CP_negedge_posedge :
      VitalDelayType := 0.000 ns; trecovery_SDN_CP_posedge_posedge :
      VitalDelayType := 0.000 ns; thold_SDN_CP_posedge_posedge : VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge : VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge : VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge : VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge : VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge : VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge : VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge : VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge : VitalDelayType := 0.000 ns;
      tpw_CP_posedge : VitalDelayType := 0.000 ns; tpw_CP_negedge :
      VitalDelayType := 0.000 ns; tpw_SDN_negedge : VitalDelayType := 0.000
      ns; tipd_CP : VitalDelayType01 := (0.000 ns, 0.000 ns); tipd_D :
      VitalDelayType01 := (0.000 ns, 0.000 ns); tipd_SDN : VitalDelayType01
      := (0.000 ns, 0.000 ns); tipd_SE : VitalDelayType01 := (0.000 ns,
      0.000 ns); tipd_SI : VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SDN                            :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFSND4 : entity is TRUE;
end SDFSND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFSND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (SDN_ipd, SDN, tipd_SDN);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, SDN_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_SDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_SDN	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 5);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_SDN_CP_posedge,
          TimingData              => Tmkr_SDN_CP_posedge,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_SDN_CP_posedge_posedge,
          Removal                 => thold_SDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT SDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_SDN,
          PeriodData              => PInfo_SDN,
          TestSignal              => SDN_ipd,
          TestSignalName          => "SDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_SDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFSND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_SDN_CP_posedge or Tviol_SE_CP_posedge or Pviol_SDN or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFNSND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, D_delayed, SE_delayed, SDN_ipd, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (SDN_ipd'last_event, tpd_SDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFSND4_VITAL of SDFSND4 is
   for VITAL
   end for;
end CFG_SDFSND4_VITAL;


----- CELL SDFXD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFXD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFXD1 : entity is TRUE;
end SDFXD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFXD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFXD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, DB_delayed, DA_delayed, SE_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFXD1_VITAL of SDFXD1 is
   for VITAL
   end for;
end CFG_SDFXD1_VITAL;


----- CELL SDFXD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFXD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFXD2 : entity is TRUE;
end SDFXD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFXD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFXD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, DB_delayed, DA_delayed, SE_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFXD2_VITAL of SDFXD2 is
   for VITAL
   end for;
end CFG_SDFXD2_VITAL;


----- CELL SDFXD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SDFXD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_DA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_DB_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_DB_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_DB_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SA_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SA_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SA_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_DB                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SA                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      DA                             :	in    STD_ULOGIC;
      DB                             :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SA                             :	in    STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SDFXD4 : entity is TRUE;
end SDFXD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SDFXD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL DB_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SA_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (DA_ipd, DA, tipd_DA);
   VitalWireDelay (DB_ipd, DB, tipd_DB);
   VitalWireDelay (SA_ipd, SA, tipd_SA);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, DA_ipd, DB_ipd, SA_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_DA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_DB_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_DB_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SA_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SA_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE DA_delayed : STD_ULOGIC := 'X';
   VARIABLE DB_delayed : STD_ULOGIC := 'X';
   VARIABLE SA_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_DA_CP_posedge,
          TimingData              => Tmkr_DA_CP_posedge,
          TestSignal              => DA_ipd,
          TestSignalName          => "DA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DA_CP_posedge_posedge,
          SetupLow                => tsetup_DA_CP_negedge_posedge,
          HoldHigh                => thold_DA_CP_negedge_posedge,
          HoldLow                 => thold_DA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_DB_CP_posedge,
          TimingData              => Tmkr_DB_CP_posedge,
          TestSignal              => DB_ipd,
          TestSignalName          => "DB",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_DB_CP_posedge_posedge,
          SetupLow                => tsetup_DB_CP_negedge_posedge,
          HoldHigh                => thold_DB_CP_negedge_posedge,
          HoldLow                 => thold_DB_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SA_CP_posedge,
          TimingData              => Tmkr_SA_CP_posedge,
          TestSignal              => SA_ipd,
          TestSignalName          => "SA",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SA_CP_posedge_posedge,
          SetupLow                => tsetup_SA_CP_negedge_posedge,
          HoldHigh                => thold_SA_CP_negedge_posedge,
          HoldLow                 => thold_SA_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SDFXD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_DA_CP_posedge or Tviol_DB_CP_posedge or Tviol_SA_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, DB_delayed, DA_delayed, SE_delayed, SA_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      DA_delayed := DA_ipd;
      DB_delayed := DB_ipd;
      SA_delayed := SA_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SDFXD4_VITAL of SDFXD4 is
   for VITAL
   end for;
end CFG_SDFXD4_VITAL;


----- CELL SEDFCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCND1 : entity is TRUE;
end SEDFCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCND1_VITAL of SEDFCND1 is
   for VITAL
   end for;
end CFG_SEDFCND1_VITAL;


----- CELL SEDFCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCND2 : entity is TRUE;
end SEDFCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCND2_VITAL of SEDFCND2 is
   for VITAL
   end for;
end CFG_SEDFCND2_VITAL;


----- CELL SEDFCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CDN_QN_negedge                     :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCND4 : entity is TRUE;
end SEDFCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_QN_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCND4_VITAL of SEDFCND4 is
   for VITAL
   end for;
end CFG_SEDFCND4_VITAL;


----- CELL SEDFCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCNQD1 : entity is TRUE;
end SEDFCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCNQD1_VITAL of SEDFCNQD1 is
   for VITAL
   end for;
end CFG_SEDFCNQD1_VITAL;


----- CELL SEDFCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCNQD2 : entity is TRUE;
end SEDFCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCNQD2_VITAL of SEDFCNQD2 is
   for VITAL
   end for;
end CFG_SEDFCNQD2_VITAL;


----- CELL SEDFCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CDN_Q_negedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      trecovery_CDN_CP_posedge_posedge               :	VitalDelayType := 0.000 ns;
      thold_CDN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CDN_negedge                :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CDN                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CDN                            :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFCNQD4 : entity is TRUE;
end SEDFCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CDN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CDN_ipd, CDN, tipd_CDN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CDN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CDN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CDN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CDN	: STD_ULOGIC := '0';
   VARIABLE PInfo_CDN	: VitalPeriodDataType := VitalPeriodDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalRecoveryRemovalCheck (
          Violation               => Tviol_CDN_CP_posedge,
          TimingData              => Tmkr_CDN_CP_posedge,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          Recovery                => trecovery_CDN_CP_posedge_posedge,
          Removal                 => thold_CDN_CP_posedge_posedge,
          ActiveLow               => TRUE,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CDN,
          PeriodData              => PInfo_CDN,
          TestSignal              => CDN_ipd,
          TestSignalName          => "CDN",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => 0 ns,
          PulseWidthLow           => tpw_CDN_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TO_X01((NOT CDN_ipd) ) /= '1',
          HeaderMsg               => InstancePath &"/SEDFCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CDN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CDN or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFCND1_Q_tab,
        DataIn => (
               CDN_ipd, CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CDN_ipd'last_event, tpd_CDN_Q_negedge, TRUE),
                 1 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFCNQD4_VITAL of SEDFCNQD4 is
   for VITAL
   end for;
end CFG_SEDFCNQD4_VITAL;


----- CELL SEDFD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFD1 : entity is TRUE;
end SEDFD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFD1_VITAL of SEDFD1 is
   for VITAL
   end for;
end CFG_SEDFD1_VITAL;


----- CELL SEDFD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFD2 : entity is TRUE;
end SEDFD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFD2_VITAL of SEDFD2 is
   for VITAL
   end for;
end CFG_SEDFD2_VITAL;


----- CELL SEDFD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFD4 : entity is TRUE;
end SEDFD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFD4_VITAL of SEDFD4 is
   for VITAL
   end for;
end CFG_SEDFD4_VITAL;


----- CELL SEDFKCND1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCND1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCND1 : entity is TRUE;
end SEDFKCND1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCND1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCND1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCND1_VITAL of SEDFKCND1 is
   for VITAL
   end for;
end CFG_SEDFKCND1_VITAL;


----- CELL SEDFKCND2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCND2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCND2 : entity is TRUE;
end SEDFKCND2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCND2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCND2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCND2_VITAL of SEDFKCND2 is
   for VITAL
   end for;
end CFG_SEDFKCND2_VITAL;


----- CELL SEDFKCND4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCND4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_CP_QN_posedge                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      QN                             :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCND4 : entity is TRUE;
end SEDFKCND4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCND4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 2) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);
   ALIAS QN_zd : STD_LOGIC is Results(2);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;
   VARIABLE QN_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCND4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      QN_zd := (NOT Q_zd);
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);
      VitalPathDelay01 (
       OutSignal => QN,
       GlitchData => QN_GlitchData,
       OutSignalName => "QN",
       OutTemp => QN_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_QN_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCND4_VITAL of SEDFKCND4 is
   for VITAL
   end for;
end CFG_SEDFKCND4_VITAL;


----- CELL SEDFKCNQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCNQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCNQD1 : entity is TRUE;
end SEDFKCNQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCNQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCNQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCNQD1_VITAL of SEDFKCNQD1 is
   for VITAL
   end for;
end CFG_SEDFKCNQD1_VITAL;


----- CELL SEDFKCNQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCNQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCNQD2 : entity is TRUE;
end SEDFKCNQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCNQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCNQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCNQD2_VITAL of SEDFKCNQD2 is
   for VITAL
   end for;
end CFG_SEDFKCNQD2_VITAL;


----- CELL SEDFKCNQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFKCNQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_CN_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_CN_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_CN_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CN                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CN                             :	in    STD_ULOGIC;
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFKCNQD4 : entity is TRUE;
end SEDFKCNQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFKCNQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CN_ipd	 : STD_ULOGIC := 'X';
   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CN_ipd, CN, tipd_CN);
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CN_ipd, CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_CN_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_CN_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 7);
   VARIABLE CN_delayed : STD_ULOGIC := 'X';
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_CN_CP_posedge,
          TimingData              => Tmkr_CN_CP_posedge,
          TestSignal              => CN_ipd,
          TestSignalName          => "CN",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_CN_CP_posedge_posedge,
          SetupLow                => tsetup_CN_CP_negedge_posedge,
          HoldHigh                => thold_CN_CP_negedge_posedge,
          HoldLow                 => thold_CN_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFKCNQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_CN_CP_posedge or Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SEDFKCND1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, SE_delayed, CN_delayed, Q_zd, D_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CN_delayed := CN_ipd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFKCNQD4_VITAL of SEDFKCNQD4 is
   for VITAL
   end for;
end CFG_SEDFKCNQD4_VITAL;


----- CELL SEDFQD1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFQD1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFQD1 : entity is TRUE;
end SEDFQD1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFQD1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFQD1",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFQD1_VITAL of SEDFQD1 is
   for VITAL
   end for;
end CFG_SEDFQD1_VITAL;


----- CELL SEDFQD2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFQD2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFQD2 : entity is TRUE;
end SEDFQD2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFQD2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFQD2",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFQD2_VITAL of SEDFQD2 is
   for VITAL
   end for;
end CFG_SEDFQD2_VITAL;


----- CELL SEDFQD4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity SEDFQD4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_CP_Q_posedge                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      thold_D_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_D_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_D_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_E_CP_posedge_posedge                     :	VitalDelayType := 0.000 ns;
      thold_E_CP_negedge_posedge                     :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_E_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SE_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SE_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      thold_SI_CP_posedge_posedge                    :	VitalDelayType := 0.000 ns;
      thold_SI_CP_negedge_posedge                    :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_posedge_posedge                   :	VitalDelayType := 0.000 ns;
      tsetup_SI_CP_negedge_posedge                   :	VitalDelayType := 0.000 ns;
      tpw_CP_posedge                 :	VitalDelayType := 0.000 ns;
      tpw_CP_negedge                 :	VitalDelayType := 0.000 ns;
      tipd_CP                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_D                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_E                         :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SE                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_SI                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      CP                             :	in    STD_ULOGIC;
      D                              :	in    STD_ULOGIC;
      E                              :	in    STD_ULOGIC;
      Q                              :	out   STD_ULOGIC;
      SE                             :	in    STD_ULOGIC;
      SI                             :	in    STD_ULOGIC);
attribute VITAL_LEVEL0 of SEDFQD4 : entity is TRUE;
end SEDFQD4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of SEDFQD4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL CP_ipd	 : STD_ULOGIC := 'X';
   SIGNAL D_ipd	 : STD_ULOGIC := 'X';
   SIGNAL E_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SE_ipd	 : STD_ULOGIC := 'X';
   SIGNAL SI_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (CP_ipd, CP, tipd_CP);
   VitalWireDelay (D_ipd, D, tipd_D);
   VitalWireDelay (E_ipd, E, tipd_E);
   VitalWireDelay (SE_ipd, SE, tipd_SE);
   VitalWireDelay (SI_ipd, SI, tipd_SI);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (CP_ipd, D_ipd, E_ipd, SE_ipd, SI_ipd)

   -- timing check results
   VARIABLE Tviol_D_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_D_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_E_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_E_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SE_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SE_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Tviol_SI_CP_posedge	: STD_ULOGIC := '0';
   VARIABLE Tmkr_SI_CP_posedge	: VitalTimingDataType := VitalTimingDataInit;
   VARIABLE Pviol_CP	: STD_ULOGIC := '0';
   VARIABLE PInfo_CP	: VitalPeriodDataType := VitalPeriodDataInit;

   -- functionality results
   VARIABLE Violation : STD_ULOGIC := '0';
   VARIABLE PrevData_Q : STD_LOGIC_VECTOR(0 to 6);
   VARIABLE CP_delayed : STD_ULOGIC := 'X';
   VARIABLE D_delayed : STD_ULOGIC := 'X';
   VARIABLE E_delayed : STD_ULOGIC := 'X';
   VARIABLE SE_delayed : STD_ULOGIC := 'X';
   VARIABLE SI_delayed : STD_ULOGIC := 'X';
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Q_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Q_GlitchData	: VitalGlitchDataType;

   begin

      ------------------------
      --  Timing Check Section
      ------------------------
      if (TimingChecksOn) then
         VitalSetupHoldCheck (
          Violation               => Tviol_D_CP_posedge,
          TimingData              => Tmkr_D_CP_posedge,
          TestSignal              => D_ipd,
          TestSignalName          => "D",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_D_CP_posedge_posedge,
          SetupLow                => tsetup_D_CP_negedge_posedge,
          HoldHigh                => thold_D_CP_negedge_posedge,
          HoldLow                 => thold_D_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_E_CP_posedge,
          TimingData              => Tmkr_E_CP_posedge,
          TestSignal              => E_ipd,
          TestSignalName          => "E",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_E_CP_posedge_posedge,
          SetupLow                => tsetup_E_CP_negedge_posedge,
          HoldHigh                => thold_E_CP_negedge_posedge,
          HoldLow                 => thold_E_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SE_CP_posedge,
          TimingData              => Tmkr_SE_CP_posedge,
          TestSignal              => SE_ipd,
          TestSignalName          => "SE",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SE_CP_posedge_posedge,
          SetupLow                => tsetup_SE_CP_negedge_posedge,
          HoldHigh                => thold_SE_CP_negedge_posedge,
          HoldLow                 => thold_SE_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalSetupHoldCheck (
          Violation               => Tviol_SI_CP_posedge,
          TimingData              => Tmkr_SI_CP_posedge,
          TestSignal              => SI_ipd,
          TestSignalName          => "SI",
          TestDelay               => 0 ns,
          RefSignal               => CP_ipd,
          RefSignalName          => "CP",
          RefDelay                => 0 ns,
          SetupHigh               => tsetup_SI_CP_posedge_posedge,
          SetupLow                => tsetup_SI_CP_negedge_posedge,
          HoldHigh                => thold_SI_CP_negedge_posedge,
          HoldLow                 => thold_SI_CP_posedge_posedge,
          CheckEnabled            => 
                           TRUE,
          RefTransition           => 'R',
          HeaderMsg               => InstancePath & "/SEDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
         VitalPeriodPulseCheck (
          Violation               => Pviol_CP,
          PeriodData              => PInfo_CP,
          TestSignal              => CP_ipd,
          TestSignalName          => "CP",
          TestDelay               => 0 ns,
          Period                  => 0 ns,
          PulseWidthHigh          => tpw_CP_posedge,
          PulseWidthLow           => tpw_CP_negedge,
          CheckEnabled            => 
                           TRUE,
          HeaderMsg               => InstancePath &"/SEDFQD4",
          Xon                     => Xon,
          MsgOn                   => MsgOn,
          MsgSeverity             => WARNING);
      end if;

      -------------------------
      --  Functionality Section
      -------------------------
      Violation := Tviol_D_CP_posedge or Tviol_E_CP_posedge or Tviol_SE_CP_posedge or Tviol_SI_CP_posedge or Pviol_CP;
      VitalStateTable(
        Result => Q_zd,
        PreviousDataIn => PrevData_Q,
        StateTable => SDFXD1_Q_tab,
        DataIn => (
               CP_delayed, SI_delayed, Q_zd, D_delayed, SE_delayed, E_delayed, CP_ipd));
      Q_zd := Violation XOR Q_zd;
      CP_delayed := CP_ipd;
      D_delayed := D_ipd;
      E_delayed := E_ipd;
      SE_delayed := SE_ipd;
      SI_delayed := SI_ipd;

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Q,
       GlitchData => Q_GlitchData,
       OutSignalName => "Q",
       OutTemp => Q_zd,
       Paths => (0 => (CP_ipd'last_event, tpd_CP_Q_posedge, TRUE)),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_SEDFQD4_VITAL of SEDFQD4 is
   for VITAL
   end for;
end CFG_SEDFQD4_VITAL;


----- CELL TIEH -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity TIEH is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True);

   port(
      Z                              :	out   STD_ULOGIC := 'H');
attribute VITAL_LEVEL0 of TIEH : entity is TRUE;
end TIEH;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of TIEH is
   attribute VITAL_LEVEL0 of VITAL : architecture is TRUE;


begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   --  empty
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   Z <= 'H';


end VITAL;

configuration CFG_TIEH_VITAL of TIEH is
   for VITAL
   end for;
end CFG_TIEH_VITAL;


----- CELL TIEL -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity TIEL is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True);

   port(
      ZN                             :	out   STD_ULOGIC := 'L');
attribute VITAL_LEVEL0 of TIEL : entity is TRUE;
end TIEL;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of TIEL is
   attribute VITAL_LEVEL0 of VITAL : architecture is TRUE;


begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   --  empty
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   ZN <= 'L';


end VITAL;

configuration CFG_TIEL_VITAL of TIEL is
   for VITAL
   end for;
end CFG_TIEL_VITAL;


----- CELL XNR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR2D0 : entity is TRUE;
end XNR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR2D0_VITAL of XNR2D0 is
   for VITAL
   end for;
end CFG_XNR2D0_VITAL;


----- CELL XNR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR2D1 : entity is TRUE;
end XNR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR2D1_VITAL of XNR2D1 is
   for VITAL
   end for;
end CFG_XNR2D1_VITAL;


----- CELL XNR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR2D2 : entity is TRUE;
end XNR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR2D2_VITAL of XNR2D2 is
   for VITAL
   end for;
end CFG_XNR2D2_VITAL;


----- CELL XNR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1              :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR2D4 : entity is TRUE;
end XNR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR2D4_VITAL of XNR2D4 is
   for VITAL
   end for;
end CFG_XNR2D4_VITAL;


----- CELL XNR3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR3D0 : entity is TRUE;
end XNR3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR3D0_VITAL of XNR3D0 is
   for VITAL
   end for;
end CFG_XNR3D0_VITAL;


----- CELL XNR3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR3D1 : entity is TRUE;
end XNR3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR3D1_VITAL of XNR3D1 is
   for VITAL
   end for;
end CFG_XNR3D1_VITAL;


----- CELL XNR3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR3D2 : entity is TRUE;
end XNR3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR3D2_VITAL of XNR3D2 is
   for VITAL
   end for;
end CFG_XNR3D2_VITAL;


----- CELL XNR3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1   :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR3D4 : entity is TRUE;
end XNR3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR3D4_VITAL of XNR3D4 is
   for VITAL
   end for;
end CFG_XNR3D4_VITAL;


----- CELL XNR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR4D0 : entity is TRUE;
end XNR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR4D0_VITAL of XNR4D0 is
   for VITAL
   end for;
end CFG_XNR4D0_VITAL;


----- CELL XNR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR4D1 : entity is TRUE;
end XNR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR4D1_VITAL of XNR4D1 is
   for VITAL
   end for;
end CFG_XNR4D1_VITAL;


----- CELL XNR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR4D2 : entity is TRUE;
end XNR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR4D2_VITAL of XNR4D2 is
   for VITAL
   end for;
end CFG_XNR4D2_VITAL;


----- CELL XNR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XNR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_ZN                      :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      ZN                             :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XNR4D4 : entity is TRUE;
end XNR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XNR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS ZN_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE ZN_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      ZN_zd := (NOT ((A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd)));

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => ZN,
       GlitchData => ZN_GlitchData,
       OutSignalName => "ZN",
       OutTemp => ZN_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_ZN_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_ZN_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_ZN,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_ZN_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_ZN,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XNR4D4_VITAL of XNR4D4 is
   for VITAL
   end for;
end CFG_XNR4D4_VITAL;


----- CELL XOR2D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR2D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR2D0 : entity is TRUE;
end XOR2D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR2D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR2D0_VITAL of XOR2D0 is
   for VITAL
   end for;
end CFG_XOR2D0_VITAL;


----- CELL XOR2D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR2D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR2D1 : entity is TRUE;
end XOR2D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR2D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR2D1_VITAL of XOR2D1 is
   for VITAL
   end for;
end CFG_XOR2D1_VITAL;


----- CELL XOR2D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR2D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR2D2 : entity is TRUE;
end XOR2D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR2D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR2D2_VITAL of XOR2D2 is
   for VITAL
   end for;
end CFG_XOR2D2_VITAL;


----- CELL XOR2D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR2D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1               :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR2D4 : entity is TRUE;
end XOR2D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR2D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0,
                        (TO_X01((NOT A2_ipd))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1,
                        (TO_X01(A2_ipd)='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01(((NOT A2_ipd)) OR (A2_ipd))/='1')),
                 3 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0,
                        (TO_X01((NOT A1_ipd))='1')),
                 4 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1,
                        (TO_X01(A1_ipd)='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01(((NOT A1_ipd)) OR (A1_ipd))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR2D4_VITAL of XOR2D4 is
   for VITAL
   end for;
end CFG_XOR2D4_VITAL;


----- CELL XOR3D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR3D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR3D0 : entity is TRUE;
end XOR3D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR3D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR3D0_VITAL of XOR3D0 is
   for VITAL
   end for;
end CFG_XOR3D0_VITAL;


----- CELL XOR3D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR3D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR3D1 : entity is TRUE;
end XOR3D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR3D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR3D1_VITAL of XOR3D1 is
   for VITAL
   end for;
end CFG_XOR3D1_VITAL;


----- CELL XOR3D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR3D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR3D2 : entity is TRUE;
end XOR3D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR3D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR3D2_VITAL of XOR3D2 is
   for VITAL
   end for;
end CFG_XOR3D2_VITAL;


----- CELL XOR3D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR3D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1    :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR3D4 : entity is TRUE;
end XOR3D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR3D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd))) OR
                         ((A3_ipd) AND ((NOT A2_ipd))) OR (((NOT A3_ipd)) AND
                         (A2_ipd)) OR ((A3_ipd) AND (A2_ipd)))/='1')),
                 5 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)))='1')),
                 6 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)))='1')),
                 7 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd))='1')),
                 8 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd))='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd))) OR
                         ((A3_ipd) AND ((NOT A1_ipd))) OR (((NOT A3_ipd)) AND
                         (A1_ipd)) OR ((A3_ipd) AND (A1_ipd)))/='1')),
                 10 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)))='1')),
                 11 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)))='1')),
                 12 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd))='1')),
                 13 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd))='1')),
                 14 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd))) OR
                         ((A2_ipd) AND ((NOT A1_ipd))) OR (((NOT A2_ipd)) AND
                         (A1_ipd)) OR ((A2_ipd) AND (A1_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR3D4_VITAL of XOR3D4 is
   for VITAL
   end for;
end CFG_XOR3D4_VITAL;


----- CELL XOR4D0 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR4D0 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR4D0 : entity is TRUE;
end XOR4D0;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR4D0 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR4D0_VITAL of XOR4D0 is
   for VITAL
   end for;
end CFG_XOR4D0_VITAL;


----- CELL XOR4D1 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR4D1 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR4D1 : entity is TRUE;
end XOR4D1;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR4D1 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR4D1_VITAL of XOR4D1 is
   for VITAL
   end for;
end CFG_XOR4D1_VITAL;


----- CELL XOR4D2 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR4D2 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR4D2 : entity is TRUE;
end XOR4D2;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR4D2 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR4D2_VITAL of XOR4D2 is
   for VITAL
   end for;
end CFG_XOR4D2_VITAL;


----- CELL XOR4D4 -----
library IEEE;
use IEEE.STD_LOGIC_1164.all;
library IEEE;
use IEEE.VITAL_Timing.all;


-- entity declaration --
entity XOR4D4 is
   generic(
      TimingChecksOn: Boolean := True;
      InstancePath: STRING := "*";
      Xon: Boolean := False;
      MsgOn: Boolean := True;
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A1_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A2_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A3_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1 :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tpd_A4_Z                       :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A1                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A2                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A3                        :	VitalDelayType01 := (0.000 ns, 0.000 ns);
      tipd_A4                        :	VitalDelayType01 := (0.000 ns, 0.000 ns));

   port(
      A1                             :	in    STD_ULOGIC;
      A2                             :	in    STD_ULOGIC;
      A3                             :	in    STD_ULOGIC;
      A4                             :	in    STD_ULOGIC;
      Z                              :	out   STD_ULOGIC);
attribute VITAL_LEVEL0 of XOR4D4 : entity is TRUE;
end XOR4D4;

-- architecture body --
library IEEE;
use IEEE.VITAL_Primitives.all;
library work;
use work.VTABLES.all;
architecture VITAL of XOR4D4 is
   attribute VITAL_LEVEL1 of VITAL : architecture is TRUE;

   SIGNAL A1_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A2_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A3_ipd	 : STD_ULOGIC := 'X';
   SIGNAL A4_ipd	 : STD_ULOGIC := 'X';

begin

   ---------------------
   --  INPUT PATH DELAYs
   ---------------------
   WireDelay : block
   begin
   VitalWireDelay (A1_ipd, A1, tipd_A1);
   VitalWireDelay (A2_ipd, A2, tipd_A2);
   VitalWireDelay (A3_ipd, A3, tipd_A3);
   VitalWireDelay (A4_ipd, A4, tipd_A4);
   end block;
   --------------------
   --  BEHAVIOR SECTION
   --------------------
   VITALBehavior : process (A1_ipd, A2_ipd, A3_ipd, A4_ipd)


   -- functionality results
   VARIABLE Results : STD_LOGIC_VECTOR(1 to 1) := (others => 'X');
   ALIAS Z_zd : STD_LOGIC is Results(1);

   -- output glitch detection variables
   VARIABLE Z_GlitchData	: VitalGlitchDataType;

   begin

      -------------------------
      --  Functionality Section
      -------------------------
      Z_zd := (A2_ipd) XOR (A1_ipd) XOR (A3_ipd) XOR (A4_ipd);

      ----------------------
      --  Path Delay Section
      ----------------------
      VitalPathDelay01 (
       OutSignal => Z,
       GlitchData => Z_GlitchData,
       OutSignalName => "Z",
       OutTemp => Z_zd,
       Paths => (0 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 1 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 2 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 3 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd))='1')),
                 4 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 5 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd))='1')),
                 6 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 7 => (A1_ipd'last_event, tpd_A1_Z_A2_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A2_ipd) AND (A4_ipd))='1')),
                 8 => (A1_ipd'last_event, tpd_A1_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A2_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A2_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A2_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A2_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A2_ipd) AND
                         (A4_ipd)))/='1')),
                 9 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 10 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 11 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 12 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_0_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 13 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 14 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 15 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 16 => (A2_ipd'last_event, tpd_A2_Z_A1_EQ_1_AN_A3_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A3_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 17 => (A2_ipd'last_event, tpd_A2_Z,
                        (TO_X01((((NOT A3_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A3_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A3_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A3_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A3_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A3_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 18 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 19 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 20 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd)))='1')),
                 21 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_0_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd))='1')),
                 22 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 23 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_0_AN_A4_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd))='1')),
                 24 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd)))='1')),
                 25 => (A3_ipd'last_event, tpd_A3_Z_A1_EQ_1_AN_A2_EQ_1_AN_A4_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A4_ipd))='1')),
                 26 => (A3_ipd'last_event, tpd_A3_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A4_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A4_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A4_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A4_ipd)))/='1')),
                 27 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 28 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 29 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd)))='1')),
                 30 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_0_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd))='1')),
                 31 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_0,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 32 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_0_AN_A3_EQ_1,
                        (TO_X01(((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd))='1')),
                 33 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_0,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd)))='1')),
                 34 => (A4_ipd'last_event, tpd_A4_Z_A1_EQ_1_AN_A2_EQ_1_AN_A3_EQ_1,
                        (TO_X01((A2_ipd) AND (A1_ipd) AND (A3_ipd))='1')),
                 35 => (A4_ipd'last_event, tpd_A4_Z,
                        (TO_X01((((NOT A2_ipd)) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR ((A2_ipd) AND ((NOT A1_ipd)) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND ((NOT A1_ipd)) AND
                         (A3_ipd)) OR (((NOT A2_ipd)) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR (((NOT A2_ipd)) AND (A1_ipd) AND
                         (A3_ipd)) OR ((A2_ipd) AND (A1_ipd) AND ((NOT
                         A3_ipd))) OR ((A2_ipd) AND (A1_ipd) AND
                         (A3_ipd)))/='1'))),
       Mode => OnDetect,
       Xon => Xon,
       MsgOn => MsgOn,
       MsgSeverity => WARNING);

end process;

end VITAL;

configuration CFG_XOR4D4_VITAL of XOR4D4 is
   for VITAL
   end for;
end CFG_XOR4D4_VITAL;


---- end of library ----
