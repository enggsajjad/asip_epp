#include "larsix.h"
#include "lib_lcd.h"
#include "loadStoreByte.h"
#include "intToStr.h"


int create_switch(char* str, x1, y1, x2, y2, group) {
  static int curr_switch = 1;
  static int curr_group = 0;
  
  if (group < 0 || group > 256) return 1;
  
  if (curr_group != group && group != 0) {
    g_makeradiogroup(group);
    curr_group = group;
  }

  g_makeswitch(str, x1, y1, x2, y2, curr_switch, curr_switch++);

  switches[activeswitches].value = 0;
  switches[activeswitches].radio_group = group;
  switches[activeswitches].update = 1;

  activeswitches++;

  return 0;
}

// in case of error quits and returns a positive error code
//
// ERRORCODE 1:  missing ESC
// ERRORCODE 2:  unexpected symbol describing sending LCD item
// ERRORCODE 3:  wrong packet length
// ERRORCODE 4:  unexpected value in switch data-structure
// ERRORCODE 5:  unexpected data length
//

int poll_display() {
  char data[10];
  char text[10];
  int bytes_in_buffer;
  int temp;
  int i = 0;
  
  while (1) {
    // check if there is data to read in LCD buffer
    bytes_in_buffer = checkbuffer();

    if (bytes_in_buffer > 3) {

      //debug output
      intToStr(bytes_in_buffer, data);
      g_print("   \0", 0, 110);
      g_print(data, 0, 110);

      temp = getbytes(data, bytes_in_buffer);
      
      if (temp != bytes_in_buffer) return temp;
      
      // TODO check if (temp == bytes_in_buffer);
      while (i < bytes_in_buffer) {
	temp = loadByteUnsigned(data + i);
	i++;
	if (temp != 27) return 1;  // check for ESC
	temp = loadByteUnsigned(data + i);
	i++;
	switch (temp) {
	case 'A':	// touch switch button event
	  temp = loadByteUnsigned(data + i);
	  i++;
	  if (temp != 1) return 3;
	  temp = loadByteUnsigned(data + i); // return code of the switch
	  i++;
	  temp--; // because the array starts at 0, event codes start at 1
	  if (switches[temp].value == 1) switches[temp].value = 0;
	  else if (switches[temp].value == 0) switches[temp].value = 1;
	  else return 4;
	  switches[temp].update = 1;
	  i++;
	  break;

	case 'N':	// menu event
	  temp = loadByteUnsigned(data + i);
	  i++;
	  if (temp != 1) return 3;
	  temp = loadByteUnsigned(data + i); // return code of the switch
	  i++;
	  temp--; // because the array starts at 0, event codes start at 1
	  if (switches[temp].value == 1) switches[temp].value = 0;
	  else if (switches[temp].value == 0) switches[temp].value = 1;
	  else return 4;
	  switches[temp].update = 1;
	  i++;
	  break;

	case 'B':	// bargraph event
	  temp = loadByteUnsigned(data + i);
	  i++;
	  if (temp != 2) return 3;
	  temp = loadByteUnsigned(data + i); // number of the changed bar
	  i++;
	  temp--; // because the array starts at 0, event codes start at 1
 	  bars[temp].value = loadByteUnsigned(data + i);
	  bars[temp].update = 1;
	  i++;
	  break;

	case 'T':	// menu event to be handled by host
	  break;

	case 'H':	// free define touch event
	  break;

	default: // we should never go here !!
	  return 2;
	}

	if (i > bytes_in_buffer + 1) return 5;
      }
      i = 0;
    }

    switchThread();
  }
  return 0;
}

int test_poll() {
  char text[10];
  
  g_makeswitch("CSound\0", 20, 20, 70, 40, 1, 1);
  activeswitches++;

  g_makebar(10, 80, 160, 100, 8, 42, 20, 1, 1, 1);
  bars[activebars].value = 20;
  activebars++;
  
  
  while(1) {
    if (switches[0].update == 1) {
      intToStr(switches[0].value, text);
      g_print("   \0", 42, 60);
      g_print(text, 42, 60);
      switches[0].update = 0;
    }

    if (bars[0].update == 1) {
      intToStr(bars[0].value, text);
      g_print("   \0", 130, 60);
      g_print(text, 130, 60);
      bars[0].update = 0;
    }

    //  while(1)
    switchThread();
  }

  return 0;
}
